<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>-2</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">RedcliffSword</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=127402243</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Script" referent="RBX1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">global</string>
				<ProtectedString name="Source">function CreateSignal()
&#9;local this = {}
&#9;local mListeners = {}
&#9;local mListenerCount = 0
&#9;local mWaitProxy = nil
&#9;local mWaitReturns = nil
&#9;local mHasWaiters = false
&#9;function this:connect(func)
&#9;&#9;if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if type(func) ~= &apos;function&apos; then
&#9;&#9;&#9;error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
&#9;&#9;end
&#9;&#9;mListenerCount = mListenerCount + 1
&#9;&#9;local conn = {}
&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;if mListeners[conn] then
&#9;&#9;&#9;&#9;mListeners[conn] = nil
&#9;&#9;&#9;&#9;mListenerCount = mListenerCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;mListeners[conn] = func
&#9;&#9;return conn
&#9;end
&#9;function this:disconnect()
&#9;&#9;if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;for k, v in pairs(mListeners) do
&#9;&#9;&#9;mListeners[k] = nil
&#9;&#9;end
&#9;&#9;mListenerCount = 0
&#9;end
&#9;function this:wait()
&#9;&#9;if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if not mWaitProxy then
&#9;&#9;&#9;mWaitProxy = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;end
&#9;&#9;mHasWaiters = true
&#9;&#9;mWaitProxy.Changed:wait()
&#9;&#9;return unpack(mWaitReturns)
&#9;end
&#9;function this:fire(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function this:fireSync(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;end
&#9;&#9;end&#9;&#9;
&#9;end
&#9;return this
end
local function Create_PrivImpl(objectType)
&#9;if type(objectType) ~= &apos;string&apos; then
&#9;&#9;error(&quot;Argument of Create must be a string&quot;, 2)
&#9;end
&#9;return function(dat)
&#9;&#9;dat = dat or {}
&#9;&#9;local obj = Instance.new(objectType)
&#9;&#9;local ctor = nil
&#9;&#9;for k, v in pairs(dat) do
&#9;&#9;&#9;if type(k) == &apos;string&apos; then
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;elseif type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;userdata&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Numeric keys must be paired with children, got a: &quot;..type(v), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;elseif type(k) == &apos;table&apos; and k.__eventname then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create.E\&apos;&quot;..k.__eventname..&quot;\&apos;]` must have a function value\
&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj[k.__eventname]:connect(v)
&#9;&#9;&#9;elseif k == Create then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;elseif ctor then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Only one constructor function is allowed&quot;, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ctor = v
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Bad entry (&quot;..tostring(k)..&quot; =&gt; &quot;..tostring(v)..&quot;) in Create body&quot;, 2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if ctor then
&#9;&#9;&#9;ctor(obj)
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end
Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
Create.E = function(eventName)
&#9;return {__eventname = eventName}
end
function class(classname)
&#9;local classDef = {}
&#9;local mPublicMethods = {}
&#9;local mAllMethods = {}
&#9;local mGetters = {__ClassName = true}
&#9;local mSetters = {}
&#9;local mEvents = {}
&#9;local function fmtKey(key)
&#9;&#9;if type(key) == &apos;string&apos; then
&#9;&#9;&#9;return &apos;.&apos;..key
&#9;&#9;else
&#9;&#9;&#9;return &apos;[&apos;..tostring(key)..&apos;]&apos;
&#9;&#9;end
&#9;end
&#9;return function(implementer)
&#9;&#9;if type(implementer) ~= &apos;function&apos; then
&#9;&#9;&#9;error(&quot;Only functions ay be used as a class body definition, got a &quot;..type(implementer), 2)
&#9;&#9;end
&#9;&#9;local setProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.set&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;mSetters[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local getProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.get&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;mGetters[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.get&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local getsetProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.getset&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local eventProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Passing arguments to clasdef.event&quot;..fmtKey(key)..&quot;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if type(key) ~= &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t create event `&quot;..tostring(key)..&quot;` event names must be strings&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mEvents[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Redefinition of event `&quot;..key..&quot;`&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mEvents[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;__index = function()
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not indexed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;__newindex = function()
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not assigned to&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.event&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local staticProxy = setmetatable({}, {
&#9;&#9;&#9;__index = classDef,
&#9;&#9;&#9;__newindex = classDef,
&#9;&#9;})
&#9;&#9;local privateProxy = setmetatable({}, {
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.private&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get classdef.private&quot;..fmtKey(key), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local mainImplProxy = {}
&#9;&#9;mainImplProxy.get = getProxy
&#9;&#9;mainImplProxy.set = setProxy
&#9;&#9;mainImplProxy.getset = getsetProxy
&#9;&#9;mainImplProxy.event = eventProxy
&#9;&#9;mainImplProxy.private = privateProxy
&#9;&#9;mainImplProxy.static = staticProxy
&#9;&#9;setmetatable(mainImplProxy, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get classdef&apos;..fmtKey(key), 2)
&#9;&#9;&#9;end; 
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mPublicMethods[key] = val
&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;implementer(mainImplProxy)
&#9;&#9;for k, f in pairs(mAllMethods) do
&#9;&#9;&#9;if k ~= &apos;Create&apos; then
&#9;&#9;&#9;&#9;mAllMethods[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;if type(self) ~= &apos;table&apos; or self.__ClassName ~= classname then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Methods must be called with a &apos;:&apos;, not a &apos;.&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if mPublicMethods[k] then
&#9;&#9;&#9;&#9;&#9;mPublicMethods[k] = mAllMethods[k]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for k, f in pairs(mGetters) do
&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;mGetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for k, f in pairs(mSetters) do
&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;mSetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local internalMT = {
&#9;&#9;&#9;__index = mAllMethods;
&#9;&#9;}
&#9;&#9;local rawget = rawget 
&#9;&#9;local externalMT = {
&#9;&#9;&#9;__index = function(obj, key)
&#9;&#9;&#9;&#9;local method = mPublicMethods[key]
&#9;&#9;&#9;&#9;if method then
&#9;&#9;&#9;&#9;&#9;return method
&#9;&#9;&#9;&#9;elseif mGetters[key] == true then
&#9;&#9;&#9;&#9;&#9;return rawget(obj, &apos;__internal&apos;)[key]
&#9;&#9;&#9;&#9;elseif mGetters[key] then
&#9;&#9;&#9;&#9;&#9;return mGetters[key](obj)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(obj, key, val)
&#9;&#9;&#9;&#9;if mSetters[key] == true then
&#9;&#9;&#9;&#9;&#9;rawget(obj, &apos;__internal&apos;)[key] = val
&#9;&#9;&#9;&#9;elseif mSetters[key] then
&#9;&#9;&#9;&#9;&#9;mSetters[key](obj, val)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;}
&#9;&#9;local constructor = function(...)
&#9;&#9;&#9;local internalThis = {__ClassName = classname}
&#9;&#9;&#9;internalThis.__internal = internalThis
&#9;&#9;&#9;setmetatable(internalThis, internalMT)
&#9;&#9;&#9;local externalThis = {__internal = internalThis}
&#9;&#9;&#9;setmetatable(externalThis, externalMT)
&#9;&#9;&#9;for eventName, _ in pairs(mEvents) do
&#9;&#9;&#9;&#9;internalThis[eventName] = CreateSignal()
&#9;&#9;&#9;end
&#9;&#9;&#9;if mAllMethods.Create then
&#9;&#9;&#9;&#9;mAllMethods.Create(internalThis, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return externalThis
&#9;&#9;end
&#9;&#9;classDef.Create = constructor
&#9;&#9;getfenv(0)[&apos;Create&apos;..classname] = constructor
&#9;&#9;getfenv(0)[classname] = classDef
&#9;end
end


-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

--===============================================================================
-- A tree object for quick verification of the object hierarchy that a game or
-- gear may need to be present. The tree returns a &quot;filter&quot; function which can
-- be called on an instance to flatten it into a tag map, so that in the future
-- the objects in the hierarchy can safely be accessed through the tag map
-- without need for extra checks of existance. If the hierarchy is not valid
-- then nothing is returned from the call to the filter.
--
-- Below some common examples of how to construct a tree are given, and the
-- Gearlib includes the most common examples which veryify various parts of
-- the character depending on the needs of the gear.
--
--===============================================================================
function tree(name)
&#9;if type(name) == &apos;string&apos; then
&#9;&#9;return function(dat)
&#9;&#9;&#9;return function(instance, ctx)
&#9;&#9;&#9;&#9;local child = instance:FindFirstChild(name)
&#9;&#9;&#9;&#9;if not child then return false end 
&#9;&#9;&#9;&#9;if dat.IsA and not child:IsA(dat.IsA) then return false end
&#9;&#9;&#9;&#9;if dat.Tag then
&#9;&#9;&#9;&#9;&#9;ctx[dat.Tag] = child
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;if not dat[i](child, ctx) then return false end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;return function(dat)
&#9;&#9;&#9;return function(instance)
&#9;&#9;&#9;&#9;local ctx = {}
&#9;&#9;&#9;&#9;if dat.IsA and not instance:IsA(dat.IsA) then return nil end
&#9;&#9;&#9;&#9;if dat.Tag then ctx[dat.Tag] = instance end
&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;if not dat[i](instance, ctx) then return nil end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return ctx
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

--===============================================================================
-- A tree which verifys all parts of a character including legs.
-- Tags Declared:
--  Character: the root character model
--  LeftArm, RightArm, LeftLeg, RightLeg, Head: The appendages
--  Humanoid: The humanoid
--  
local CharacterFullTree = tree{
&#9;IsA = &apos;Model&apos;;
&#9;Tag = &apos;Character&apos;;
&#9;--
&#9;tree&apos;Left Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;};
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Left Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;};
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Head&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Head&apos;;
&#9;};
&#9;tree&apos;Humanoid&apos;{
&#9;&#9;IsA = &apos;Humanoid&apos;;
&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;};
}

--===============================================================================
-- A tree with just the parts for a basic gear.
-- Tags Declared:
--  Character: The root character object
--  RightArm
--  Torso
--  Humanoid
local CharacterRightArmTree = tree{
&#9;IsA = &apos;Model&apos;;
&#9;Tag = &apos;Character&apos;;
&#9;--
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Torso&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Torso&apos;;
&#9;};
&#9;tree&apos;Humanoid&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;};
}


--===============================================================================
-- A class for maintaining a list of assets that the gear uses. The assets can
-- be added as a list or one by one, and then requested as for various purposes,
-- such as as individual sounds or meshes, or more specifically such as for a set
-- of animations on a given humanoid.
class&apos;AssetProvider&apos;(function(def)
&#9;function def:Create()
&#9;&#9;self.Model = script.Parent:FindFirstChild(&apos;assets&apos;)
&#9;&#9;if not self.Model then
&#9;&#9;&#9;self.Model = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;Name = &quot;assets&quot;;
&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;}
&#9;&#9;end
&#9;end



&#9;--functionality to register various types of asset
&#9;function def:RegisterMesh(tag, id, scale)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local mesh = Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;MeshId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;}
&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;mesh.Scale = scale
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function def:RegisterAnim(tag, id, speed, fadeTime)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = Create&apos;Animation&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;AnimationId = self:ToAssetId(id);
&#9;&#9;&#9;}
&#9;&#9;&#9;if speed then
&#9;&#9;&#9;&#9;local speedObj = Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;speed&apos;;
&#9;&#9;&#9;&#9;&#9;Value = speed;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;speedObj.Parent = obj
&#9;&#9;&#9;&#9;print(&quot;Server Speed parent:&quot;, speed.Parent, &quot;shouldbe:&quot;, obj)
&#9;&#9;&#9;end
&#9;&#9;&#9;if fadeTime then
&#9;&#9;&#9;&#9;local fadeTimeObj = Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;fadeTime&apos;;
&#9;&#9;&#9;&#9;&#9;Value = fadeTime;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;fadeTimeObj.Parent = obj
&#9;&#9;&#9;end
&#9;&#9;&#9;obj.Parent = self.Model;
&#9;&#9;end
&#9;end

&#9;function def:RegisterSound(tag, id, volume, pitch)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local sound = Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;SoundId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;}
&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;&#9;end
&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;sound.Pitch = pitch
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end



&#9;--functionality to create instances of various asset types
&#9;function def:CreateSound(tag, volume, pitch)
&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;obj.Volume = volume
&#9;&#9;&#9;end
&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;obj.Pitch = pitch
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end

&#9;function def:CreateMesh(tag, scale)
&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;obj.Scale = scale
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end

&#9;function def:CreateAnimator(humanoid)
&#9;&#9;local anims = {}
&#9;&#9;for _, anim in pairs(self.Model:GetChildren()) do
&#9;&#9;&#9;if anim:IsA(&apos;Animation&apos;) then
&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local proxy = {}
&#9;&#9;&#9;&#9;local defaultSpeed, defaultFade;
&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;speed&apos;) then
&#9;&#9;&#9;&#9;&#9;defaultSpeed = anim:FindFirstChild(&apos;speed&apos;).Value
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;fadeTime&apos;) then
&#9;&#9;&#9;&#9;&#9;defaultFade = anim:FindFirstChild(&apos;fadeTime&apos;).Value
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;function proxy:Play(speed, fadeTime)
&#9;&#9;&#9;&#9;&#9;track:Play(fadeTime or defaultFade or 0.1, 1, speed or defaultSpeed or 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;function proxy:Stop(fadeTime)
&#9;&#9;&#9;&#9;&#9;track:Stop(fadeTime or defaultFade or 0.1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;proxy.KeyframeReached = track.KeyframeReached
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;anims[anim.Name] = proxy
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;--
&#9;&#9;local animator = setmetatable({}, {__index=anims})
&#9;&#9;function animator:StopAll(fadeTime)
&#9;&#9;&#9;for _, anim in pairs(anims) do
&#9;&#9;&#9;&#9;anim:Stop(fadeTime)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return animator
&#9;end

&#9;function def.private:ToAssetId(id)
&#9;&#9;if type(id) == &apos;string&apos; then
&#9;&#9;&#9;return id
&#9;&#9;elseif type(id) == &apos;number&apos; then
&#9;&#9;&#9;return &apos;http://www.roblox.com/asset/?id=&apos;..id
&#9;&#9;end
&#9;end
end)


function CreateMutexFunction(task)
&#9;local running = false
&#9;return function(...)
&#9;&#9;if not running then
&#9;&#9;&#9;return task(...)
&#9;&#9;end
&#9;end
end


function CreateGlobalVarList()
&#9;local this = {}
&#9;local waitingOn = {}
&#9;--
&#9;local data = script.Parent:FindFirstChild(&apos;data&apos;)
&#9;if not data then
&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;data = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;Name = &apos;data&apos;;
&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;}&#9;
&#9;&#9;else
&#9;&#9;&#9;repeat wait() until script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;&#9;data = script.Parent:FindFirstChild(&apos;data&apos;)&#9;&#9;&#9;
&#9;&#9;end
&#9;end
&#9;--
&#9;function this:Create(tag, type, default)
&#9;&#9;if not data:FindFirstChild(tag) then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;Create(type..&apos;Value&apos;){
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;Parent = data;
&#9;&#9;&#9;&#9;&#9;Value = default;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;waitingOn[tag] = true
&#9;&#9;&#9;&#9;repeat wait() until data:FindFirstChild(tag)
&#9;&#9;&#9;&#9;waitingOn[tag] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;setmetatable(this, {
&#9;&#9;__index = function(tb, inx)
&#9;&#9;&#9;if inx == &apos;Create&apos; then
&#9;&#9;&#9;&#9;return this.Create
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local val = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;if val then
&#9;&#9;&#9;&#9;&#9;return val.Value
&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;return data[inx].Value
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end;
&#9;&#9;__newindex = function(tb, inx, val)
&#9;&#9;&#9;local obj = data:FindFirstChild(inx)
&#9;&#9;&#9;if obj then
&#9;&#9;&#9;&#9;obj.Value = val
&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;data[inx].Value = val
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;end
&#9;&#9;end;
&#9;})
&#9;return this
end


class&apos;Tool&apos;(function(def)
&#9;function def:Create()
&#9;&#9;self.Tool = script.Parent
&#9;&#9;local tool = script.Parent
&#9;&#9;self.Handle = tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;if not self.Handle then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;repeat wait() until tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;&#9;self.Handle = tool.Handle
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Tool has no `Handle`, did you forget to add one?&quot;)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--see which side we&apos;re on, localscript or normal script:
&#9;&#9;local IsLocal = script:IsA(&apos;LocalScript&apos;)

&#9;&#9;--set up the damage bin in the tool, so that damage can be inflicted
&#9;&#9;--from a localscript. The global script side has to create a &quot;damagebin&quot;
&#9;&#9;--in the tool, and the local side of the tool then puts notifications
&#9;&#9;--into that madel.
&#9;&#9;if IsLocal then
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;while not tool:FindFirstChild(&apos;damagebin&apos;) do
&#9;&#9;&#9;&#9;&#9;tool.ChildAdded:wait()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;if not self.DamageBin then
&#9;&#9;&#9;&#9;self.DamageBin = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;damagebin&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = tool;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;end
&#9;&#9;&#9;--and listen on the damage bin
&#9;&#9;&#9;self.DamageBin.ChildAdded:connect(function(ch)
&#9;&#9;&#9;&#9;local dmg = tonumber(ch.Name)
&#9;&#9;&#9;&#9;--tag the humanoid
&#9;&#9;&#9;&#9;local creator = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;creator&apos;;
&#9;&#9;&#9;&#9;&#9;Value = self.Player;
&#9;&#9;&#9;&#9;&#9;Parent = ch.Value;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;ch.Value:TakeDamage(dmg)
&#9;&#9;&#9;&#9;game.Debris:AddItem(ch, 2)
&#9;&#9;&#9;&#9;game.Debris:AddItem(creator, 2)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;--create the asset manager
&#9;&#9;self.Asset = CreateAssetProvider()

&#9;&#9;--create the global var list
&#9;&#9;self.Var = CreateGlobalVarList()

&#9;&#9;--
&#9;&#9;tool.Equipped:connect(function(mouse)
&#9;&#9;&#9;--main properties set on selection
&#9;&#9;&#9;self.Mouse = mouse
&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;self.Selected = true
&#9;&#9;&#9;
&#9;&#9;&#9;--set up convinience properties
&#9;&#9;&#9;self.Character = tool.Parent
&#9;&#9;&#9;self.Player = game.Players:GetPlayerFromCharacter(self.Character)
&#9;&#9;&#9;self.Head = self.Character:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;self.Torso = self.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;self.Humanoid = self.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;self.LeftLeg = self.Character:FindFirstChild(&apos;Left Leg&apos;)
&#9;&#9;&#9;self.RightLeg = self.Character:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;&#9;self.LeftArm = self.Character:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;self.RightArm = self.Character:FindFirstChild(&apos;Right Arm&apos;)

&#9;&#9;&#9;--create main the animator for this instance. It won&apos;t be usefull from the
&#9;&#9;&#9;--global side right now, but it may be in the future, and it is an abstraction
&#9;&#9;&#9;--so it is possible to make it work even from the global side.
&#9;&#9;&#9;self.Animator = self.Asset:CreateAnimator(self.Humanoid)
&#9;&#9;&#9;
&#9;&#9;&#9;--if local, set up the mouse events
&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;&#9;self.MouseDown = true
&#9;&#9;&#9;&#9;&#9;self.Button1Down:fire()
&#9;&#9;&#9;&#9;end)&#9;
&#9;&#9;&#9;&#9;mouse.Button1Up:connect(function()
&#9;&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;&#9;self.Button1Up:fire()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;&#9;&#9;self.KeyDown:fire(key)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;mouse.KeyUp:connect(function(key)
&#9;&#9;&#9;&#9;&#9;self.KeyUp:fire(key)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--finally, pass off to the user
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;self.Equipped:fire()
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;tool.Unequipped:connect(function()
&#9;&#9;&#9;-- FIRST give the tool a chance to do stuff with these properties
&#9;&#9;&#9;-- before we kill them. That is, the unequipped event fires before
&#9;&#9;&#9;-- the thing is really unequipped.
&#9;&#9;&#9;self.Unequipped:fireSync()

&#9;&#9;&#9;--unset convinience properties
&#9;&#9;&#9;self.Selected = false
&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;self.Mouse = nil
&#9;&#9;&#9;self.Character = nil
&#9;&#9;&#9;--
&#9;&#9;&#9;self.Head = nil
&#9;&#9;&#9;self.Torso = nil
&#9;&#9;&#9;self.Humanoid = nil
&#9;&#9;&#9;self.LeftArm = nil
&#9;&#9;&#9;self.RightArm = nil
&#9;&#9;&#9;self.LeftLeg = nil
&#9;&#9;&#9;self.RightLeg = nil
&#9;&#9;&#9;
&#9;&#9;&#9;--kill the old animator. We may be able to reuse it some of the time
&#9;&#9;&#9;--but the most common use cases are ones where it&apos;s not possible to save, so
&#9;&#9;&#9;--it&apos;s not worth the extra code comlexity to figure out when we can save it.
&#9;&#9;&#9;self.Animator = nil
&#9;&#9;end)
&#9;end

&#9;function def:DamageHumanoid(humanoid, damage)
&#9;&#9;if self.DamageBin then
&#9;&#9;&#9;(Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;}).Parent = self.DamageBin
&#9;&#9;else
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;repeat wait() until self.DamageBin
&#9;&#9;&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;}.Parent = self.DamageBin
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;--============================
&#9;def.get.Tool()
&#9;def.get.Player()
&#9;def.get.Mouse()
&#9;def.get.MouseDown()
&#9;def.get.Selected()
&#9;function def.get:MouseTarget()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Target
&#9;&#9;end
&#9;end
&#9;function def.get:MouseHit()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Hit
&#9;&#9;end
&#9;end
&#9;function def.get:MouseIcon()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Icon
&#9;&#9;end
&#9;end
&#9;function def.set:MouseIcon(icon)
&#9;&#9;if not self.Mouse then
&#9;&#9;&#9;error(&quot;Error, Can&apos;t set MouseIcon from a global script!&quot;)
&#9;&#9;end
&#9;&#9;self.Mouse.Icon = icon
&#9;end
&#9;--
&#9;def.get.Character()
&#9;def.get.Humanoid()
&#9;def.get.LeftArm()
&#9;def.get.RightArm()
&#9;def.get.LeftLeg()
&#9;def.get.RightLeg()
&#9;def.get.Head()
&#9;def.get.Torso()
&#9;def.get.Handle()
&#9;--
&#9;def.get.Asset()
&#9;def.get.Animator()
&#9;def.get.Var()

&#9;--=============================
&#9;def.event.Equipped()
&#9;def.event.Unequipped()
&#9;--
&#9;def.event.Button1Down()
&#9;def.event.Button1Up()
&#9;def.event.KeyDown()
&#9;def.event.KeyUp()
end)

local Tool = CreateTool()

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


--====================================================================================--
--                                 asset setup code
--====================================================================================--

--meshes
Tool.Asset:RegisterMesh(&apos;swordmesh&apos;,    127402519)
Tool.Asset:RegisterMesh(&apos;shieldmesh&apos;,   127402561)


--animations
Tool.Asset:RegisterAnim(&apos;firstequip&apos;,   79155144)
Tool.Asset:RegisterAnim(&apos;slash&apos;,        79155154)
--
Tool.Asset:RegisterAnim(&apos;entershield&apos;,  79155126)
Tool.Asset:RegisterAnim(&apos;walkshield&apos;,   79155174)
Tool.Asset:RegisterAnim(&apos;exitshield&apos;,   79155149)
--
Tool.Asset:RegisterAnim(&apos;begincharge&apos;,  79155105)
Tool.Asset:RegisterAnim(&apos;charge&apos;,       79155114)
Tool.Asset:RegisterAnim(&apos;endcharge&apos;,    79155124)
--
Tool.Asset:RegisterAnim(&apos;stash&apos;,        79155162)
Tool.Asset:RegisterAnim(&apos;equip2&apos;,       79155042)
Tool.Asset:RegisterAnim(&apos;hold2&apos;,        79155055)
Tool.Asset:RegisterAnim(&apos;slash2&apos;,       79155062)
Tool.Asset:RegisterAnim(&apos;taunt2&apos;,       79155095)
Tool.Asset:RegisterAnim(&apos;stash2&apos;,       79155073)
Tool.Asset:RegisterAnim(&apos;equip1&apos;,       79155032)


--sounds
Tool.Asset:RegisterSound(&apos;slashsharp&apos;,  45885030)
Tool.Asset:RegisterSound(&apos;swoosh2&apos;,     &apos;SOUND_doubleswoosh&apos;)
Tool.Asset:RegisterSound(&apos;swoosh&apos;,      &apos;SOUND_swoosh&apos;)
Tool.Asset:RegisterSound(&apos;equipsound&apos;,  &apos;SOUND_equip&apos;)
Tool.Asset:RegisterSound(&apos;shieldstow&apos;,  &apos;SOUND_shieldstow&apos;)


--global variables
Tool.Var:Create(&apos;shield&apos;,     &apos;Int&apos;,  350)
Tool.Var:Create(&apos;shieldmode&apos;, &apos;Bool&apos;, false)
Tool.Var:Create(&apos;special&apos;,    &apos;Bool&apos;, false)


-----------------------------------
Tool.Equipped:connect(function()
&#9;local oldHealth = Tool.Humanoid.Health
&#9;Tool.Humanoid.HealthChanged:connect(function()
&#9;&#9;local newHealth = Tool.Humanoid.Health
&#9;&#9;local damage = oldHealth-newHealth
&#9;&#9;if damage &gt; 0 then
&#9;&#9;&#9;if Tool.Var.shieldmode then
&#9;&#9;&#9;&#9;--if shielded, take the full damage to the shield
&#9;&#9;&#9;&#9;local toHeal = math.min(damage, Tool.Var.shield)
&#9;&#9;&#9;&#9;Tool.Humanoid.Health = Tool.Humanoid.Health + toHeal
&#9;&#9;&#9;&#9;Tool.Var.shield = Tool.Var.shield - toHeal

&#9;&#9;&#9;elseif Tool.Var.special then
&#9;&#9;&#9;&#9;--if they&apos;re in special, reduce the damage by 50%
&#9;&#9;&#9;&#9;local toHeal = math.min(0.5*damage, Tool.Var.shield)
&#9;&#9;&#9;&#9;Tool.Humanoid.Health = Tool.Humanoid.Health + toHeal
&#9;&#9;&#9;&#9;Tool.Var.shield = Tool.Var.shield - toHeal
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;oldHealth = Tool.Humanoid.Health
&#9;end)
&#9;while Tool.Selected do
&#9;&#9;if Tool.Humanoid.Health &lt; 100 and Tool.Var.shieldmode and Tool.Var.shield &gt; 0 then
&#9;&#9;&#9;local toHeal = math.min(Tool.Var.shield, math.min(3, (100-Tool.Humanoid.Health)))
&#9;&#9;&#9;Tool.Var.shield = Tool.Var.shield - toHeal
&#9;&#9;&#9;Tool.Humanoid.Health = Tool.Humanoid.Health + toHeal
&#9;&#9;end
&#9;&#9;wait(0.2)
&#9;end
end)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX2">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">local</string>
				<ProtectedString name="Source">function CreateSignal()
&#9;local this = {}
&#9;local mListeners = {}
&#9;local mListenerCount = 0
&#9;local mWaitProxy = nil
&#9;local mWaitReturns = nil
&#9;local mHasWaiters = false
&#9;function this:connect(func)
&#9;&#9;if self ~= this then error(&quot;connect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if type(func) ~= &apos;function&apos; then
&#9;&#9;&#9;error(&quot;Argument #1 of connect must be a function, got a &quot;..type(func), 2)
&#9;&#9;end
&#9;&#9;mListenerCount = mListenerCount + 1
&#9;&#9;local conn = {}
&#9;&#9;function conn:disconnect()
&#9;&#9;&#9;if mListeners[conn] then
&#9;&#9;&#9;&#9;mListeners[conn] = nil
&#9;&#9;&#9;&#9;mListenerCount = mListenerCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;mListeners[conn] = func
&#9;&#9;return conn
&#9;end
&#9;function this:disconnect()
&#9;&#9;if self ~= this then error(&quot;disconnect must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;for k, v in pairs(mListeners) do
&#9;&#9;&#9;mListeners[k] = nil
&#9;&#9;end
&#9;&#9;mListenerCount = 0
&#9;end
&#9;function this:wait()
&#9;&#9;if self ~= this then error(&quot;wait must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;if not mWaitProxy then
&#9;&#9;&#9;mWaitProxy = Instance.new(&apos;BoolValue&apos;)
&#9;&#9;end
&#9;&#9;mHasWaiters = true
&#9;&#9;mWaitProxy.Changed:wait()
&#9;&#9;return unpack(mWaitReturns)
&#9;end
&#9;function this:fire(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;function this:fireSync(...)
&#9;&#9;if self ~= this then error(&quot;fire must be called with `:`, not `.`&quot;, 2) end
&#9;&#9;local arguments;
&#9;&#9;if mListenerCount &gt; 0 or mHasWaiters then
&#9;&#9;&#9;arguments = {...}
&#9;&#9;end
&#9;&#9;if mHasWaiters then
&#9;&#9;&#9;mHasWaiters = false
&#9;&#9;&#9;mWaitReturns = arguments
&#9;&#9;&#9;mWaitProxy.Value = not mWaitProxy.Value
&#9;&#9;&#9;mWaitReturns = nil
&#9;&#9;end
&#9;&#9;if mListenerCount &gt; 0 then
&#9;&#9;&#9;for _, handlerFunc in pairs(mListeners) do
&#9;&#9;&#9;&#9;handlerFunc(unpack(arguments))
&#9;&#9;&#9;end
&#9;&#9;end&#9;&#9;
&#9;end
&#9;return this
end
local function Create_PrivImpl(objectType)
&#9;if type(objectType) ~= &apos;string&apos; then
&#9;&#9;error(&quot;Argument of Create must be a string&quot;, 2)
&#9;end
&#9;return function(dat)
&#9;&#9;dat = dat or {}
&#9;&#9;local obj = Instance.new(objectType)
&#9;&#9;local ctor = nil
&#9;&#9;for k, v in pairs(dat) do
&#9;&#9;&#9;if type(k) == &apos;string&apos; then
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;elseif type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;userdata&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Numeric keys must be paired with children, got a: &quot;..type(v), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;elseif type(k) == &apos;table&apos; and k.__eventname then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create.E\&apos;&quot;..k.__eventname..&quot;\&apos;]` must have a function value\
&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj[k.__eventname]:connect(v)
&#9;&#9;&#9;elseif k == Create then
&#9;&#9;&#9;&#9;if type(v) ~= &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
&#9;&#9;&#9;&#9;&#9;       got: &quot;..tostring(v), 2)
&#9;&#9;&#9;&#9;elseif ctor then
&#9;&#9;&#9;&#9;&#9;error(&quot;Bad entry in Create body: Only one constructor function is allowed&quot;, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;ctor = v
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Bad entry (&quot;..tostring(k)..&quot; =&gt; &quot;..tostring(v)..&quot;) in Create body&quot;, 2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if ctor then
&#9;&#9;&#9;ctor(obj)
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end
Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
Create.E = function(eventName)
&#9;return {__eventname = eventName}
end
function class(classname)
&#9;local classDef = {}
&#9;local mPublicMethods = {}
&#9;local mAllMethods = {}
&#9;local mGetters = {__ClassName = true}
&#9;local mSetters = {}
&#9;local mEvents = {}
&#9;local function fmtKey(key)
&#9;&#9;if type(key) == &apos;string&apos; then
&#9;&#9;&#9;return &apos;.&apos;..key
&#9;&#9;else
&#9;&#9;&#9;return &apos;[&apos;..tostring(key)..&apos;]&apos;
&#9;&#9;end
&#9;end
&#9;return function(implementer)
&#9;&#9;if type(implementer) ~= &apos;function&apos; then
&#9;&#9;&#9;error(&quot;Only functions ay be used as a class body definition, got a &quot;..type(implementer), 2)
&#9;&#9;end
&#9;&#9;local setProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.set&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;mSetters[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local getProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.get&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;mGetters[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.get&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local getsetProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Passing arguments to classdef.getset&apos;..fmtKey(key)..&apos;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&apos;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mSetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of setter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mGetters[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&apos;Redefinition of getter for &apos;..tostring(key), 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mSetters[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef.set&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local eventProxy = setmetatable({}, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;return setmetatable({}, {
&#9;&#9;&#9;&#9;&#9;__call = function(tb, ...)
&#9;&#9;&#9;&#9;&#9;&#9;if #{...} &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Passing arguments to clasdef.event&quot;..fmtKey(key)..&quot;() has no meaning, \
&#9;&#9;&#9;&#9;&#9;&#9;&#9;       see documentation for correct usage.&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if type(key) ~= &apos;string&apos; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t create event `&quot;..tostring(key)..&quot;` event names must be strings&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if mEvents[key] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Redefinition of event `&quot;..key..&quot;`&quot;, 2)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;mEvents[key] = true
&#9;&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;__index = function()
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not indexed&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;&#9;__newindex = function()
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;classdef.event&quot;..fmtKey(key)..&quot; can only be called, not assigned to&quot;, 2)
&#9;&#9;&#9;&#9;&#9;end;
&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.event&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local staticProxy = setmetatable({}, {
&#9;&#9;&#9;__index = classDef,
&#9;&#9;&#9;__newindex = classDef,
&#9;&#9;})
&#9;&#9;local privateProxy = setmetatable({}, {
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set classdef.private&quot;..fmtKey(key)..&quot; = &quot;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get classdef.private&quot;..fmtKey(key), 2)
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;local mainImplProxy = {}
&#9;&#9;mainImplProxy.get = getProxy
&#9;&#9;mainImplProxy.set = setProxy
&#9;&#9;mainImplProxy.getset = getsetProxy
&#9;&#9;mainImplProxy.event = eventProxy
&#9;&#9;mainImplProxy.private = privateProxy
&#9;&#9;mainImplProxy.static = staticProxy
&#9;&#9;setmetatable(mainImplProxy, {
&#9;&#9;&#9;__index = function(tb, key)
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get classdef&apos;..fmtKey(key), 2)
&#9;&#9;&#9;end; 
&#9;&#9;&#9;__newindex = function(tb, key, val)
&#9;&#9;&#9;&#9;if type(key) == &apos;string&apos; and type(val) == &apos;function&apos; then
&#9;&#9;&#9;&#9;&#9;mPublicMethods[key] = val
&#9;&#9;&#9;&#9;&#9;mAllMethods[key] = val
&#9;&#9;&#9;&#9;&#9;mGetters[key] = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set classdef&apos;..fmtKey(key)..&apos; = &apos;..tostring(val), 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;})
&#9;&#9;implementer(mainImplProxy)
&#9;&#9;for k, f in pairs(mAllMethods) do
&#9;&#9;&#9;if k ~= &apos;Create&apos; then
&#9;&#9;&#9;&#9;mAllMethods[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;if type(self) ~= &apos;table&apos; or self.__ClassName ~= classname then
&#9;&#9;&#9;&#9;&#9;&#9;error(&quot;Methods must be called with a &apos;:&apos;, not a &apos;.&apos;&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if mPublicMethods[k] then
&#9;&#9;&#9;&#9;&#9;mPublicMethods[k] = mAllMethods[k]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for k, f in pairs(mGetters) do
&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;mGetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for k, f in pairs(mSetters) do
&#9;&#9;&#9;if type(f) == &apos;function&apos; then
&#9;&#9;&#9;&#9;mSetters[k] = function(self, ...)
&#9;&#9;&#9;&#9;&#9;return f(rawget(self, &apos;__internal&apos;), ...)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local internalMT = {
&#9;&#9;&#9;__index = mAllMethods;
&#9;&#9;}
&#9;&#9;local rawget = rawget 
&#9;&#9;local externalMT = {
&#9;&#9;&#9;__index = function(obj, key)
&#9;&#9;&#9;&#9;local method = mPublicMethods[key]
&#9;&#9;&#9;&#9;if method then
&#9;&#9;&#9;&#9;&#9;return method
&#9;&#9;&#9;&#9;elseif mGetters[key] == true then
&#9;&#9;&#9;&#9;&#9;return rawget(obj, &apos;__internal&apos;)[key]
&#9;&#9;&#9;&#9;elseif mGetters[key] then
&#9;&#9;&#9;&#9;&#9;return mGetters[key](obj)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t get &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;&#9;__newindex = function(obj, key, val)
&#9;&#9;&#9;&#9;if mSetters[key] == true then
&#9;&#9;&#9;&#9;&#9;rawget(obj, &apos;__internal&apos;)[key] = val
&#9;&#9;&#9;&#9;elseif mSetters[key] then
&#9;&#9;&#9;&#9;&#9;mSetters[key](obj, val)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&quot;Can&apos;t set &quot;..classname..&quot;::&quot;..key, 2)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end;
&#9;&#9;}
&#9;&#9;local constructor = function(...)
&#9;&#9;&#9;local internalThis = {__ClassName = classname}
&#9;&#9;&#9;internalThis.__internal = internalThis
&#9;&#9;&#9;setmetatable(internalThis, internalMT)
&#9;&#9;&#9;local externalThis = {__internal = internalThis}
&#9;&#9;&#9;setmetatable(externalThis, externalMT)
&#9;&#9;&#9;for eventName, _ in pairs(mEvents) do
&#9;&#9;&#9;&#9;internalThis[eventName] = CreateSignal()
&#9;&#9;&#9;end
&#9;&#9;&#9;if mAllMethods.Create then
&#9;&#9;&#9;&#9;mAllMethods.Create(internalThis, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return externalThis
&#9;&#9;end
&#9;&#9;classDef.Create = constructor
&#9;&#9;getfenv(0)[&apos;Create&apos;..classname] = constructor
&#9;&#9;getfenv(0)[classname] = classDef
&#9;end
end


-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------

--===============================================================================
-- A tree object for quick verification of the object hierarchy that a game or
-- gear may need to be present. The tree returns a &quot;filter&quot; function which can
-- be called on an instance to flatten it into a tag map, so that in the future
-- the objects in the hierarchy can safely be accessed through the tag map
-- without need for extra checks of existance. If the hierarchy is not valid
-- then nothing is returned from the call to the filter.
--
-- Below some common examples of how to construct a tree are given, and the
-- Gearlib includes the most common examples which veryify various parts of
-- the character depending on the needs of the gear.
--
--===============================================================================
function tree(name)
&#9;if type(name) == &apos;string&apos; then
&#9;&#9;return function(dat)
&#9;&#9;&#9;return function(instance, ctx)
&#9;&#9;&#9;&#9;local child = instance:FindFirstChild(name)
&#9;&#9;&#9;&#9;if not child then return false end 
&#9;&#9;&#9;&#9;if dat.IsA and not child:IsA(dat.IsA) then return false end
&#9;&#9;&#9;&#9;if dat.Tag then
&#9;&#9;&#9;&#9;&#9;ctx[dat.Tag] = child
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;if not dat[i](child, ctx) then return false end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;return function(dat)
&#9;&#9;&#9;return function(instance)
&#9;&#9;&#9;&#9;local ctx = {}
&#9;&#9;&#9;&#9;if dat.IsA and not instance:IsA(dat.IsA) then return nil end
&#9;&#9;&#9;&#9;if dat.Tag then ctx[dat.Tag] = instance end
&#9;&#9;&#9;&#9;for i = 1, #dat do
&#9;&#9;&#9;&#9;&#9;if not dat[i](instance, ctx) then return nil end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return ctx
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

--===============================================================================
-- A tree which verifys all parts of a character including legs.
-- Tags Declared:
--  Character: the root character model
--  LeftArm, RightArm, LeftLeg, RightLeg, Head: The appendages
--  Humanoid: The humanoid
--  
local CharacterFullTree = tree{
&#9;IsA = &apos;Model&apos;;
&#9;Tag = &apos;Character&apos;;
&#9;--
&#9;tree&apos;Left Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;};
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Left Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;LeftArm&apos;;
&#9;};
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Head&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Head&apos;;
&#9;};
&#9;tree&apos;Humanoid&apos;{
&#9;&#9;IsA = &apos;Humanoid&apos;;
&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;};
}

--===============================================================================
-- A tree with just the parts for a basic gear.
-- Tags Declared:
--  Character: The root character object
--  RightArm
--  Torso
--  Humanoid
local CharacterRightArmTree = tree{
&#9;IsA = &apos;Model&apos;;
&#9;Tag = &apos;Character&apos;;
&#9;--
&#9;tree&apos;Right Arm&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;RightArm&apos;;
&#9;};
&#9;tree&apos;Torso&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Torso&apos;;
&#9;};
&#9;tree&apos;Humanoid&apos;{
&#9;&#9;IsA = &apos;BasePart&apos;;
&#9;&#9;Tag = &apos;Humanoid&apos;;
&#9;};
}


--===============================================================================
-- A class for maintaining a list of assets that the gear uses. The assets can
-- be added as a list or one by one, and then requested as for various purposes,
-- such as as individual sounds or meshes, or more specifically such as for a set
-- of animations on a given humanoid.
class&apos;AssetProvider&apos;(function(def)
&#9;function def:Create()
&#9;&#9;self.Model = script.Parent:FindFirstChild(&apos;assets&apos;)
&#9;&#9;if not self.Model then
&#9;&#9;&#9;self.Model = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;Name = &quot;assets&quot;;
&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;}
&#9;&#9;end
&#9;end



&#9;--functionality to register various types of asset
&#9;function def:RegisterMesh(tag, id, scale)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local mesh = Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;MeshId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;}
&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;mesh.Scale = scale
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function def:RegisterAnim(tag, id, speed, fadeTime)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = Create&apos;Animation&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;AnimationId = self:ToAssetId(id);
&#9;&#9;&#9;}
&#9;&#9;&#9;if speed then
&#9;&#9;&#9;&#9;local speedObj = Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;speed&apos;;
&#9;&#9;&#9;&#9;&#9;Value = speed;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;speedObj.Parent = obj
&#9;&#9;&#9;end
&#9;&#9;&#9;if fadeTime then
&#9;&#9;&#9;&#9;local fadeTimeObj = Create&apos;NumberValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;fadeTime&apos;;
&#9;&#9;&#9;&#9;&#9;Value = fadeTime;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;fadeTimeObj.Parent = obj
&#9;&#9;&#9;end
&#9;&#9;&#9;obj.Parent = self.Model;
&#9;&#9;end
&#9;end

&#9;function def:RegisterSound(tag, id, volume, pitch)
&#9;&#9;if not self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local sound = Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;SoundId = self:ToAssetId(id);
&#9;&#9;&#9;&#9;Parent = self.Model;
&#9;&#9;&#9;}
&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;sound.Volume = volume
&#9;&#9;&#9;end
&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;sound.Pitch = pitch
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end



&#9;--functionality to create instances of various asset types
&#9;function def:CreateSound(tag, volume, pitch)
&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;if volume then
&#9;&#9;&#9;&#9;obj.Volume = volume
&#9;&#9;&#9;end
&#9;&#9;&#9;if pitch then
&#9;&#9;&#9;&#9;obj.Pitch = pitch
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end
&#9;
&#9;function def:PlaySound(tag)
&#9;&#9;Spawn(function()
&#9;&#9;&#9;local handle = script.Parent:WaitForChild(&apos;Handle&apos;)
&#9;&#9;&#9;if not handle:FindFirstChild(tag) and self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;self.Model:FindFirstChild(tag):Clone().Parent = handle
&#9;&#9;&#9;end
&#9;&#9;&#9;if handle:FindFirstChild(tag) then
&#9;&#9;&#9;&#9;handle:FindFirstChild(tag):Play()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;function def:CreateMesh(tag, scale)
&#9;&#9;if self.Model:FindFirstChild(tag) then
&#9;&#9;&#9;local obj = self.Model:FindFirstChild(tag):Clone()
&#9;&#9;&#9;if scale then
&#9;&#9;&#9;&#9;obj.Scale = scale
&#9;&#9;&#9;end
&#9;&#9;&#9;return obj
&#9;&#9;end
&#9;end

&#9;function def:CreateAnimator(humanoid)
&#9;&#9;local anims = {}
&#9;&#9;local function HandleChild(anim)
&#9;&#9;&#9;if anim:IsA(&apos;Animation&apos;) then
&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local proxy = {}
&#9;&#9;&#9;&#9;local defaultSpeed, defaultFade;
&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;speed&apos;) then
&#9;&#9;&#9;&#9;&#9;defaultSpeed = anim:FindFirstChild(&apos;speed&apos;).Value
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if anim:FindFirstChild(&apos;fadeTime&apos;) then
&#9;&#9;&#9;&#9;&#9;defaultFade = anim:FindFirstChild(&apos;fadeTime&apos;).Value
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;function proxy:Play(speed, fadeTime)
&#9;&#9;&#9;&#9;&#9;track:Play(fadeTime or defaultFade or 0.1, 1, speed or defaultSpeed or 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;function proxy:AdjustSpeed(speedFrac)
&#9;&#9;&#9;&#9;&#9;track:AdjustSpeed((speed or defaultSpeed or 1)*speedFrac)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;function proxy:Stop(fadeTime)
&#9;&#9;&#9;&#9;&#9;track:Stop(fadeTime or defaultFade or 0.1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;proxy.KeyframeReached = track.KeyframeReached
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;anims[anim.Name] = proxy
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for _, anim in pairs(self.Model:GetChildren()) do
&#9;&#9;&#9;HandleChild(anim)
&#9;&#9;end
&#9;&#9;self.Model.ChildAdded:connect(HandleChild)
&#9;&#9;--
&#9;&#9;local animator = setmetatable({}, {__index=anims})
&#9;&#9;function animator:StopAll(fadeTime)
&#9;&#9;&#9;for _, anim in pairs(anims) do
&#9;&#9;&#9;&#9;anim:Stop(fadeTime)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return animator
&#9;end

&#9;function def.private:ToAssetId(id)
&#9;&#9;local res;
&#9;&#9;if type(id) == &apos;string&apos; then
&#9;&#9;&#9;res = id
&#9;&#9;elseif type(id) == &apos;number&apos; then
&#9;&#9;&#9;res = &apos;http://www.roblox.com/asset/?id=&apos;..id
&#9;&#9;end
&#9;&#9;game:GetService(&apos;ContentProvider&apos;):Preload(res)
&#9;&#9;return res
&#9;end
end)


function CreateMutexFunction(task)
&#9;local running = false
&#9;return function(...)
&#9;&#9;if not running then
&#9;&#9;&#9;return task(...)
&#9;&#9;end
&#9;end
end


function CreateGlobalVarList()
&#9;local this = {}
&#9;local waitingOn = {}
&#9;--
&#9;local data = script.Parent:FindFirstChild(&apos;data&apos;)
&#9;if not data then
&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;data = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;Name = &apos;data&apos;;
&#9;&#9;&#9;&#9;Parent = script.Parent;
&#9;&#9;&#9;}&#9;
&#9;&#9;else
&#9;&#9;&#9;repeat wait() until script.Parent:FindFirstChild(&apos;data&apos;)
&#9;&#9;&#9;data = script.Parent:FindFirstChild(&apos;data&apos;)&#9;&#9;&#9;
&#9;&#9;end
&#9;end
&#9;--
&#9;function this:Create(tag, type, default)
&#9;&#9;if not data:FindFirstChild(tag) then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;Create(type..&apos;Value&apos;){
&#9;&#9;&#9;&#9;&#9;Name = tag;
&#9;&#9;&#9;&#9;&#9;Parent = data;
&#9;&#9;&#9;&#9;&#9;Value = default;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;waitingOn[tag] = true
&#9;&#9;&#9;&#9;repeat wait() until data:FindFirstChild(tag)
&#9;&#9;&#9;&#9;waitingOn[tag] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;setmetatable(this, {
&#9;&#9;__index = function(tb, inx)
&#9;&#9;&#9;if inx == &apos;Create&apos; then
&#9;&#9;&#9;&#9;return this.Create
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local val = data:FindFirstChild(inx)
&#9;&#9;&#9;&#9;if val then
&#9;&#9;&#9;&#9;&#9;return val.Value
&#9;&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;&#9;return data[inx].Value
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t set global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end;
&#9;&#9;__newindex = function(tb, inx, val)
&#9;&#9;&#9;local obj = data:FindFirstChild(inx)
&#9;&#9;&#9;if obj then
&#9;&#9;&#9;&#9;obj.Value = val
&#9;&#9;&#9;elseif waitingOn[inx] then
&#9;&#9;&#9;&#9;repeat wait() until not waitingOn[inx]
&#9;&#9;&#9;&#9;data:FindFirstChild(inx).Value = val
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&apos;Can\&apos;t get global `&apos;..inx..&apos;`, does not exist.&apos;)
&#9;&#9;&#9;end
&#9;&#9;end;
&#9;})
&#9;return this
end


class&apos;Tool&apos;(function(def)
&#9;function def:Create()
&#9;&#9;self.Tool = script.Parent
&#9;&#9;local tool = script.Parent
&#9;&#9;self.Handle = tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;if not self.Handle then
&#9;&#9;&#9;if script:IsA(&apos;LocalScript&apos;) then
&#9;&#9;&#9;&#9;repeat wait() until tool:FindFirstChild(&apos;Handle&apos;)
&#9;&#9;&#9;&#9;self.Handle = tool.Handle
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Tool has no `Handle`, did you forget to add one?&quot;)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;--see which side we&apos;re on, localscript or normal script:
&#9;&#9;local IsLocal = script:IsA(&apos;LocalScript&apos;)

&#9;&#9;--set up the damage bin in the tool, so that damage can be inflicted
&#9;&#9;--from a localscript. The global script side has to create a &quot;damagebin&quot;
&#9;&#9;--in the tool, and the local side of the tool then puts notifications
&#9;&#9;--into that madel.
&#9;&#9;if IsLocal then
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;while not tool:FindFirstChild(&apos;damagebin&apos;) do
&#9;&#9;&#9;&#9;&#9;tool.ChildAdded:wait()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;end)
&#9;&#9;else
&#9;&#9;&#9;self.DamageBin = tool:FindFirstChild(&apos;damagebin&apos;)
&#9;&#9;&#9;if not self.DamageBin then
&#9;&#9;&#9;&#9;self.DamageBin = Create&apos;Model&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;damagebin&apos;;
&#9;&#9;&#9;&#9;&#9;Parent = tool;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;end
&#9;&#9;&#9;--and listen on the damage bin
&#9;&#9;&#9;self.DamageBin.ChildAdded:connect(function(ch)
&#9;&#9;&#9;&#9;local dmg = tonumber(ch.Name)
&#9;&#9;&#9;&#9;--tag the humanoid
&#9;&#9;&#9;&#9;local creator = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &apos;creator&apos;;
&#9;&#9;&#9;&#9;&#9;Value = self.Player;
&#9;&#9;&#9;&#9;&#9;Parent = ch.Value;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;ch.Value:TakeDamage(dmg)
&#9;&#9;&#9;&#9;game.Debris:AddItem(ch, 2)
&#9;&#9;&#9;&#9;game.Debris:AddItem(creator, 2)
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;--create the asset manager
&#9;&#9;self.Asset = CreateAssetProvider()

&#9;&#9;--create the global var list
&#9;&#9;self.Var = CreateGlobalVarList()

&#9;&#9;--
&#9;&#9;tool.Equipped:connect(function(mouse)
&#9;&#9;&#9;--main properties set on selection
&#9;&#9;&#9;self.Mouse = mouse
&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;self.Selected = true
&#9;&#9;&#9;
&#9;&#9;&#9;--set up convinience properties
&#9;&#9;&#9;self.Character = tool.Parent
&#9;&#9;&#9;self.Player = game.Players:GetPlayerFromCharacter(self.Character)
&#9;&#9;&#9;self.Head = self.Character:FindFirstChild(&apos;Head&apos;)
&#9;&#9;&#9;self.Torso = self.Character:FindFirstChild(&apos;Torso&apos;)
&#9;&#9;&#9;self.Humanoid = self.Character:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;self.LeftLeg = self.Character:FindFirstChild(&apos;Left Leg&apos;)
&#9;&#9;&#9;self.RightLeg = self.Character:FindFirstChild(&apos;Right Leg&apos;)
&#9;&#9;&#9;self.LeftArm = self.Character:FindFirstChild(&apos;Left Arm&apos;)
&#9;&#9;&#9;self.RightArm = self.Character:FindFirstChild(&apos;Right Arm&apos;)

&#9;&#9;&#9;--create main the animator for this instance. It won&apos;t be usefull from the
&#9;&#9;&#9;--global side right now, but it may be in the future, and it is an abstraction
&#9;&#9;&#9;--so it is possible to make it work even from the global side.
&#9;&#9;&#9;self.Animator = self.Asset:CreateAnimator(self.Humanoid)
&#9;&#9;&#9;
&#9;&#9;&#9;--if local, set up the mouse events
&#9;&#9;&#9;if IsLocal then
&#9;&#9;&#9;&#9;mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;&#9;self.MouseDown = true
&#9;&#9;&#9;&#9;&#9;self.Button1Down:fire()
&#9;&#9;&#9;&#9;end)&#9;
&#9;&#9;&#9;&#9;mouse.Button1Up:connect(function()
&#9;&#9;&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;&#9;&#9;self.Button1Up:fire()
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;&#9;&#9;self.KeyDown:fire(key)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;mouse.KeyUp:connect(function(key)
&#9;&#9;&#9;&#9;&#9;self.KeyUp:fire(key)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--finally, pass off to the user
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;self.Equipped:fire()
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;tool.Unequipped:connect(function()
&#9;&#9;&#9;-- FIRST give the tool a chance to do stuff with these properties
&#9;&#9;&#9;-- before we kill them. That is, the unequipped event fires before
&#9;&#9;&#9;-- the thing is really unequipped.
&#9;&#9;&#9;self.Unequipped:fireSync()

&#9;&#9;&#9;--unset convinience properties
&#9;&#9;&#9;self.Selected = false
&#9;&#9;&#9;self.MouseDown = false
&#9;&#9;&#9;self.Mouse = nil
&#9;&#9;&#9;self.Character = nil
&#9;&#9;&#9;--
&#9;&#9;&#9;self.Head = nil
&#9;&#9;&#9;self.Torso = nil
&#9;&#9;&#9;self.Humanoid = nil
&#9;&#9;&#9;self.LeftArm = nil
&#9;&#9;&#9;self.RightArm = nil
&#9;&#9;&#9;self.LeftLeg = nil
&#9;&#9;&#9;self.RightLeg = nil
&#9;&#9;&#9;
&#9;&#9;&#9;--kill the old animator. We may be able to reuse it some of the time
&#9;&#9;&#9;--but the most common use cases are ones where it&apos;s not possible to save, so
&#9;&#9;&#9;--it&apos;s not worth the extra code comlexity to figure out when we can save it.
&#9;&#9;&#9;self.Animator = nil
&#9;&#9;end)
&#9;end

&#9;function def:DamageHumanoid(humanoid, damage)
&#9;&#9;if self.DamageBin then
&#9;&#9;&#9;(Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;}).Parent = self.DamageBin
&#9;&#9;else
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;repeat wait() until self.DamageBin
&#9;&#9;&#9;&#9;Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tostring(damage);
&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;}.Parent = self.DamageBin
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;--============================
&#9;def.get.Tool()
&#9;def.get.Player()
&#9;def.get.Mouse()
&#9;def.get.MouseDown()
&#9;def.get.Selected()
&#9;function def.get:MouseTarget()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Target
&#9;&#9;end
&#9;end
&#9;function def.get:MouseHit()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Hit
&#9;&#9;end
&#9;end
&#9;function def.get:MouseIcon()
&#9;&#9;if self.Mouse then
&#9;&#9;&#9;return self.Mouse.Icon
&#9;&#9;end
&#9;end
&#9;function def.set:MouseIcon(icon)
&#9;&#9;if not self.Mouse then
&#9;&#9;&#9;error(&quot;Error, Can&apos;t set MouseIcon from a global script!&quot;)
&#9;&#9;end
&#9;&#9;self.Mouse.Icon = icon
&#9;end
&#9;--
&#9;def.get.Character()
&#9;def.get.Humanoid()
&#9;def.get.LeftArm()
&#9;def.get.RightArm()
&#9;def.get.LeftLeg()
&#9;def.get.RightLeg()
&#9;def.get.Head()
&#9;def.get.Torso()
&#9;def.get.Handle()
&#9;--
&#9;def.get.Asset()
&#9;def.get.Animator()
&#9;def.get.Var()

&#9;--=============================
&#9;def.event.Equipped()
&#9;def.event.Unequipped()
&#9;--
&#9;def.event.Button1Down()
&#9;def.event.Button1Up()
&#9;def.event.KeyDown()
&#9;def.event.KeyUp()
end)

local Tool = CreateTool()

-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-----------------------------------------------------------------------


--====================================================================================--
--                                 asset setup code
--====================================================================================--

--meshes
Tool.Asset:RegisterMesh(&apos;swordmesh&apos;,    127402519)
Tool.Asset:RegisterMesh(&apos;shieldmesh&apos;,   127402561)


--animations
Tool.Asset:RegisterAnim(&apos;firstequip&apos;,   79155144, 6, 0)
Tool.Asset:RegisterAnim(&apos;slash&apos;,        79155154, 3, 0)
--
Tool.Asset:RegisterAnim(&apos;entershield&apos;,  79155126, 6, 0)
Tool.Asset:RegisterAnim(&apos;walkshield&apos;,   79155174, 4, 0)
Tool.Asset:RegisterAnim(&apos;exitshield&apos;,   79155149, 6, 0)
--
Tool.Asset:RegisterAnim(&apos;begincharge&apos;,  79155105, 4, 0)
Tool.Asset:RegisterAnim(&apos;charge&apos;,       79155114, 4, 0)
Tool.Asset:RegisterAnim(&apos;endcharge&apos;,    79155124, 6, 0)
--
Tool.Asset:RegisterAnim(&apos;stash&apos;,        79155162, 6, 0)
Tool.Asset:RegisterAnim(&apos;equip2&apos;,       79155042, 6, 0)
Tool.Asset:RegisterAnim(&apos;hold2&apos;,        79155055, 1, 0)
Tool.Asset:RegisterAnim(&apos;slash2&apos;,       79155062, 2, 0)
Tool.Asset:RegisterAnim(&apos;taunt2&apos;,       79155095, 2, 0)
Tool.Asset:RegisterAnim(&apos;stash2&apos;,       79155073, 6, 0)
Tool.Asset:RegisterAnim(&apos;equip1&apos;,       79155032, 6, 0)


--sounds
Tool.Asset:RegisterSound(&apos;slashsharp&apos;,  45885030)
Tool.Asset:RegisterSound(&apos;swoosh2&apos;,     &apos;SOUND_doubleswoosh&apos;)
Tool.Asset:RegisterSound(&apos;swoosh&apos;,      &apos;SOUND_swoosh&apos;)
Tool.Asset:RegisterSound(&apos;equipsound&apos;,  &apos;SOUND_equip&apos;)
Tool.Asset:RegisterSound(&apos;shieldstow&apos;,  &apos;SOUND_shieldstow&apos;)

Tool.Asset:RegisterSound(&apos;chargesound&apos;, 116048294)
Tool.Asset:RegisterSound(&apos;deepswish&apos;,   120766256, 0.8, 0.5)
Tool.Asset:RegisterSound(&apos;charged&apos;,     127416781)
Tool.Asset:RegisterSound(&apos;swing&apos;,       120766256, 0.5, 1.0)


--global variables
Tool.Var:Create(&apos;shield&apos;,     &apos;Int&apos;,  350)
Tool.Var:Create(&apos;shieldmode&apos;, &apos;Bool&apos;, false)
Tool.Var:Create(&apos;special&apos;,    &apos;Bool&apos;, false)




--====================================================================================--
--                                 weapon holding code
--====================================================================================--

--create a handle for the shield
local Shield = Create&apos;Part&apos;{
&#9;Name = &apos;Shield&apos;;
&#9;FormFactor = &apos;Custom&apos;;
&#9;Size = Vector3.new(2.5, 3.0, 0.6);
&#9;CanCollide = false;
&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;MeshId = &apos;http://www.roblox.com/asset/?id=127402561&apos;;
&#9;&#9;TextureId = &apos;http://www.roblox.com/asset/?id=127402402&apos;;
&#9;&#9;Scale = Vector3.new(1.5, 1.5, 1.5);
&#9;&#9;Name = &apos;Mesh&apos;;
&#9;}
}
local ShieldAttach = Create&apos;Motor6D&apos;{
&#9;Name = &apos;ShieldAttach&apos;;
&#9;C0 = CFrame.new(-0.3,0,0); 
&#9;C1 = CFrame.Angles(0, 0, 0);
}

--set the shield to be attached to the back for 1-handed mode
function AttachShieldToBack()
&#9;ShieldAttach.Parent = Tool.Torso
&#9;ShieldAttach.Part1 = Shield
&#9;ShieldAttach.Part0 = Tool.Torso
&#9;Shield.Parent = Tool.Character
end

--set the shield to be attached to the arm for 1handed mode
function AttachShieldToArm()
&#9;ShieldAttach.Parent = Tool.LeftArm
&#9;ShieldAttach.Part1 = Shield
&#9;ShieldAttach.Part0 = Tool.LeftArm
&#9;Shield.Parent = Tool.Character
end



--====================================================================================--
--                                 GUI setup code
--====================================================================================--

local ShieldScreenGui = Create&apos;ScreenGui&apos;{
&#9;Name = &apos;AngelSword_Gui&apos;;
}

local BarGui = Create&apos;Frame&apos;{
&#9;Style = &apos;RobloxRound&apos;;
&#9;Position = UDim2.new(0.5, -128, 1, -210);
&#9;Size = UDim2.new(0, 256, 0, 40);
&#9;Name = &apos;BarGui&apos;;
&#9;--
&#9;Parent = ShieldScreenGui;
&#9;--
&#9;Create&apos;Frame&apos;{
&#9;&#9;Name = &apos;Bar&apos;;
&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;BackgroundColor3 = Color3.new(0.2, 0.2, 1.0);
&#9;};
&#9;Create&apos;TextLabel&apos;{
&#9;&#9;Name = &apos;Label&apos;;
&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;Text = &apos;Shield Health: 400/400&apos;;
&#9;&#9;Font = &apos;ArialBold&apos;;
&#9;&#9;FontSize = &apos;Size14&apos;;
&#9;&#9;TextColor3 = Color3.new(0.3, 0.3, 0.8);
&#9;&#9;TextStrokeTransparency = 0;
&#9;&#9;TextStrokeColor3 = Color3.new(1,1,1);
&#9;};
}

local ReadyMessage = &quot;Hold Q to protect yourself from damage.\n&quot;..
                     &quot;Doubleclick and hold to charge special!&quot;
local ShieldMessage = &quot;(Protecting From Damage)&quot;
local ChargingMessage = &quot;Imma chargin mah special attack!&quot;
local SpecialMessage = &quot;Hold the mouse button down to unleash the fury!!!\n&quot;..
                       &quot;Press Q while looking at someone to taunt&quot;

local MessageGui = Create&apos;Frame&apos;{
&#9;Style = &apos;RobloxRound&apos;;
&#9;Position = UDim2.new(0.5, -128, 1, -160);
&#9;Size = UDim2.new(0, 256, 0, 60);
&#9;Name = &apos;UsageMessage&apos;;
&#9;--
&#9;Parent = ShieldScreenGui;
&#9;--
&#9;Create&apos;TextLabel&apos;{
&#9;&#9;Name = &apos;Label&apos;;
&#9;&#9;Size = UDim2.new(1, 0, 1, 0);
&#9;&#9;BackgroundTransparency = 1.0;
&#9;&#9;Text = &apos;Hold Q to protect\nyourself from damage\n&apos;;
&#9;&#9;Font = &apos;Arial&apos;;
&#9;&#9;FontSize = &apos;Size14&apos;;
&#9;&#9;TextWrapped = true;
&#9;&#9;TextColor3 = Color3.new(1, 1, 1);
&#9;&#9;--TextStrokeTransparency = 0;
&#9;&#9;--TextStrokeColor3 = Color3.new(1,1,1);
&#9;};
}



--====================================================================================--
--                          settings for main functionality
--====================================================================================--
local GearMode = &apos;Ready&apos; -- Ready | Shield | Charging | Special
local TimerStart = 0     --when charging or special started
local ShieldMax = 350    --how wuch shields
--
local ChargeTime = 6     --how long to charge
local SpecialTime = 20   --how long for the special
--
local UsingSword = false --anything that would block a state change from being done at
                         --a given time sets this to true: A 1hand slash, 2hand slash
                         --or a 2hand taunt
local IsWalking = false

local CurrentDamage = 0

--====================================================================================--
--                         main functionality implementation
--====================================================================================--

function HSVtoRGB(h, s, v)
&#9;local hi = math.floor(h / 60) % 6
&#9;local f = (h/60) - math.floor(h/60)
&#9;local p = v*(1-s)
&#9;local q = v*(1-f*s)
&#9;local t = v*(1-(1-f)*s)
&#9;if hi == 0 then
&#9;&#9;return v, t, p
&#9;elseif hi == 1 then
&#9;&#9;return q, v, p
&#9;elseif hi == 2 then
&#9;&#9;return p, v, t
&#9;elseif hi == 3 then
&#9;&#9;return p, q, v
&#9;elseif hi == 4 then
&#9;&#9;return t, p, v
&#9;elseif hi == 5 then
&#9;&#9;return v, p, q
&#9;end
end

--A generic update function which is called every frame. Performs both physical and 
--GUI changes
function Update()
&#9;if GearMode == &apos;Shield&apos; then
&#9;&#9;--we have to update the shield UI for changes in the shield global
&#9;&#9;--we could do this with an event, but the complexity isn&apos;t worth it.
&#9;&#9;BarGui.Bar.Size = UDim2.new(Tool.Var.shield / ShieldMax, 0, 1, 0)
&#9;&#9;BarGui.Label.Text = &quot;Shield Health: &quot;..Tool.Var.shield..&quot; / &quot;..ShieldMax

&#9;elseif GearMode == &apos;Ready&apos; then
&#9;&#9;--in geady mode we don&apos;t have anything to do at all every frame

&#9;elseif GearMode == &apos;Charging&apos; then
&#9;&#9;--in charging we need to update the amount of charge
&#9;&#9;BarGui.Bar.Size = UDim2.new((tick()-TimerStart)/ChargeTime, 0, 1, 0)
&#9;&#9;BarGui.Label.Text = &quot;Charging Special: &quot;..math.floor((tick()-TimerStart)/ChargeTime*100)..&quot;%&quot;

&#9;elseif GearMode == &apos;Special&apos; then
&#9;&#9;--lots of stuff. We need to update the charge left in our special,
&#9;&#9;--make the sword to pretty flashing things, and make the charge bar
&#9;&#9;--do pretty flashing things too.

&#9;&#9;--set the bar position
&#9;&#9;local fracLeft = 1-(tick()-TimerStart)/SpecialTime
&#9;&#9;if fracLeft &lt; 0 then fracLeft = 0 end
&#9;&#9;BarGui.Bar.Size = UDim2.new(fracLeft, 0, 1, 0)
&#9;&#9;local timeLeft = SpecialTime-(tick()-TimerStart)
&#9;&#9;if timeLeft &lt; 0 then timeLeft = 0 end
&#9;&#9;BarGui.Label.Text = &quot;Special Left: &quot;..math.floor(timeLeft)..&quot;s&quot;

&#9;&#9;--calculate some pretty color based on time
&#9;&#9;local t = tick()
&#9;&#9;local h = (math.sin(t*10)+t*15)*10
&#9;&#9;local s = 1
&#9;&#9;local v = 1-math.sin(t*t - 5*h - t*t*t)^3
&#9;&#9;local r, g, b = math.abs(math.sin(5*t)), math.abs(math.cos(7*t)), math.abs(math.cos(4*t))

&#9;&#9;--calculate a scale modifier for the sword
&#9;&#9;local smodlen = math.abs((0.5*(math.sin(3*t)+math.cos(4*t)))/5)
&#9;&#9;local smodw = math.abs(math.sin(t*10))
&#9;&#9;--
&#9;&#9;Tool.Handle.Mesh.Scale = Vector3.new(1.5, 1.5+smodlen, 1.5+smodw)
&#9;&#9;Tool.Handle.Mesh.VertexColor = Vector3.new(r, g, b)
&#9;&#9;Shield.Mesh.VertexColor = Vector3.new(r, g, b)
&#9;&#9;--
&#9;&#9;BarGui.Bar.BackgroundColor3 = Color3.new(r, g, b)
&#9;&#9;BarGui.Label.TextColor3 = Color3.new(r, g, b)
&#9;&#9;BarGui.Label.TextStrokeColor3 = Color3.new(1-r, 1-g, 1-b)
&#9;end
end

--set the bar to show how much shield are left when shields are active
function SetModeShield()
&#9;GearMode = &apos;Shield&apos;
&#9;Tool.Var.shieldmode = true
&#9;--
&#9;BarGui.Bar.BackgroundColor3 = Color3.new(0.2, 0.2, 1.0)
&#9;BarGui.Label.TextColor3 = Color3.new(0.2, 0.2, 1.0)
&#9;BarGui.Label.TextStrokeColor3 = Color3.new(1.0, 1.0, 1.0)
&#9;BarGui.Bar.Size = UDim2.new(Tool.Var.shield / ShieldMax, 0, 1, 0)
&#9;BarGui.Label.Text = &quot;Shield Health: &quot;..Tool.Var.shield..&quot; / &quot;..ShieldMax
&#9;MessageGui.Label.Text = ShieldMessage
&#9;--
&#9;Tool.Humanoid.WalkSpeed = 10
&#9;--
&#9;Spawn(function()
&#9;&#9;UsingSword = true
&#9;&#9;Tool.Animator.entershield:Play()
&#9;&#9;--we have a special walking anim for the shielded player, use it
&#9;&#9;local walkingCn = Tool.Humanoid.Running:connect(function(speed)
&#9;&#9;&#9;if speed &gt; 0 then
&#9;&#9;&#9;&#9;Tool.Animator.walkshield:Play()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Tool.Animator.walkshield:Stop()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;--start them walking te begin with if they already are
&#9;&#9;if IsWalking then
&#9;&#9;&#9;Tool.Animator.walkshield:Play()
&#9;&#9;end
&#9;&#9;--
&#9;&#9;repeat wait() until GearMode ~= &apos;Shield&apos;
&#9;&#9;walkingCn:disconnect()
&#9;&#9;--
&#9;&#9;Tool.Animator.walkshield:Stop()
&#9;&#9;Tool.Animator.entershield:Stop()
&#9;&#9;Tool.Animator.exitshield:Play()
&#9;&#9;UsingSword = false
&#9;&#9;Tool.Var.shieldmode = false
&#9;end)
end

--set the GUI to be doing nothing special
function SetModeReady()
&#9;GearMode = &apos;Ready&apos;
&#9;Tool.Var.shieldmode = false
&#9;--
&#9;BarGui.Bar.BackgroundColor3 = Color3.new(0.2, 0.2, 1.0)
&#9;BarGui.Label.TextColor3 = Color3.new(0.2, 0.2, 1.0)
&#9;BarGui.Label.TextStrokeColor3 = Color3.new(1.0, 1.0, 1.0)
&#9;BarGui.Bar.Size = UDim2.new(Tool.Var.shield / ShieldMax, 0, 1, 0)
&#9;BarGui.Label.Text = &quot;Shield Health: &quot;..Tool.Var.shield..&quot; / &quot;..ShieldMax
&#9;MessageGui.Label.Text = ReadyMessage
&#9;--
&#9;Tool.Humanoid.WalkSpeed = 16
end

--set GUI for charging special
function SetModeCharging()
&#9;GearMode = &apos;Charging&apos;
&#9;Tool.Var.shieldmode = false
&#9;--
&#9;BarGui.Bar.BackgroundColor3 = Color3.new(1.0, 0.2, 0.2)
&#9;BarGui.Label.TextColor3 = Color3.new(1.0, 0.2, 0.2)
&#9;BarGui.Label.TextStrokeColor3 = Color3.new(1.0, 1.0, 1.0)
&#9;BarGui.Bar.Size = UDim2.new(0, 1, 1, 0)
&#9;BarGui.Label.Text = &quot;Charging Special: 0%&quot;
&#9;MessageGui.Label.Text = ChargingMessage
&#9;--
&#9;Tool.Humanoid.WalkSpeed = 0
&#9;--
&#9;local id = ModeId
&#9;local charging = false
&#9;TimerStart = tick()
&#9;Spawn(function()
&#9;&#9;local lastSound = 0
&#9;&#9;while GearMode == &apos;Charging&apos; do
&#9;&#9;&#9;local elapsed = tick()-TimerStart
&#9;&#9;&#9;local frac = elapsed / ChargeTime
&#9;&#9;&#9;--
&#9;&#9;&#9;if charging and id == ModeId then
&#9;&#9;&#9;&#9;Tool.Animator.charge:AdjustSpeed(0.8+frac*1.8)
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;local deltaNow = (1-frac)*0.5 + 0.1
&#9;&#9;&#9;if tick()-lastSound &gt; deltaNow then
&#9;&#9;&#9;&#9;lastSound = tick()
&#9;&#9;&#9;&#9;Tool.Asset:PlaySound(&apos;chargesound&apos;)
&#9;&#9;&#9;end
&#9;&#9;&#9;--&#9;
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;end)
&#9;Spawn(function()
&#9;&#9;--
&#9;&#9;Tool.Animator.begincharge:Play()
&#9;&#9;repeat until    Tool.Animator.begincharge.KeyframeReached:wait() == &apos;complete&apos; 
&#9;&#9;&#9;         or not Tool.MouseDown
&#9;&#9;Tool.Animator.begincharge:Stop()
&#9;&#9;if not Tool.MouseDown then
&#9;&#9;&#9;SetModeReady()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;--
&#9;&#9;Tool.Animator.charge:Play(0.8, 0)
&#9;&#9;Tool.Animator.charge:AdjustSpeed(0.8)
&#9;&#9;charging = true
&#9;&#9;repeat wait() until    not Tool.MouseDown 
&#9;&#9;&#9;                or ((tick()-TimerStart) &gt; ChargeTime)
&#9;&#9;charging = false
&#9;&#9;Tool.Animator.charge:Stop(0) --is looping, we need to stop it no matter how we
&#9;&#9;                             --broke out of the loop.
&#9;&#9;if Tool.MouseDown then --only if the mouse is still down should we go to special mode
&#9;&#9;&#9;SetModeSpecial()
&#9;&#9;else
&#9;&#9;&#9;SetModeReady()
&#9;&#9;end

&#9;&#9;--and we need to end the charge, make sure we occupy the sword durring this time
&#9;&#9;--so that the Ready mode can&apos;t slash yet.
&#9;&#9;--UsingSword = true
&#9;&#9;--Tool.Animator.endcharge:Play()
&#9;&#9;--repeat until Tool.Animator.endcharge.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;--UsingSword = false
&#9;end)
end

--set the GUI for the special enabled mode
function SetModeSpecial()
&#9;GearMode = &apos;Special&apos;
&#9;Tool.Var.shieldmode = false
&#9;--
&#9;Tool.Asset:PlaySound(&apos;charged&apos;)
&#9;--
&#9;--(color3 set in loop, is dynamic)
&#9;BarGui.Bar.Size = UDim2.new(0, 1, 1, 0)
&#9;BarGui.Label.Text = &quot;Charging Special: 0%&quot;
&#9;MessageGui.Label.Text = SpecialMessage
&#9;--
&#9;Tool.Humanoid.WalkSpeed = 22
&#9;--
&#9;TimerStart = tick()
&#9;Spawn(function()
&#9;&#9;Tool.Var.special = true
&#9;&#9;Tool.Animator.stash:Play()
&#9;&#9;repeat until Tool.Animator.stash.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;AttachShieldToBack()
&#9;&#9;Tool.Animator.equip2:Play()
&#9;&#9;repeat until Tool.Animator.equip2.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;Tool.Animator.hold2:Play()
&#9;&#9;--
&#9;&#9;-- now, any time the mouse is held and something is not playing (a-la 
&#9;&#9;-- UsingSword = true), we start a 2hand sword swing.
&#9;&#9;while GearMode == &apos;Special&apos; and (tick()-TimerStart) &lt; SpecialTime do
&#9;&#9;&#9;while 
&#9;&#9;&#9;&#9;GearMode == &apos;Special&apos;             and 
&#9;&#9;&#9;&#9;Tool.MouseDown                    and 
&#9;&#9;&#9;&#9;not UsingSword                    and 
&#9;&#9;&#9;&#9;(tick()-TimerStart) &lt; SpecialTime 
&#9;&#9;&#9;do
&#9;&#9;&#9;&#9;Tool.Asset:PlaySound(&apos;deepswish&apos;)
&#9;&#9;&#9;&#9;CurrentDamage = 35
&#9;&#9;&#9;&#9;UsingSword = true
&#9;&#9;&#9;&#9;Tool.Animator.slash2:Play()
&#9;&#9;&#9;&#9;repeat until Tool.Animator.slash2.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;&#9;&#9;UsingSword = false
&#9;&#9;&#9;&#9;CurrentDamage = 0
&#9;&#9;&#9;end
&#9;&#9;&#9;wait()
&#9;&#9;end

&#9;&#9;-- done this mode now, stop the hold anim and unstash the shield.
&#9;&#9;Tool.Animator.hold2:Stop()
&#9;&#9;--
&#9;&#9;UsingSword = true
&#9;&#9;Tool.Animator.stash2:Play()
&#9;&#9;repeat until Tool.Animator.stash2.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;AttachShieldToArm()
&#9;&#9;Tool.Animator.equip1:Play()
&#9;&#9;repeat until Tool.Animator.equip1.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;UsingSword = false

&#9;&#9;--fix the sword
&#9;&#9;Tool.Handle.Mesh.Scale = Vector3.new(1.5, 1.5, 1.5)
&#9;&#9;Tool.Handle.Mesh.VertexColor = Vector3.new(1, 1, 1)
&#9;&#9;Shield.Mesh.VertexColor = Vector3.new(1, 1, 1)

&#9;&#9;--change the special flag
&#9;&#9;Tool.Var.special = false

&#9;&#9;--change modes
&#9;&#9;SetModeReady()
&#9;end)
end


--====================================================================================--
--                              main event handling code
--====================================================================================-- 

Tool.Handle.Touched:connect(function(part)
&#9;--only damage player parts, not also player weapons + hats
&#9;local hum = (part.Parent or game):FindFirstChild(&apos;Humanoid&apos;)
&#9;if hum and CurrentDamage &gt; 0 then
&#9;&#9;Tool:DamageHumanoid(hum, CurrentDamage)
&#9;end
end)



local LastClick = 0
Tool.Button1Down:connect(function()
&#9;local t = tick()
&#9;if (t-LastClick) &gt; 0.3 then
&#9;&#9;LastClick = t
&#9;&#9;--do a single click
&#9;&#9;if GearMode == &apos;Ready&apos; then
&#9;&#9;&#9;if not UsingSword then
&#9;&#9;&#9;&#9;--we need rather special handling for a normal 1hand slash, since the
&#9;&#9;&#9;&#9;--code which switches to charging mode may start playing if this is
&#9;&#9;&#9;&#9;--really a doubleclick, not a single one. We have to keep checking if
&#9;&#9;&#9;&#9;--we are still in Ready mode to handle this, which is a bit cumbersome
&#9;&#9;&#9;&#9;--but the best solution to the problem as the starting part of the
&#9;&#9;&#9;&#9;--slash anim is a bit slow, and there won&apos;t be any noticable ugliness
&#9;&#9;&#9;&#9;--as a result of stopping it to play the stash anim on a double click.
&#9;&#9;&#9;&#9;UsingSword = true
&#9;&#9;&#9;&#9;Tool.Asset:PlaySound(&apos;swing&apos;)
&#9;&#9;&#9;&#9;Tool.Animator.slash:Play()
&#9;&#9;&#9;&#9;CurrentDamage = 30
&#9;&#9;&#9;&#9;repeat until Tool.Animator.slash.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;&#9;&#9;&#9;         or GearMode ~= &apos;Ready&apos;
&#9;&#9;&#9;&#9;CurrentDamage = 0
&#9;&#9;&#9;&#9;Tool.Animator.slash:Stop() --in case we broke out before it was done
&#9;&#9;&#9;&#9;UsingSword = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif GearMode == &apos;Ready&apos; then
&#9;&#9;--do a doubleclick. We want to enter the charging mode in this case

&#9;&#9;LastClick = 0 --don&apos;t treat triple click as a double click

&#9;&#9;SetModeCharging() --note, this will immediately change the GearMode, so we don&apos;t
&#9;&#9;                  --have to worry about the user doing a slash or something.
&#9;end
end)


function Taunt()
&#9;--gather all of the humanoids in a 30stud radius
&#9;local torsos = {}
&#9;for _, p in pairs(game.Players:GetChildren()) do
&#9;&#9;if p ~= Tool.Player then
&#9;&#9;&#9;if p.Character and p.Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;torsos[#torsos+1] = p.Character.Torso
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--now pull them in towards us
&#9;local mpos = Tool.Torso.Position
&#9;for _, torso in pairs(torsos) do
&#9;&#9;if (mpos-torso.Position).magnitude &lt; 40 then
&#9;&#9;&#9;local dir = (mpos-torso.Position).unit
&#9;&#9;&#9;------------ stolen from dagger of time to make a character &quot;fly&quot; in some direction
&#9;&#9;&#9;&#9;local force = Instance.new(&quot;BodyVelocity&quot;)
&#9;&#9;&#9;&#9;force.velocity = Vector3.new(0,1,0)
&#9;&#9;&#9;&#9;force.Parent = torso
&#9;&#9;&#9;&#9;torso.Velocity = dir*250
&#9;&#9;&#9;&#9;game.Debris:AddItem(force, 0.5)
&#9;&#9;&#9;------------
&#9;&#9;end
&#9;end
end


Tool.KeyDown:connect(function(key)
&#9;if key:lower() == &apos;q&apos; then
&#9;&#9;if GearMode == &apos;Ready&apos; and not UsingSword then
&#9;&#9;&#9;--enter shield mode
&#9;&#9;&#9;SetModeShield()
&#9;&#9;elseif GearMode == &apos;Special&apos; and not UsingSword then
&#9;&#9;&#9;--do a taunt
&#9;&#9;&#9;UsingSword = true
&#9;&#9;&#9;--
&#9;&#9;&#9;Tool.Animator.taunt2:Play()
&#9;&#9;&#9;--todo: tauntey things
&#9;&#9;&#9;Taunt()
&#9;&#9;&#9;repeat until Tool.Animator.taunt2.KeyframeReached:wait() == &apos;complete&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;UsingSword = false
&#9;&#9;end
&#9;end
end)

Tool.KeyUp:connect(function(key)
&#9;if key:lower() == &apos;q&apos; then
&#9;&#9;if GearMode == &apos;Shield&apos; then
&#9;&#9;&#9;--leave shield mode
&#9;&#9;&#9;SetModeReady()
&#9;&#9;end
&#9;end
end)


local WalkingCn = nil
Tool.Equipped:connect(function()
&#9;--play sound
&#9;Tool.Asset:PlaySound(&apos;slashsharp&apos;)&#9;
&#9;
&#9;--put the GUI in the user&apos;s playerGUI
&#9;ShieldScreenGui.Parent = Tool.Player.PlayerGui

&#9;--equip the shield
&#9;AttachShieldToArm()

&#9;--play the initial anim
&#9;Tool.Animator.firstequip:Play()

&#9;--fix stuff that may be stuck from us stopping abruptly before:
&#9;--fix the sword
&#9;Tool.Handle.Mesh.Scale = Vector3.new(1.5, 1.5, 1.5)
&#9;Tool.Handle.Mesh.VertexColor = Vector3.new(1, 1, 1)
&#9;Shield.Mesh.VertexColor = Vector3.new(1, 1, 1)
&#9;--fix other vars
&#9;UsingSword = false
&#9;IsWalking = false
&#9;CurrentDamage = 0

&#9;--set up tracking of when the player is walking
&#9;WalkingCn = Tool.Humanoid.Running:connect(function(speed)
&#9;&#9;if speed &gt; 0 then
&#9;&#9;&#9;IsWalking = true
&#9;&#9;else
&#9;&#9;&#9;IsWalking = false
&#9;&#9;end
&#9;end)

&#9;--go into ready mode
&#9;SetModeReady()

&#9;--start the Updater Daemon
&#9;while Tool.Selected do
&#9;&#9;Update()
&#9;&#9;wait()
&#9;end
end)



Tool.Unequipped:connect(function()
&#9;if WalkingCn then
&#9;&#9;WalkingCn:disconnect()
&#9;&#9;WalkingCn = nil
&#9;end
&#9;Walking = false

&#9;--kill the GUI and extra handle
&#9;ShieldScreenGui.Parent = nil
&#9;Shield.Parent = nil
&#9;ShieldAttach.Parent = nil
&#9;
&#9;if Tool.Humanoid then
&#9;&#9;Tool.Humanoid.WalkSpeed = 16
&#9;end

&#9;--kill all the anims
&#9;Tool.Animator:StopAll()
end)</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX3">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MotorizeRightGrip</string>
					<ProtectedString name="Source">function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

local Tool = script.Parent.Parent

local armChildRemovedConn = nil
local Motor6DGrip = nil
local EquippedNum = 0

Tool.Equipped:connect(function()
&#9;EquippedNum = EquippedNum + 1
&#9;local myEquip = EquippedNum
&#9;--some vars
&#9;local Player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;local Character = Player.Character

&#9;local rightarm = Character:FindFirstChild(&apos;Right Arm&apos;)
&#9;if rightarm and rightarm:FindFirstChild(&apos;RightGrip&apos;) then
&#9;&#9;local rightGrip = rightarm[&apos;RightGrip&apos;]
&#9;&#9;local handle = rightGrip.Part1

&#9;&#9;--kill my joint when the normal joint is removed
&#9;&#9;--this must be done here so that the joint is removed 
&#9;&#9;--_right away_ after unequipping and the character doesn&apos;t 
&#9;&#9;--glitch up.
&#9;&#9;local armChildRemovedConn = rightarm.ChildRemoved:connect(function(ch)
&#9;&#9;&#9;if ch == rightGrip then
&#9;&#9;&#9;&#9;Motor6DGrip:Remove()
&#9;&#9;&#9;&#9;Motor6DGrip = nil
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if handle and Character:FindFirstChild(&apos;Torso&apos;) then
&#9;&#9;&#9;&#9;&#9;if Tool.Parent.Parent:IsA(&apos;Player&apos;) then
&#9;&#9;&#9;&#9;&#9;&#9;--the sword has been deselected
&#9;&#9;&#9;&#9;&#9;&#9;--put the sword far away so the user doesn&apos;t notice that the handle doesn&apos;t
&#9;&#9;&#9;&#9;&#9;&#9;--update for about 0.1 seconds after selecting the tool.
&#9;&#9;&#9;&#9;&#9;&#9;handle.CFrame = CFrame.new(100000, 100000, 100000)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--if in the workspace, position the handle where it should be dropped
&#9;&#9;&#9;&#9;&#9;&#9;--use the size of the handle to make sure it&apos;s dropped far enough away
&#9;&#9;&#9;&#9;&#9;&#9;handle.CFrame = Character.Torso.CFrame * CFrame.new(0, 0, -(handle.Size.magnitude+2))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;&#9;--make my new joint
&#9;&#9;Motor6DGrip = Create&apos;Motor6D&apos;{
&#9;&#9;&#9;Name = &apos;RightGrip_Motor&apos;,
&#9;&#9;&#9;Part0 = rightarm,
&#9;&#9;&#9;C0 = CFrame.new(-0.3, 0, 0); 
&#9;&#9;&#9;C1 = CFrame.Angles(0, -math.pi/2, -math.pi/2);
&#9;&#9;}
&#9;&#9;--kill the old weld
&#9;&#9;rightGrip.Part1 = nil
&#9;&#9;rightGrip.Part0 = nil
&#9;&#9;handle.Size = Vector3.new(0.55, 0.84, 6.26)
&#9;&#9;Motor6DGrip.Part1 = handle
&#9;&#9;Motor6DGrip.Parent = rightGrip.Parent
&#9;&#9;local mesh = handle:WaitForChild(&apos;Mesh&apos;)
&#9;&#9;mesh.Scale = Vector3.new(1.5,1.5,1.5)
&#9;&#9;mesh.TextureId = &apos;http://www.roblox.com/asset/?id=127402402&apos;
&#9;&#9;mesh.MeshId = &apos;http://www.roblox.com/asset/?id=127402519&apos;
&#9;end
end)

Tool.Unequipped:connect(function()
&#9;EquippedNum = EquippedNum + 1
&#9;if armChildRemovedConn then
&#9;&#9;armChildRemovedConn:disconnect()
&#9;&#9;armChildRemovedConn = nil
&#9;end
end)
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX4">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-24.150383</X>
					<Y>101.49881</Y>
					<Z>-35.3680115</Z>
					<R00>0.610154569</R00>
					<R01>-0.00063087407</R01>
					<R02>0.792282045</R02>
					<R10>3.48751266e-022</R10>
					<R11>0.999999642</R11>
					<R12>0.000796274282</R12>
					<R20>-0.792282224</R20>
					<R21>-0.00048585044</R21>
					<R22>0.61015439</R22>
				</CoordinateFrame>
				<bool name="CanCollide">false</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.840000153</X>
					<Y>6.26000309</Y>
					<Z>0.550000548</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX5">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=127412977</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.5</X>
						<Y>1.5</Y>
						<Z>1.5</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=127402402</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Camera" referent="RBX6">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-27.7764511</X>
					<Y>102.956444</Y>
					<Z>-32.8289871</Z>
					<R00>0.573580086</R00>
					<R01>0.256203264</R01>
					<R02>-0.778052568</R02>
					<R10>-0</R10>
					<R11>0.949829817</R11>
					<R12>0.312767386</R12>
					<R20>0.819149554</R20>
					<R21>-0.179397151</R21>
					<R22>0.544803441</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-24.150383</X>
					<Y>101.49881</Y>
					<Z>-35.3680115</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>