<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>-0.45175302</X>
				<Y>0</Y>
				<Z>-2.07265997</Z>
				<R00>0.540302277</R00>
				<R01>0</R01>
				<R02>0.841470957</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>-0.841470957</R20>
				<R21>0</R21>
				<R22>0.540302277</R22>
			</CoordinateFrame>
			<string name="Name">StravantLightning</string>
			<Content name="TextureId"><url>rbxassetid://168892484</url></Content>
			<string name="ToolTip">Stravant&apos;s Lightning</string>
		</Properties>
		<Item class="LocalScript" referent="RBX1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ToolLocal</string>
				<ProtectedString name="Source">local Tool = script.Parent

local BeginTransform = Tool:WaitForChild(&apos;BeginTransform&apos;)
local RunLocal_SSTool = Tool:WaitForChild(&apos;RunLocal_SSTool&apos;)

local Handle = Tool:WaitForChild(&apos;Handle&apos;)
local Mesh = Handle:WaitForChild(&apos;Mesh&apos;)

-- Fix up the grip / mesh from the profile one
Tool.Grip = CFrame.new(-0.4,0,0) * CFrame.Angles(1.5, 1.7, 0.3) * CFrame.Angles(0.2, 0, 0)
Mesh.MeshId = &apos;rbxassetid://168892363&apos;

Tool.Equipped:connect(function(mouse)
&#9;local character = Tool.Parent
&#9;mouse.Button1Down:connect(function()
&#9;&#9;if not character:FindFirstChild(&apos;RunLocal_SSTool&apos;) then
&#9;&#9;&#9;local clone = RunLocal_SSTool:Clone()
&#9;&#9;&#9;clone.Disabled = false
&#9;&#9;&#9;clone.Parent = character
&#9;&#9;&#9;--
&#9;&#9;&#9;BeginTransform:InvokeServer()
&#9;&#9;end
&#9;end)
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX2">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>46.1437454</X>
					<Y>56.5999985</Y>
					<Z>65.7037125</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0.5</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>1.20000005</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX3">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxassetid://168892432 </url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.20000005</X>
						<Y>1.20000005</Y>
						<Z>1.20000005</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxassetid://168892465</url></Content>
					<Vector3 name="VertexColor">
						<X>0</X>
						<Y>0.5</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="RemoteFunction" referent="RBX4">
			<Properties>
				<string name="Name">BeginTransform</string>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX5">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ToolGlobal</string>
				<ProtectedString name="Source">local Players = Game:GetService(&apos;Players&apos;)

local Tool = script.Parent
local Player, Character, Backpack;
local Equipped = false
local Debounce = false

local RunGlobal_SSTool = Tool:WaitForChild(&apos;RunGlobal_SSTool&apos;)
local BeginTransform = Tool:WaitForChild(&apos;BeginTransform&apos;)

local Handle = Tool:WaitForChild(&apos;Handle&apos;)
local Mesh = Handle:WaitForChild(&apos;Mesh&apos;)

-- Fix up the grip / mesh from the profile one
Tool.Grip = CFrame.new(-0.4,0,0) * CFrame.Angles(1.5, 1.7, 0.3) * CFrame.Angles(0.2, 0, 0)
Mesh.MeshId = &apos;rbxassetid://168892363&apos;

BeginTransform.OnServerInvoke = function(player)
&#9;if not Equipped or Debounce then return end&#9;
&#9;
&#9;-- Someone else called the invoke??
&#9;if player ~= Player then return end
&#9;
&#9;Debounce = true
&#9;
&#9;-- Clone the transform begin into the character to run the transformation
&#9;local clone = RunGlobal_SSTool:Clone()
&#9;clone.Disabled = false
&#9;clone.Parent = Character
end

Tool.Equipped:connect(function()
&#9;Character = Tool.Parent
&#9;Player = Players:GetPlayerFromCharacter(Character)
&#9;Equipped = true
end)

Tool.Unequipped:connect(function()
&#9;Equipped = false
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX6">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RunGlobal_SSTool</string>
				<ProtectedString name="Source">local Players = Game:GetService(&apos;Players&apos;)
local RunService = Game:GetService(&apos;RunService&apos;)

local Character = script.Parent
local Player = Players:GetPlayerFromCharacter(Character)

local ShootFrom = script:WaitForChild(&apos;ShootFrom&apos;)
local ShootTo = script:WaitForChild(&apos;ShootTo&apos;)
local IsShooting = script:WaitForChild(&apos;IsShooting&apos;)
local HumanoidToDamage = script:WaitForChild(&apos;HumanoidToDamage&apos;)
local UpdateShoot = script:WaitForChild(&apos;UpdateShoot&apos;)
--
local UpdateMove = script:WaitForChild(&apos;UpdateMove&apos;)
local ControlReady = script:WaitForChild(&apos;ControlReady&apos;)

local PartList = {
&#9;{
&#9;&#9;-- 15 degrees
&#9;&#9;Sweep = 20;
&#9;&#9;Mesh = &apos;rbxassetid://168892318&apos;;
&#9;&#9;CFrame = CFrame.new(-2.028, 0.003, 0.063, 0.482962936, -0.258818984, -0.836516321, 0.129409432, 0.965925813, -0.224143848, 0.866025388, 6.70552254e-008, 0.5);
&#9;},
&#9;{
&#9;&#9;-- 180 degrees
&#9;&#9;Sweep = 180;
&#9;&#9;Mesh = &apos;rbxassetid://168892343&apos;;
&#9;&#9;CFrame = CFrame.new(-0.500, -0.169, -0.275, -0.546336055, 0.136979967, 0.826288223, -0.0343417339, 0.982042372, -0.185506523, -0.836861134, -0.129725233, -0.531821132);
&#9;},
&#9;{
&#9;&#9;-- 30 degrees
&#9;&#9;Sweep = 40;
&#9;&#9;Mesh = &apos;rbxassetid://168892363&apos;;
&#9;&#9;CFrame = CFrame.new(-1.738, -0.056, -0.034, 0.913205206, -0.157400429, -0.375873566, 0.0347544663, 0.949112594, -0.313011229, 0.406014502, 0.272780538, 0.872205615);
&#9;},
&#9;{
&#9;&#9;-- 250 degrees
&#9;&#9;Sweep = 250;
&#9;&#9;Mesh = &apos;rbxassetid://168892387&apos;;
&#9;&#9;CFrame = CFrame.new(0.033, -0.053, -0.015, -0.947963715, 0.129520699, 0.290842265, 0.0606384911, 0.970239401, -0.23443158, -0.312550366, -0.20459649, -0.927605391);
&#9;},
&#9;{
&#9;&#9;-- 200 degrees
&#9;&#9;Sweep = 200;
&#9;&#9;Mesh = &apos;rbxassetid://168892408&apos;;
&#9;&#9;CFrame = CFrame.new(-0.293, -0.027, -0.226, -0.517871141, -0.154164821, -0.841452301, 0.081988588, 0.970154822, -0.228204504, 0.85152036, -0.187170446, -0.489775389);
&#9;},
}

local MainBodyPartList = {&apos;Head&apos;, &apos;Torso&apos;, &apos;Right Arm&apos;, &apos;Left Arm&apos;, &apos;Right Leg&apos;, &apos;Left Leg&apos;}

local BREAKOFF_TIME = 1
local FLOAT_FINISH_TIME = 3
local FLOAT_HEIGHT = 10
--
local RISE_VELOCITY = FLOAT_FINISH_TIME / FLOAT_HEIGHT

local function TransformationSequence(character)
&#9;-- Get the stuff
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;local dir = torso.CFrame.lookVector
&#9;local transformBase = CFrame.new(torso.Position, torso.Position + Vector3.new(dir.X, 0, dir.Z))

&#9;-- Anchor and ready the character
&#9;if Workspace.FilteringEnabled then
&#9;&#9;torso.Anchored = true
&#9;&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;end
&#9;
&#9;-- Remove the tools from the character (Under both filtering and non filtering... might as well)
&#9;for _, ch in pairs(Player:WaitForChild(&apos;Backpack&apos;):GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Tool&apos;) or ch:IsA(&apos;Hopperbin&apos;) then
&#9;&#9;&#9;ch.Parent = nil
&#9;&#9;end
&#9;end
&#9;for _, ch in pairs(character:GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;ch.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;--
&#9;local light = Instance.new(&apos;PointLight&apos;, torso)
&#9;light.Brightness = 2
&#9;light.Range = 6
&#9;light.Color = Color3.new(0/255, 153/255, 255/255)
&#9;
&#9;-- Copy the ViewLocal into the other players
&#9;local addViewCn;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;local viewLocal = script:WaitForChild(&apos;ViewLocal&apos;)
&#9;&#9;for _, player in pairs(Players:GetChildren()) do
&#9;&#9;&#9;if player ~= Player then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;local cl = viewLocal:Clone()
&#9;&#9;&#9;&#9;&#9;cl:WaitForChild(&apos;TargetCharacter&apos;).Value = character
&#9;&#9;&#9;&#9;&#9;cl.Disabled = false
&#9;&#9;&#9;&#9;&#9;while not player.Character do player.Changed:wait() end
&#9;&#9;&#9;&#9;&#9;cl.Parent = player.Character
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;-- .PlayerAdded does not work for other players on the client
&#9;&#9;addViewCn = Players.ChildAdded:connect(function(player)
&#9;&#9;&#9;if not player:IsA(&apos;Player&apos;) then return end
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;local cl = viewLocal:Clone()
&#9;&#9;&#9;&#9;cl:WaitForChild(&apos;TargetCharacter&apos;).Value = character
&#9;&#9;&#9;&#9;cl.Disabled = false
&#9;&#9;&#9;&#9;while not player.Character do player.Changed:wait() end
&#9;&#9;&#9;&#9;cl.Parent = player.Character
&#9;&#9;&#9;end)&#9;&#9;&#9;
&#9;&#9;end)
&#9;end

&#9;-- Go into the transformation sequence
&#9;local transformStart = tick()
&#9;local transformLast = transformStart
&#9;local transformBase = character.Torso.CFrame * CFrame.new(0, -3, 0)
&#9;transformBase = CFrame.new(transformBase.p, transformBase.p + Vector3.new(transformBase.lookVector.X, 0, transformBase.lookVector.z))

&#9;-- Main transformation sequence
&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;-- How much time has elapsed
&#9;&#9;local now = tick()
&#9;&#9;local dt = now - transformLast
&#9;&#9;local elapsed = now - transformStart
&#9;&#9;transformLast = now

&#9;&#9;-- Main timer
&#9;&#9;local frac = math.min(1, elapsed / FLOAT_FINISH_TIME)
&#9;&#9;local breakFrac = math.max(0, math.min(1, (elapsed - BREAKOFF_TIME) / (FLOAT_FINISH_TIME - BREAKOFF_TIME)))
&#9;&#9;local moveFrac = frac^1.2
&#9;&#9;
&#9;&#9;-- Float up the torso
&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;torso.Anchored = false
&#9;&#9;&#9;torso.CFrame = transformBase * CFrame.new(0, 3 + moveFrac * FLOAT_HEIGHT, 0)
&#9;&#9;&#9;torso.Anchored = true
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Exit
&#9;&#9;if elapsed &gt; FLOAT_FINISH_TIME then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;
&#9;&#9;wait()
&#9;end
&#9;
&#9;return addViewCn
end

addViewCn = TransformationSequence(Character)

local lastDamagedHum = nil
local lastDamagedAt = 0
local lastDamagedCreator;
local DamagePerSecond = 70

function RunController(addViewCn, character)&#9;-- Already dead
&#9;if not (character.Parent and character:FindFirstChild(&apos;Humanoid&apos;) and character.Humanoid.Health &gt; 0) then
&#9;&#9;if addViewCn then
&#9;&#9;&#9;addViewCn:disconnect()
&#9;&#9;end
&#9;&#9;return nil
&#9;end&#9;
&#9;--
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;--
&#9;local turn, move;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;turn = Instance.new(&apos;BodyGyro&apos;)
&#9;&#9;turn.maxTorque = Vector3.new(10000, 10000, 10000)
&#9;&#9;turn.cframe = torso.CFrame
&#9;&#9;turn.Name = &apos;Turn&apos;
&#9;&#9;turn.Parent = torso
&#9;&#9;--
&#9;&#9;move = Instance.new(&apos;BodyPosition&apos;)
&#9;&#9;move.maxForce = Vector3.new(10000, 10000, 10000)
&#9;&#9;move.position = torso.Position
&#9;&#9;move.Name = &apos;Move&apos;
&#9;&#9;move.Parent = torso
&#9;&#9;--
&#9;&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;&#9;torso.Anchored = false
&#9;&#9;--
&#9;&#9;Spawn(function()
&#9;&#9;&#9;local lastTime = tick()
&#9;&#9;&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;local newHumanoidToDamage = nil
&#9;&#9;&#9;&#9;&#9;if IsShooting.Value and HumanoidToDamage.Value then
&#9;&#9;&#9;&#9;&#9;&#9;newHumanoidToDamage = HumanoidToDamage.Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;if lastDamagedHum ~= newHumanoidToDamage then
&#9;&#9;&#9;&#9;&#9;&#9;if lastDamagedHum then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (now - lastDamagedAt) &gt; 0.2 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum:TakeDamage((now - lastDamagedAt)*DamagePerSecond)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Game:GetService(&apos;Debris&apos;):AddItem(lastDamagedCreator, 1)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum = newHumanoidToDamage
&#9;&#9;&#9;&#9;&#9;&#9;if lastDamagedHum then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedAt = now
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator = Instance.new(&apos;ObjectValue&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Value = Player
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Name = &apos;creator&apos;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Parent = lastDamagedHum
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if lastDamagedHum and (now - lastDamagedAt) &gt; 0.1 then
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum:TakeDamage((now - lastDamagedAt)*DamagePerSecond)
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedAt = now
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;end
&#9;&#9;&#9;if lastDamagedCreator then
&#9;&#9;&#9;&#9;Game:GetService(&apos;Debris&apos;):AddItem(lastDamagedCreator, 1)
&#9;&#9;&#9;end
&#9;&#9;&#9;if addViewCn then
&#9;&#9;&#9;&#9;addViewCn:disconnect()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;--
&#9;&#9;local this = {}
&#9;&#9;--
&#9;&#9;function this:UpdateMove(distributedGameTime, movementPosition, movementVelocity, movementYVelocity)
&#9;&#9;&#9;if movementVelocity.magnitude &gt; 0.01 then
&#9;&#9;&#9;&#9;turn.cframe = CFrame.new(Vector3.new(), movementVelocity)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;turn.cframe = CFrame.new(Vector3.new(), Vector3.new(torso.CFrame.lookVector.X, 0, torso.CFrame.lookVector.Z))
&#9;&#9;&#9;end
&#9;&#9;&#9;move.position = movementPosition
&#9;&#9;end
&#9;&#9;function this:ShootAt(...)
&#9;&#9;&#9;
&#9;&#9;end
&#9;&#9;--&#9;
&#9;&#9;return this
&#9;else
&#9;&#9;local this = {}
&#9;&#9;-- stubs, intentionally unimplemented, the client will do these under non-filtering
&#9;&#9;function this:UpdateMove() end
&#9;&#9;function this:ShootAt() end
&#9;&#9;return this
&#9;end
end

local Controller = RunController(addViewCn, Character)

if Workspace.FilteringEnabled then
&#9;UpdateShoot.OnServerEvent:connect(function(player, active, from, to, hum)
&#9;&#9;ShootFrom.Value = from
&#9;&#9;ShootTo.Value = to
&#9;&#9;HumanoidToDamage.Value = hum
&#9;&#9;IsShooting.Value = active
&#9;end)
&#9;UpdateMove.OnServerInvoke = function(player, ...)
&#9;&#9;if player == Player then Controller:UpdateMove(...) end
&#9;end
&#9;ControlReady.Value = true
end



















</ProtectedString>
			</Properties>
			<Item class="RemoteFunction" referent="RBX7">
				<Properties>
					<string name="Name">UpdateMove</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX8">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ViewLocal</string>
					<ProtectedString name="Source">Players = Game:GetService(&apos;Players&apos;)
RunService = Game:GetService(&apos;RunService&apos;)

-- Remove us from the hierarchy, so that we stay around even if the player running is respawns
coroutine.yield()
script.Parent = nil

-- Get the charater to use
local TargetCharacter = script:WaitForChild(&apos;TargetCharacter&apos;)
while not TargetCharacter.Value do TargetCharacter.Changed:wait() end
local Character = TargetCharacter.Value
if not Character then return end
local Player = Players:GetPlayerFromCharacter(Character)
if not Player then return end
-- 

local PartList = {
&#9;{
&#9;&#9;-- 15 degrees
&#9;&#9;Sweep = 20;
&#9;&#9;Mesh = &apos;rbxassetid://168892318&apos;;
&#9;&#9;CFrame = CFrame.new(-2.028, 0.003, 0.063, 0.482962936, -0.258818984, -0.836516321, 0.129409432, 0.965925813, -0.224143848, 0.866025388, 6.70552254e-008, 0.5);
&#9;},
&#9;{
&#9;&#9;-- 180 degrees
&#9;&#9;Sweep = 180;
&#9;&#9;Mesh = &apos;rbxassetid://168892343&apos;;
&#9;&#9;CFrame = CFrame.new(-0.500, -0.169, -0.275, -0.546336055, 0.136979967, 0.826288223, -0.0343417339, 0.982042372, -0.185506523, -0.836861134, -0.129725233, -0.531821132);
&#9;},
&#9;{
&#9;&#9;-- 30 degrees
&#9;&#9;Sweep = 40;
&#9;&#9;Mesh = &apos;rbxassetid://168892363&apos;;
&#9;&#9;CFrame = CFrame.new(-1.738, -0.056, -0.034, 0.913205206, -0.157400429, -0.375873566, 0.0347544663, 0.949112594, -0.313011229, 0.406014502, 0.272780538, 0.872205615);
&#9;},
&#9;{
&#9;&#9;-- 250 degrees
&#9;&#9;Sweep = 250;
&#9;&#9;Mesh = &apos;rbxassetid://168892387&apos;;
&#9;&#9;CFrame = CFrame.new(0.033, -0.053, -0.015, -0.947963715, 0.129520699, 0.290842265, 0.0606384911, 0.970239401, -0.23443158, -0.312550366, -0.20459649, -0.927605391);
&#9;},
&#9;{
&#9;&#9;-- 200 degrees
&#9;&#9;Sweep = 200;
&#9;&#9;Mesh = &apos;rbxassetid://168892408&apos;;
&#9;&#9;CFrame = CFrame.new(-0.293, -0.027, -0.226, -0.517871141, -0.154164821, -0.841452301, 0.081988588, 0.970154822, -0.228204504, 0.85152036, -0.187170446, -0.489775389);
&#9;},
}

local MainBodyPartList = {
&#9;&apos;Head&apos;, &apos;Torso&apos;, &apos;Right Arm&apos;, &apos;Left Arm&apos;, &apos;Right Leg&apos;, &apos;Left Leg&apos;;
}

local function DuplicateCharacterInto(character, parent)
&#9;local partSet = {}
&#9;--
&#9;for _, ch in pairs(character:GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;ch:Clone().Parent = parent
&#9;&#9;end
&#9;end
&#9;for _, partName in pairs(MainBodyPartList) do
&#9;&#9;local ch = Character:FindFirstChild(partName)
&#9;&#9;if ch and ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;local c = ch:Clone()
&#9;&#9;&#9;c.Parent = parent
&#9;&#9;&#9;c.Anchored = true
&#9;&#9;&#9;c.CanCollide = false
&#9;&#9;&#9;c.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.RightSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.LeftSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.FrontSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BackSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c:BreakJoints()
&#9;&#9;&#9;partSet[c.Name] = c
&#9;&#9;end
&#9;end
&#9;--
&#9;return partSet
end

local function CreateEffectModel(character)
&#9;local model;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, character)
&#9;else
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, Workspace.CurrentCamera)
&#9;end
&#9;model.Name = Player.Name..&quot;_EffectModel&quot;
&#9;return model
end

local function CreatePartPool()
&#9;local this = {}
&#9;
&#9;local mPartPoolPtr = 0
&#9;local mPartPool = {}
&#9;
&#9;function this:Allocate()
&#9;&#9;mPartPoolPtr = mPartPoolPtr + 1
&#9;&#9;local part = mPartPool[mPartPoolPtr]
&#9;&#9;if not part then
&#9;&#9;&#9;part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;local box = Instance.new(&apos;SelectionBox&apos;, part)
&#9;&#9;&#9;box.Adornee = part
&#9;&#9;&#9;box.Transparency = 0.3
&#9;&#9;&#9;box.Color = BrickColor.new(1010)
&#9;&#9;&#9;--
&#9;&#9;&#9;mPartPool[mPartPoolPtr] = part
&#9;&#9;end
&#9;&#9;return part
&#9;end
&#9;
&#9;function this:ResetPointer()
&#9;&#9;mPartPoolPtr = 0
&#9;end
&#9;
&#9;function this:HideRest()
&#9;&#9;for i = mPartPoolPtr+1, #mPartPool do
&#9;&#9;&#9;mPartPool[i].Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:HideAll()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateBlurEffect(parent, partSet)
&#9;local this = {}
&#9;local mTransparency = 0.5
&#9;local mVelocity = Vector3.new(0, 0, 0)
&#9;local mRiseDir = Vector3.new(0, 1, 0)
&#9;--
&#9;local mPartList = {}
&#9;local mTweenSet = {}
&#9;--
&#9;local tm = tick()
&#9;for part, _ in pairs(partSet) do
&#9;&#9;local dat = {}
&#9;&#9;dat.Part = part
&#9;&#9;dat.NextEmit = tm + math.random()*0.5
&#9;&#9;table.insert(mPartList, dat)
&#9;end
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;function this:SetVelocity(velo)
&#9;&#9;mVelocity = velo
&#9;end
&#9;
&#9;local function emit(part)
&#9;&#9;local dir = (CFrame.new(Vector3.new(), mRiseDir) * CFrame.Angles(0, 0, math.pi*2*math.random()) * CFrame.Angles(2*math.random(), 0, 0)).lookVector
&#9;&#9;local dat = {}
&#9;&#9;dat.CFrame = part.CFrame
&#9;&#9;dat.Direction = dir
&#9;&#9;dat.Emitted = tick()
&#9;&#9;dat.Lifetime = 0.4 + math.random()*0.3
&#9;&#9;dat.SpeedFactor = 1 + (math.random()*2-1)*0.5
&#9;&#9;dat.BaseSize = part.Size
&#9;&#9;dat.Velocity = mVelocity
&#9;&#9;local newPart = part:Clone()
&#9;&#9;dat.Part = newPart
&#9;&#9;newPart.Anchored = true
&#9;&#9;newPart.CanCollide = false
&#9;&#9;newPart.FormFactor = &apos;Custom&apos;
&#9;&#9;newPart.Transparency = mTransparency
&#9;&#9;newPart.BrickColor = BrickColor.new(23)
&#9;&#9;newPart.TopSurface = &apos;Smooth&apos;
&#9;&#9;newPart.BottomSurface = &apos;Smooth&apos;
&#9;&#9;newPart.RightSurface = &apos;Smooth&apos;
&#9;&#9;newPart.LeftSurface = &apos;Smooth&apos;
&#9;&#9;newPart:BreakJoints()
&#9;&#9;mTweenSet[dat] = true
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;-- Update rise dir&#9;
&#9;&#9;local desiredRise = (Vector3.new(0, 2, 0) - mVelocity).unit
&#9;&#9;if (desiredRise - mRiseDir).magnitude &lt;= 2*dt then
&#9;&#9;&#9;mRiseDir = desiredRise
&#9;&#9;else
&#9;&#9;&#9;mRiseDir = (mRiseDir + (desiredRise - mRiseDir).unit * (2*dt)).unit
&#9;&#9;end&#9;
&#9;&#9;
&#9;&#9;-- Update part list
&#9;&#9;for _, dat in pairs(mPartList) do
&#9;&#9;&#9;if tick() &gt; dat.NextEmit then
&#9;&#9;&#9;&#9;emit(dat.Part)
&#9;&#9;&#9;&#9;dat.NextEmit = tick() + (0.1 + math.random()*0.2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Update the tween parts
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;local frac = (tick() - dat.Emitted) / dat.Lifetime
&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;mTweenSet[dat] = nil
&#9;&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;dat.Part.Parent = parent
&#9;&#9;&#9;&#9;dat.Part:BreakJoints()
&#9;&#9;&#9;&#9;dat.Part.Size = dat.BaseSize * (1 - 0.3*frac)
&#9;&#9;&#9;&#9;dat.CFrame = dat.CFrame + (frac^1.5*dt*20*dat.SpeedFactor)*dat.Direction + dat.Velocity*dt
&#9;&#9;&#9;&#9;dat.Part.CFrame = dat.CFrame
&#9;&#9;&#9;&#9;dat.Part.Transparency = mTransparency + (1 - mTransparency)*(frac^1.5)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateSpinEffect(parent)
&#9;local this = {}
&#9;
&#9;local mTransparency = 0.5
&#9;local mCFrame = CFrame.new()
&#9;
&#9;local mRingSet = {}
&#9;local mRingCount = 0
&#9;local mNextRingAt = tick() + 0.5
&#9;local mDesiredRingCount = 8
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;
&#9;function this:SetCFrame(cf)
&#9;&#9;mCFrame = CFrame.new(cf.p)
&#9;end
&#9;
&#9;function this:AddRing()
&#9;&#9;local ring = PartList[math.random(1, #PartList)] 
&#9;&#9;mRingCount = mRingCount + 1
&#9;&#9;--
&#9;&#9;local dat = {}
&#9;&#9;dat.Started = tick()
&#9;&#9;dat.Created = dat.Started
&#9;&#9;dat.Mode = &apos;In&apos;
&#9;&#9;dat.PartRotOffset = (ring.CFrame - ring.CFrame.p)
&#9;&#9;dat.PartMoveOffset = ring.CFrame.p
&#9;&#9;--
&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;part.Anchored = true
&#9;&#9;part.CanCollide = false
&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;mesh.TextureId = &apos;rbxassetid://168892465&apos;
&#9;&#9;mesh.MeshId = ring.Mesh
&#9;&#9;mesh.VertexColor = Vector3.new(0, 0.5, 1)
&#9;&#9;--
&#9;&#9;dat.Part = part
&#9;&#9;dat.Mesh = mesh
&#9;&#9;dat.VerticalOffset = 4*(math.random()*2-1)
&#9;&#9;dat.Radius = 2 + 5*math.sqrt(1 - math.abs(dat.VerticalOffset/4))
&#9;&#9;dat.Theta = (math.random()*math.pi*2)
&#9;&#9;dat.TurnDirection = (math.random(0,1)*2-1)
&#9;&#9;dat.TurnSpeed = 3 + (math.random()*2-1)*2
&#9;&#9;mRingSet[dat] = true
&#9;end
&#9;
&#9;function this:ShedRing()
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;ring.Mode = &apos;Out&apos;
&#9;&#9;&#9;&#9;ring.Started = tick()
&#9;&#9;&#9;&#9;mRingCount = mRingCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;local now = tick()
&#9;&#9;
&#9;&#9;if now &gt; mNextRingAt then&#9;&#9;&#9;
&#9;&#9;&#9;if mRingCount &gt; mDesiredRingCount then
&#9;&#9;&#9;&#9;this:ShedRing()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;this:AddRing()
&#9;&#9;&#9;end
&#9;&#9;&#9;mNextRingAt = now + (0.1 + math.random()*(0.3 * (mRingCount / mDesiredRingCount)))
&#9;&#9;end
&#9;&#9;
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;local frac = (now - ring.Started) / 2
&#9;&#9;&#9;local radius = nil
&#9;&#9;&#9;local trans = nil
&#9;&#9;&#9;if ring.Mode == &apos;In&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;ring.Mode = &apos;Norm&apos;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local turnFactor = 0.2 + 0.8*(0.5+0.5*math.cos(frac*math.pi))^2
&#9;&#9;&#9;&#9;&#9;local turnSpeed = ring.TurnSpeed + turnFactor*10
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*turnSpeed)
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + turnFactor*5
&#9;&#9;&#9;&#9;&#9;trans = frac
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif ring.Mode == &apos;Out&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;mRingSet[ring] = nil
&#9;&#9;&#9;&#9;&#9;ring.Part:Destroy()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + 5*(frac^2)
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)
&#9;&#9;&#9;&#9;&#9;trans = frac^2
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;radius = ring.Radius
&#9;&#9;&#9;&#9;trans = 1
&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;if mRingSet[ring] then
&#9;&#9;&#9;&#9;local sz = radius / 4
&#9;&#9;&#9;&#9;ring.Mesh.Scale = Vector3.new(sz, 1, sz)
&#9;&#9;&#9;&#9;ring.Part.Parent = parent
&#9;&#9;&#9;&#9;ring.Part.CFrame = (mCFrame * CFrame.new(0, ring.VerticalOffset, 0) * CFrame.Angles(0, ring.Theta, 0) * CFrame.new(ring.PartMoveOffset*sz)) * ring.PartRotOffset
&#9;&#9;&#9;&#9;ring.Part.Transparency = 1 - (1-mTransparency)*(1-trans)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateLightningEffect(parent)
&#9;local this = {}
&#9;
&#9;local mPartPool = CreatePartPool()
&#9;local mActive = false
&#9;local mActivatedAt = 0
&#9;local mFrom = Vector3.new()
&#9;local mTo = Vector3.new()
&#9;local mLightningPath = {{P = mFrom; T = tick(); Expiry = 0}}
&#9;local mLightningPart = Instance.new(&apos;Part&apos;)
&#9;mLightningPart.Anchored = true
&#9;mLightningPart.CanCollide = false
&#9;mLightningPart.FormFactor = &apos;Custom&apos;
&#9;mLightningPart.Size = Vector3.new()
&#9;mLightningPart.Transparency = 1
&#9;local fire = Instance.new(&apos;Fire&apos;, mLightningPart)
&#9;fire.Heat = 20
&#9;fire.Color = Color3.new(10/255, 149/255, 255/255)
&#9;fire.SecondaryColor = Color3.new(0, 0, 0)
&#9;fire.Size = 5
&#9;fire:Clone().Parent = mLightningPart
&#9;local light = Instance.new(&apos;PointLight&apos;, mLightningPart)
&#9;light.Brightness = 2
&#9;light.Range = 4
&#9;light.Color = Color3.new(0/255, 153/255, 255/255)
&#9;
&#9;function this:GetLightningPart()
&#9;&#9;return mLightningPart
&#9;end
&#9;
&#9;local function tickPath(dt)
&#9;&#9;local cachedPoints = {}
&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;local i = 1
&#9;&#9;local now = tick()&#9;
&#9;&#9;while true do&#9;
&#9;&#9;&#9;-- Fudge the current point&#9;&#9;
&#9;&#9;&#9;local currentPoint = mLightningPath[i]
&#9;&#9;&#9;currentPoint.P = currentPoint.P + Vector3.new(math.random()*2-1, math.random()*2-1, math.random()*2-1)*(5*dt)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;-- Are we at the goal?&#9;
&#9;&#9;&#9;-- If we are then clear out the other points
&#9;&#9;&#9;if (currentPoint.P - mTo).magnitude &lt; 0.5 then
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Not at the goal, do we have a next point?
&#9;&#9;&#9;local useNext;
&#9;&#9;&#9;local nextPoint = mLightningPath[i+1]
&#9;&#9;&#9;if nextPoint then
&#9;&#9;&#9;&#9;local toNext = nextPoint.P - currentPoint.P
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Is the next point near the goal?&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.6 then
&#9;&#9;&#9;&#9;&#9;-- Just snap it to the goal
&#9;&#9;&#9;&#9;&#9;nextPoint.P = mTo
&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- 
&#9;&#9;&#9;&#9;&#9;if math.acos(toNext.unit:Dot(toGoal.unit)) &gt; math.pi/2 then
&#9;&#9;&#9;&#9;&#9;&#9;-- The next point is too far out of direction
&#9;&#9;&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;if useNext and (now - currentPoint.T) &gt; currentPoint.Expiry then
&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P - mFrom).magnitude / (mFrom - mTo).magnitude&#9;
&#9;&#9;&#9;&#9;currentPoint.Expiry = math.random()*0.1 + 0.6*fracThere
&#9;&#9;&#9;&#9;currentPoint.T = now
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- If we can&apos;t use the next then we need to do some work
&#9;&#9;&#9;if not useNext then
&#9;&#9;&#9;&#9;-- Move all the points ahead to the cached list
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;table.insert(cachedPoints, mLightningPath[j])
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Create the next point
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.5 then
&#9;&#9;&#9;&#9;&#9;-- If we&apos;re close enough to the goal, just snap there
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {P = mTo; T = now; Expiry = math.random()*0.4})
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- Otherwise, perturb the direction
&#9;&#9;&#9;&#9;&#9;local upwards = math.min(1, (now - mActivatedAt) / 0.8)
&#9;&#9;&#9;&#9;&#9;if upwards == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;mActivatedAt = now
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local dir = CFrame.new(Vector3.new(), toGoal) * CFrame.Angles(0.2 + upwards*0.5, 0, 0) * CFrame.Angles(0, 0, math.random()*math.pi*2) * CFrame.Angles(math.random()*math.pi/3, 0, 0)
&#9;&#9;&#9;&#9;&#9;dir = dir.lookVector * (2 + math.random()*1)
&#9;&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P + dir - mFrom).magnitude / (mFrom - mTo).magnitude
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {
&#9;&#9;&#9;&#9;&#9;&#9;P = currentPoint.P + dir;
&#9;&#9;&#9;&#9;&#9;&#9;T = now;
&#9;&#9;&#9;&#9;&#9;&#9;Expiry = math.random()*0.1 + 0.6*fracThere;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Done
&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;if i &gt; 40 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function drawPath()
&#9;&#9;mPartPool:ResetPointer()
&#9;&#9;for i = 1, #mLightningPath - 1 do
&#9;&#9;&#9;local a = mLightningPath[i].P
&#9;&#9;&#9;local b = mLightningPath[i+1].P
&#9;&#9;&#9;--
&#9;&#9;&#9;local frac = i / (#mLightningPath-1)
&#9;&#9;&#9;local w = 0.2 + 0.2*(1 - 2*math.abs(frac - 0.5))
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = mPartPool:Allocate()
&#9;&#9;&#9;part.Size = Vector3.new(w, w, (a-b).magnitude)
&#9;&#9;&#9;part.CFrame = CFrame.new(0.5*(a+b), b)
&#9;&#9;&#9;part.Parent = parent
&#9;&#9;&#9;part.Transparency = 1
&#9;&#9;end
&#9;&#9;mPartPool:HideRest()
&#9;&#9;mLightningPart.CFrame = CFrame.new(mTo)
&#9;&#9;mLightningPart.Parent = parent
&#9;end
&#9;
&#9;function this:Set(from, to)
&#9;&#9;mFrom = from
&#9;&#9;mTo = to
&#9;end
&#9;
&#9;function this:SetActive(state)
&#9;&#9;if mActive == state then return end
&#9;&#9;mActive = state
&#9;&#9;if mActive then
&#9;&#9;&#9;mActivatedAt = tick()
&#9;&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;&#9;for i = 2, #mLightningPath do
&#9;&#9;&#9;&#9;mLightningPath[i] = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;mPartPool:HideAll()
&#9;&#9;&#9;mLightningPart.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;if mActive then
&#9;&#9;&#9;tickPath(dt)
&#9;&#9;&#9;drawPath()
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;mPartPool:Destroy()
&#9;end
&#9;
&#9;return this
end

local BREAKOFF_TIME = 1
local FLOAT_FINISH_TIME = 3
local FLOAT_HEIGHT = 10
--
local RISE_VELOCITY = FLOAT_FINISH_TIME / FLOAT_HEIGHT

local function TransformationSequence(character)
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;local dir = torso.CFrame.lookVector
&#9;local transformBase = CFrame.new(torso.Position, torso.Position + Vector3.new(dir.X, 0, dir.Z))

&#9;-- Gather the parts to do the tween on
&#9;local partsToTween = {}
&#9;local function gatherParts(object)
&#9;&#9;for _, ch in pairs(object:GetChildren()) do
&#9;&#9;&#9;if ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;local tweenPart = {
&#9;&#9;&#9;&#9;&#9;Part = ch;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;table.insert(partsToTween, tweenPart)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;gatherParts(ch)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;gatherParts(character)
&#9;
&#9;-- The effect model
&#9;local effectModel = CreateEffectModel(character)
&#9;
&#9;-- Duplicate the parts we want normally, but want to make fly away
&#9;local flyAwayParts = DuplicateCharacterInto(character, effectModel)
&#9;
&#9;-- Put the body parts into a set
&#9;local flyAwayPartSet = {}

&#9;-- Decide what to do with each of the parts
&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;if flyAwayParts[dat.Part.Name] then
&#9;&#9;&#9;flyAwayPartSet[dat.Part] = true
&#9;&#9;&#9;dat.Mode = &apos;BreakAway&apos;
&#9;&#9;&#9;dat.BreakAwayPart = flyAwayParts[dat.Part.Name]
&#9;&#9;else
&#9;&#9;&#9;dat.Mode = &apos;Fade&apos;
&#9;&#9;end
&#9;end
&#9;
&#9;--[[
&#9;-- Anchor and ready the character
&#9;torso.Anchored = true
&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;]]
&#9;
&#9;-- Go into the transformation sequence
&#9;local transformStart = tick()
&#9;local transformLast = transformStart
&#9;local transformBase = character.Torso.CFrame * CFrame.new(0, -3, 0)
&#9;transformBase = CFrame.new(transformBase.p, transformBase.p + Vector3.new(transformBase.lookVector.X, 0, transformBase.lookVector.z))
&#9;
&#9;-- Generate some of the effects
&#9;local effectSet = {}

&#9;-- Takeoff ground waves
&#9;do
&#9;&#9;local waves = {}
&#9;&#9;for i = 1, 4 do
&#9;&#9;&#9;local wave = {}
&#9;&#9;&#9;wave.Delay = ((i-1)/4)*0.25 + math.random()*0.3
&#9;&#9;&#9;wave.Size = ((5-i)/4)*15 + math.random()*3
&#9;&#9;&#9;wave.Duration = 0.5 + math.random()*0.2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.CFrame = transformBase * CFrame.new(math.random()*4-2, 0, math.random()*4-2)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Sphere&apos;
&#9;&#9;&#9;wave.Part = part
&#9;&#9;&#9;wave.Mesh = mesh
&#9;&#9;&#9;table.insert(waves, wave)
&#9;&#9;end
&#9;&#9;local function updateWaves(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay + wave.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - wave.Delay) / wave.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local fracIn = 1 - frac^0.25
&#9;&#9;&#9;&#9;&#9;&#9;local fracOut = frac^5
&#9;&#9;&#9;&#9;&#9;&#9;wave.Mesh.Scale = Vector3.new(wave.Size * fracIn, 0.1 + 9*fracOut, wave.Size * fracIn)
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Transparency = 0.3 + 0.7*fracOut
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyWaves()
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateWaves;
&#9;&#9;&#9;Destroy = destroyWaves;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Takeoff vertical risers
&#9;do
&#9;&#9;local risers = {}
&#9;&#9;for i = 1, 6 do
&#9;&#9;&#9;local riser = {}
&#9;&#9;&#9;riser.Delay = 0.3 + math.random() * 0.4
&#9;&#9;&#9;riser.Duration = 1 + math.random() * 1.5
&#9;&#9;&#9;riser.Offset = CFrame.new(math.random()*4 - 2, 0, math.random()*4 - 2)
&#9;&#9;&#9;riser.Width = 0.3 + math.random() * 0.5
&#9;&#9;&#9;riser.Height = 1 + math.random() * 2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Brick&apos;
&#9;&#9;&#9;riser.Part = part
&#9;&#9;&#9;riser.Mesh = mesh
&#9;&#9;&#9;table.insert(risers, riser)
&#9;&#9;end
&#9;&#9;local function updateRisers(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay + riser.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - riser.Delay) / riser.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local rampFrac = 1 - math.abs(frac - 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;local widthFrac = rampFrac^2
&#9;&#9;&#9;&#9;&#9;&#9;local heightFrac = rampFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Mesh.Scale = Vector3.new(riser.Width * widthFrac, riser.Height * heightFrac, riser.Width * widthFrac)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Transparency = 0.2 --widthFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.CFrame = transformBase * riser.Offset * CFrame.new(0, -riser.Height/2 + frac^2*(6 + riser.Height), 0) * CFrame.Angles(0, frac*8, 0)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyRisers()
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateRisers;
&#9;&#9;&#9;Destroy = destroyRisers;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Main effect
&#9;local blurEffect = CreateBlurEffect(effectModel, flyAwayPartSet)
&#9;
&#9;-- The ring effect
&#9;local ringEffect = CreateSpinEffect(effectModel)
&#9;
&#9;-- Main transformation sequence
&#9;while true do
&#9;&#9;-- How much time has elapsed
&#9;&#9;local now = tick()
&#9;&#9;local dt = now - transformLast
&#9;&#9;local elapsed = now - transformStart
&#9;&#9;transformLast = now
&#9;&#9;
&#9;&#9;-- Run any effects
&#9;&#9;for effect, _ in pairs(effectSet) do
&#9;&#9;&#9;if effect.Update(elapsed, dt) then
&#9;&#9;&#9;&#9;effect.Destroy()
&#9;&#9;&#9;&#9;effectSet[effect] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Main timer
&#9;&#9;local frac = math.min(1, elapsed / FLOAT_FINISH_TIME)
&#9;&#9;local breakFrac = math.max(0, math.min(1, (elapsed - BREAKOFF_TIME) / (FLOAT_FINISH_TIME - BREAKOFF_TIME)))
&#9;&#9;local moveFrac = frac^1.2
&#9;&#9;
&#9;&#9;-- Float up the torso (already done by the server or the other client
&#9;&#9;--[[
&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;torso.Anchored = false
&#9;&#9;&#9;torso.CFrame = transformBase * CFrame.new(0, 3 + moveFrac * FLOAT_HEIGHT, 0)&#9;
&#9;&#9;&#9;torso.Anchored = true
&#9;&#9;end
&#9;&#9;--]]
&#9;&#9;
&#9;&#9;-- Tween part positions + transparency
&#9;&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;&#9;if dat.Mode == &apos;Fade&apos; then
&#9;&#9;&#9;&#9;-- Only fade parts on under filtering
&#9;&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = frac
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif dat.Mode == &apos;BreakAway&apos; then
&#9;&#9;&#9;&#9;if dat.Part.Name == &apos;Head&apos; then
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 0.99
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if elapsed &gt; BREAKOFF_TIME then
&#9;&#9;&#9;&#9;&#9;if not dat.Broken then
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;&#9;&#9;for _, ch in pairs(dat.Part:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ch:IsA(&apos;Decal&apos;) then ch:Destroy() end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakVelocity = Vector3.new(math.random()-0.5, 1, math.random()-0.5).unit * 4*(1+math.random())
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakRotVelocity = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5)*5
&#9;&#9;&#9;&#9;&#9;&#9;dat.Broken = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local rvelo = dat.BreakRotVelocity*dt
&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = (dat.BreakCFrame + dat.BreakVelocity*dt) * CFrame.Angles(rvelo.X, rvelo.Y, rvelo.Z)
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.BreakCFrame
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.Transparency = (frac &lt; 0.5) and 0 or ((frac-0.5)/0.5)^2
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;assert(false, &quot;unreachable&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Fade in blur effect
&#9;&#9;blurEffect:SetTransparency(1 - frac*0.7)
&#9;&#9;blurEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Fade in ring effect
&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;ringEffect:SetTransparency(1 - breakFrac*0.7)
&#9;&#9;ringEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Exit
&#9;&#9;if elapsed &gt; FLOAT_FINISH_TIME + 0.5 then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;
&#9;&#9;RunService.RenderStepped:wait()
&#9;end
&#9;
&#9;for _, part in pairs(flyAwayParts) do
&#9;&#9;part:Destroy()
&#9;end
&#9;for _, obj in pairs(effectModel:GetChildren()) do
&#9;&#9;if obj:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;obj:Destroy()
&#9;&#9;end
&#9;end
&#9;blurEffect:SetTransparency(0.3)
&#9;blurEffect:Update(0)
&#9;ringEffect:SetTransparency(0.3)
&#9;ringEffect:Update(0)
&#9;
&#9;return effectModel, blurEffect, ringEffect
end

function RunController(character, effectModel, blurEffect, ringEffect)
&#9;-- Already dead
&#9;if not (character.Parent and character:FindFirstChild(&apos;Humanoid&apos;) and character.Humanoid.Health &gt; 0) then
&#9;&#9;effectModel:Destroy()
&#9;&#9;return nil
&#9;end&#9;
&#9;--
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;--
&#9;local UpdateMove;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;UpdateMove = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;UpdateMove&apos;)
&#9;&#9;local val = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;ControlReady&apos;)
&#9;&#9;while not val.Value do val.Changed:wait() end
&#9;end
&#9;--
&#9;local bin = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;)
&#9;local IsShooting = bin:WaitForChild(&apos;IsShooting&apos;)
&#9;local ShootFrom = bin:WaitForChild(&apos;ShootFrom&apos;)
&#9;local ShootTo = bin:WaitForChild(&apos;ShootTo&apos;)
&#9;local HumanoidToDamage = bin:WaitForChild(&apos;HumanoidToDamage&apos;)
&#9;--
&#9;local lightningEffect = CreateLightningEffect(effectModel)
&#9;lightningEffect:SetActive(true)
&#9;local lightningActive = false
&#9;local lightningActiveSince = 0
&#9;local lightningRunId = 0
&#9;--
&#9;local fireSound = Instance.new(&apos;Sound&apos;, lightningEffect:GetLightningPart())
&#9;fireSound.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound.Pitch = 1.5
&#9;fireSound.Volume = 0.25
&#9;fireSound.Looped = true
&#9;local fireSound2 = Instance.new(&apos;Sound&apos;, lightningEffect:GetLightningPart())
&#9;fireSound2.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound2.Pitch = 1.5
&#9;fireSound2.Volume = 0.25
&#9;fireSound2.Looped = true
&#9;--
&#9;Spawn(function()
&#9;&#9;local lastTime = tick()
&#9;&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;
&#9;&#9;&#9;-- Movement (done by server or owning client)

&#9;&#9;&#9;-- Attack effect
&#9;&#9;&#9;if not IsShooting.Value then
&#9;&#9;&#9;&#9;if lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActive = false
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = 1.5
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;&#9;fireSound2:Stop()
&#9;&#9;&#9;&#9;&#9;fireSound:Stop()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;lightningEffect:SetActive(false)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if not lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActiveSince = now
&#9;&#9;&#9;&#9;&#9;lightningActive = true
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound:Play()
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;&#9;local thisRunId = lightningRunId
&#9;&#9;&#9;&#9;&#9;Delay(0.2, function()
&#9;&#9;&#9;&#9;&#9;&#9;if lightningRunId == thisRunId then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;fireSound2:Play()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local frac = math.min(1, (now - lightningActiveSince) / 0.3)
&#9;&#9;&#9;&#9;&#9;local modPitch = 1.5 - 0.7*(1-frac)
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = modPitch
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = modPitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;lightningEffect:SetActive(true)
&#9;&#9;&#9;&#9;lightningEffect:Set(ShootFrom.Value, ShootTo.Value)
&#9;&#9;&#9;&#9;lightningEffect:Update(dt)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Character effects
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;blurEffect:SetVelocity(torso.Velocity)
&#9;&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;--
&#9;&#9;&#9;while _G.Stop do wait() end
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end

&#9;&#9;-- Turn off the lightning if still running
&#9;&#9;lightningEffect:SetActive(false)
&#9;&#9;fireSound:Stop()&#9;&#9;
&#9;&#9;
&#9;&#9;-- Fade out the other effects
&#9;&#9;local lastTime = tick()
&#9;&#9;local trans = 0.3
&#9;&#9;while character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;trans = math.min(1, trans + 0.5*dt)
&#9;&#9;&#9;blurEffect:SetTransparency(trans)
&#9;&#9;&#9;ringEffect:SetTransparency(trans)
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Finally Kill the effects and end
&#9;&#9;effectModel:Destroy()
&#9;end)
&#9;--
&#9;local this = {}
&#9;--
&#9;function this:ShootAt()
&#9;&#9;
&#9;end
&#9;--&#9;
&#9;return this
end

local effectModel, blurEffect, ringEffect = TransformationSequence(Character)
local Controller = RunController(Character, effectModel, blurEffect, ringEffect)

</ProtectedString>
				</Properties>
				<Item class="ObjectValue" referent="RBX9">
					<Properties>
						<string name="Name">TargetCharacter</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX10">
				<Properties>
					<string name="Name">ControlReady</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="Vector3Value" referent="RBX11">
				<Properties>
					<string name="Name">ShootFrom</string>
					<Vector3 name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Vector3Value" referent="RBX12">
				<Properties>
					<string name="Name">ShootTo</string>
					<Vector3 name="Value">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX13">
				<Properties>
					<string name="Name">IsShooting</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX14">
				<Properties>
					<string name="Name">HumanoidToDamage</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="RemoteEvent" referent="RBX15">
				<Properties>
					<string name="Name">UpdateShoot</string>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX16">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RunLocal_SSTool</string>
				<ProtectedString name="Source">local Players = Game:GetService(&apos;Players&apos;)
local RunService = Game:GetService(&apos;RunService&apos;)

local Character = script.Parent
local Player = Players:GetPlayerFromCharacter(Character)
local Mouse = Player:GetMouse()
local Camera = Workspace.CurrentCamera

local PartList = {
&#9;{
&#9;&#9;-- 15 degrees
&#9;&#9;Sweep = 20;
&#9;&#9;Mesh = &apos;rbxassetid://168892318&apos;;
&#9;&#9;CFrame = CFrame.new(-2.028, 0.003, 0.063, 0.482962936, -0.258818984, -0.836516321, 0.129409432, 0.965925813, -0.224143848, 0.866025388, 6.70552254e-008, 0.5);
&#9;},
&#9;{
&#9;&#9;-- 180 degrees
&#9;&#9;Sweep = 180;
&#9;&#9;Mesh = &apos;rbxassetid://168892343&apos;;
&#9;&#9;CFrame = CFrame.new(-0.500, -0.169, -0.275, -0.546336055, 0.136979967, 0.826288223, -0.0343417339, 0.982042372, -0.185506523, -0.836861134, -0.129725233, -0.531821132);
&#9;},
&#9;{
&#9;&#9;-- 30 degrees
&#9;&#9;Sweep = 40;
&#9;&#9;Mesh = &apos;rbxassetid://168892363&apos;;
&#9;&#9;CFrame = CFrame.new(-1.738, -0.056, -0.034, 0.913205206, -0.157400429, -0.375873566, 0.0347544663, 0.949112594, -0.313011229, 0.406014502, 0.272780538, 0.872205615);
&#9;},
&#9;{
&#9;&#9;-- 250 degrees
&#9;&#9;Sweep = 250;
&#9;&#9;Mesh = &apos;rbxassetid://168892387&apos;;
&#9;&#9;CFrame = CFrame.new(0.033, -0.053, -0.015, -0.947963715, 0.129520699, 0.290842265, 0.0606384911, 0.970239401, -0.23443158, -0.312550366, -0.20459649, -0.927605391);
&#9;},
&#9;{
&#9;&#9;-- 200 degrees
&#9;&#9;Sweep = 200;
&#9;&#9;Mesh = &apos;rbxassetid://168892408&apos;;
&#9;&#9;CFrame = CFrame.new(-0.293, -0.027, -0.226, -0.517871141, -0.154164821, -0.841452301, 0.081988588, 0.970154822, -0.228204504, 0.85152036, -0.187170446, -0.489775389);
&#9;},
}

local MainBodyPartList = {
&#9;&apos;Head&apos;, &apos;Torso&apos;, &apos;Right Arm&apos;, &apos;Left Arm&apos;, &apos;Right Leg&apos;, &apos;Left Leg&apos;;
}

local function DuplicateCharacterInto(character, parent)
&#9;local partSet = {}
&#9;--
&#9;for _, ch in pairs(character:GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;ch:Clone().Parent = parent
&#9;&#9;end
&#9;end
&#9;for _, partName in pairs(MainBodyPartList) do
&#9;&#9;local ch = Character:FindFirstChild(partName)
&#9;&#9;if ch and ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;local c = ch:Clone()
&#9;&#9;&#9;c.Parent = parent
&#9;&#9;&#9;c.Anchored = true
&#9;&#9;&#9;c.CanCollide = false
&#9;&#9;&#9;c.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.RightSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.LeftSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.FrontSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BackSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c:BreakJoints()
&#9;&#9;&#9;partSet[c.Name] = c
&#9;&#9;end
&#9;end
&#9;--
&#9;return partSet
end

local function CreateEffectModel(character)
&#9;local model;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, character)
&#9;else
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, Workspace.CurrentCamera)
&#9;end
&#9;model.Name = Player.Name..&quot;_EffectModel&quot;
&#9;return model
end

local function CreatePartPool()
&#9;local this = {}
&#9;
&#9;local mPartPoolPtr = 0
&#9;local mPartPool = {}
&#9;
&#9;function this:Allocate()
&#9;&#9;mPartPoolPtr = mPartPoolPtr + 1
&#9;&#9;local part = mPartPool[mPartPoolPtr]
&#9;&#9;if not part then
&#9;&#9;&#9;part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;local box = Instance.new(&apos;SelectionBox&apos;, part)
&#9;&#9;&#9;box.Adornee = part
&#9;&#9;&#9;box.Transparency = 0.3
&#9;&#9;&#9;box.Color = BrickColor.new(1010)
&#9;&#9;&#9;--
&#9;&#9;&#9;mPartPool[mPartPoolPtr] = part
&#9;&#9;end
&#9;&#9;return part
&#9;end
&#9;
&#9;function this:ResetPointer()
&#9;&#9;mPartPoolPtr = 0
&#9;end
&#9;
&#9;function this:HideRest()
&#9;&#9;for i = mPartPoolPtr+1, #mPartPool do
&#9;&#9;&#9;mPartPool[i].Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:HideAll()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateBlurEffect(parent, partSet)
&#9;local this = {}
&#9;local mTransparency = 0.5
&#9;local mVelocity = Vector3.new(0, 0, 0)
&#9;local mRiseDir = Vector3.new(0, 1, 0)
&#9;--
&#9;local mPartList = {}
&#9;local mTweenSet = {}
&#9;--
&#9;local tm = tick()
&#9;for part, _ in pairs(partSet) do
&#9;&#9;local dat = {}
&#9;&#9;dat.Part = part
&#9;&#9;dat.NextEmit = tm + math.random()*0.5
&#9;&#9;table.insert(mPartList, dat)
&#9;end
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;function this:SetVelocity(velo)
&#9;&#9;mVelocity = velo
&#9;end
&#9;
&#9;local function emit(part)
&#9;&#9;local dir = (CFrame.new(Vector3.new(), mRiseDir) * CFrame.Angles(0, 0, math.pi*2*math.random()) * CFrame.Angles(2*math.random(), 0, 0)).lookVector
&#9;&#9;local dat = {}
&#9;&#9;dat.CFrame = part.CFrame
&#9;&#9;dat.Direction = dir
&#9;&#9;dat.Emitted = tick()
&#9;&#9;dat.Lifetime = 0.4 + math.random()*0.3
&#9;&#9;dat.SpeedFactor = 1 + (math.random()*2-1)*0.5
&#9;&#9;dat.BaseSize = part.Size
&#9;&#9;dat.Velocity = mVelocity
&#9;&#9;local newPart = part:Clone()
&#9;&#9;dat.Part = newPart
&#9;&#9;newPart.Anchored = true
&#9;&#9;newPart.CanCollide = false
&#9;&#9;newPart.FormFactor = &apos;Custom&apos;
&#9;&#9;newPart.Transparency = mTransparency
&#9;&#9;newPart.BrickColor = BrickColor.new(23)
&#9;&#9;newPart.TopSurface = &apos;Smooth&apos;
&#9;&#9;newPart.BottomSurface = &apos;Smooth&apos;
&#9;&#9;newPart.RightSurface = &apos;Smooth&apos;
&#9;&#9;newPart.LeftSurface = &apos;Smooth&apos;
&#9;&#9;newPart:BreakJoints()
&#9;&#9;mTweenSet[dat] = true
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;-- Update rise dir&#9;
&#9;&#9;local desiredRise = (Vector3.new(0, 2, 0) - mVelocity).unit
&#9;&#9;if (desiredRise - mRiseDir).magnitude &lt;= 2*dt then
&#9;&#9;&#9;mRiseDir = desiredRise
&#9;&#9;else
&#9;&#9;&#9;mRiseDir = (mRiseDir + (desiredRise - mRiseDir).unit * (2*dt)).unit
&#9;&#9;end&#9;
&#9;&#9;
&#9;&#9;-- Update part list
&#9;&#9;for _, dat in pairs(mPartList) do
&#9;&#9;&#9;if tick() &gt; dat.NextEmit then
&#9;&#9;&#9;&#9;emit(dat.Part)
&#9;&#9;&#9;&#9;dat.NextEmit = tick() + (0.1 + math.random()*0.2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Update the tween parts
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;local frac = (tick() - dat.Emitted) / dat.Lifetime
&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;mTweenSet[dat] = nil
&#9;&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;dat.Part.Parent = parent
&#9;&#9;&#9;&#9;dat.Part:BreakJoints()
&#9;&#9;&#9;&#9;dat.Part.Size = dat.BaseSize * (1 - 0.3*frac)
&#9;&#9;&#9;&#9;dat.CFrame = dat.CFrame + (frac^1.5*dt*20*dat.SpeedFactor)*dat.Direction + dat.Velocity*dt
&#9;&#9;&#9;&#9;dat.Part.CFrame = dat.CFrame
&#9;&#9;&#9;&#9;dat.Part.Transparency = mTransparency + (1 - mTransparency)*(frac^1.5)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateSpinEffect(parent)
&#9;local this = {}
&#9;
&#9;local mTransparency = 0.5
&#9;local mCFrame = CFrame.new()
&#9;
&#9;local mRingSet = {}
&#9;local mRingCount = 0
&#9;local mNextRingAt = tick() + 0.5
&#9;local mDesiredRingCount = 8
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;
&#9;function this:SetCFrame(cf)
&#9;&#9;mCFrame = CFrame.new(cf.p)
&#9;end
&#9;
&#9;function this:AddRing()
&#9;&#9;local ring = PartList[math.random(1, #PartList)] 
&#9;&#9;mRingCount = mRingCount + 1
&#9;&#9;--
&#9;&#9;local dat = {}
&#9;&#9;dat.Started = tick()
&#9;&#9;dat.Created = dat.Started
&#9;&#9;dat.Mode = &apos;In&apos;
&#9;&#9;dat.PartRotOffset = (ring.CFrame - ring.CFrame.p)
&#9;&#9;dat.PartMoveOffset = ring.CFrame.p
&#9;&#9;--
&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;part.Anchored = true
&#9;&#9;part.CanCollide = false
&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;mesh.TextureId = &apos;rbxassetid://168892465&apos;
&#9;&#9;mesh.MeshId = ring.Mesh
&#9;&#9;mesh.VertexColor = Vector3.new(0, 0.5, 1)
&#9;&#9;--
&#9;&#9;dat.Part = part
&#9;&#9;dat.Mesh = mesh
&#9;&#9;dat.VerticalOffset = 4*(math.random()*2-1)
&#9;&#9;dat.Radius = 2 + 5*math.sqrt(1 - math.abs(dat.VerticalOffset/4))
&#9;&#9;dat.Theta = (math.random()*math.pi*2)
&#9;&#9;dat.TurnDirection = (math.random(0,1)*2-1)
&#9;&#9;dat.TurnSpeed = 3 + (math.random()*2-1)*2
&#9;&#9;mRingSet[dat] = true
&#9;end
&#9;
&#9;function this:ShedRing()
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;ring.Mode = &apos;Out&apos;
&#9;&#9;&#9;&#9;ring.Started = tick()
&#9;&#9;&#9;&#9;mRingCount = mRingCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;local now = tick()
&#9;&#9;
&#9;&#9;if now &gt; mNextRingAt then&#9;&#9;&#9;
&#9;&#9;&#9;if mRingCount &gt; mDesiredRingCount then
&#9;&#9;&#9;&#9;this:ShedRing()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;this:AddRing()
&#9;&#9;&#9;end
&#9;&#9;&#9;mNextRingAt = now + (0.1 + math.random()*(0.3 * (mRingCount / mDesiredRingCount)))
&#9;&#9;end
&#9;&#9;
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;local frac = (now - ring.Started) / 2
&#9;&#9;&#9;local radius = nil
&#9;&#9;&#9;local trans = nil
&#9;&#9;&#9;if ring.Mode == &apos;In&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;ring.Mode = &apos;Norm&apos;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local turnFactor = 0.2 + 0.8*(0.5+0.5*math.cos(frac*math.pi))^2
&#9;&#9;&#9;&#9;&#9;local turnSpeed = ring.TurnSpeed + turnFactor*10
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*turnSpeed)
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + turnFactor*5
&#9;&#9;&#9;&#9;&#9;trans = frac
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif ring.Mode == &apos;Out&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;mRingSet[ring] = nil
&#9;&#9;&#9;&#9;&#9;ring.Part:Destroy()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + 5*(frac^2)
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)
&#9;&#9;&#9;&#9;&#9;trans = frac^2
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;radius = ring.Radius
&#9;&#9;&#9;&#9;trans = 1
&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;if mRingSet[ring] then
&#9;&#9;&#9;&#9;local sz = radius / 4
&#9;&#9;&#9;&#9;ring.Mesh.Scale = Vector3.new(sz, 1, sz)
&#9;&#9;&#9;&#9;ring.Part.Parent = parent
&#9;&#9;&#9;&#9;ring.Part.CFrame = (mCFrame * CFrame.new(0, ring.VerticalOffset, 0) * CFrame.Angles(0, ring.Theta, 0) * CFrame.new(ring.PartMoveOffset*sz)) * ring.PartRotOffset
&#9;&#9;&#9;&#9;ring.Part.Transparency = 1 - (1-mTransparency)*(1-trans)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateLightningEffect(parent)
&#9;local this = {}
&#9;
&#9;local mPartPool = CreatePartPool()
&#9;local mActive = false
&#9;local mActivatedAt = 0
&#9;local mFrom = Vector3.new()
&#9;local mTo = Vector3.new()
&#9;local mLightningPath = {{P = mFrom; T = tick(); Expiry = 0}}
&#9;local mLightningPart = Instance.new(&apos;Part&apos;)
&#9;mLightningPart.Anchored = true
&#9;mLightningPart.CanCollide = false
&#9;mLightningPart.FormFactor = &apos;Custom&apos;
&#9;mLightningPart.Size = Vector3.new()
&#9;mLightningPart.Transparency = 1
&#9;local fire = Instance.new(&apos;Fire&apos;, mLightningPart)
&#9;fire.Heat = 20
&#9;fire.Color = Color3.new(10/255, 149/255, 255/255)
&#9;fire.SecondaryColor = Color3.new(0, 0, 0)
&#9;fire.Size = 5
&#9;fire:Clone().Parent = mLightningPart
&#9;local light = Instance.new(&apos;PointLight&apos;, mLightningPart)
&#9;light.Brightness = 2
&#9;light.Range = 4
&#9;light.Color = Color3.new(0/255, 153/255, 255/255)
&#9;
&#9;local function tickPath(dt)
&#9;&#9;local cachedPoints = {}
&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;local i = 1
&#9;&#9;local now = tick()&#9;
&#9;&#9;while true do&#9;
&#9;&#9;&#9;-- Fudge the current point&#9;&#9;
&#9;&#9;&#9;local currentPoint = mLightningPath[i]
&#9;&#9;&#9;currentPoint.P = currentPoint.P + Vector3.new(math.random()*2-1, math.random()*2-1, math.random()*2-1)*(5*dt)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;-- Are we at the goal?&#9;
&#9;&#9;&#9;-- If we are then clear out the other points
&#9;&#9;&#9;if (currentPoint.P - mTo).magnitude &lt; 0.5 then
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Not at the goal, do we have a next point?
&#9;&#9;&#9;local useNext;
&#9;&#9;&#9;local nextPoint = mLightningPath[i+1]
&#9;&#9;&#9;if nextPoint then
&#9;&#9;&#9;&#9;local toNext = nextPoint.P - currentPoint.P
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Is the next point near the goal?&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.6 then
&#9;&#9;&#9;&#9;&#9;-- Just snap it to the goal
&#9;&#9;&#9;&#9;&#9;nextPoint.P = mTo
&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- 
&#9;&#9;&#9;&#9;&#9;if math.acos(toNext.unit:Dot(toGoal.unit)) &gt; math.pi/2 then
&#9;&#9;&#9;&#9;&#9;&#9;-- The next point is too far out of direction
&#9;&#9;&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;if useNext and (now - currentPoint.T) &gt; currentPoint.Expiry then
&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P - mFrom).magnitude / (mFrom - mTo).magnitude&#9;
&#9;&#9;&#9;&#9;currentPoint.Expiry = math.random()*0.1 + 0.6*fracThere
&#9;&#9;&#9;&#9;currentPoint.T = now
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- If we can&apos;t use the next then we need to do some work
&#9;&#9;&#9;if not useNext then
&#9;&#9;&#9;&#9;-- Move all the points ahead to the cached list
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;table.insert(cachedPoints, mLightningPath[j])
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Create the next point
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.5 then
&#9;&#9;&#9;&#9;&#9;-- If we&apos;re close enough to the goal, just snap there
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {P = mTo; T = now; Expiry = math.random()*0.4})
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- Otherwise, perturb the direction
&#9;&#9;&#9;&#9;&#9;local upwards = math.min(1, (now - mActivatedAt) / 0.8)
&#9;&#9;&#9;&#9;&#9;if upwards == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;mActivatedAt = now
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local dir = CFrame.new(Vector3.new(), toGoal) * CFrame.Angles(0.2 + upwards*0.5, 0, 0) * CFrame.Angles(0, 0, math.random()*math.pi*2) * CFrame.Angles(math.random()*math.pi/3, 0, 0)
&#9;&#9;&#9;&#9;&#9;dir = dir.lookVector * (2 + math.random()*1)
&#9;&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P + dir - mFrom).magnitude / (mFrom - mTo).magnitude
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {
&#9;&#9;&#9;&#9;&#9;&#9;P = currentPoint.P + dir;
&#9;&#9;&#9;&#9;&#9;&#9;T = now;
&#9;&#9;&#9;&#9;&#9;&#9;Expiry = math.random()*0.1 + 0.6*fracThere;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Done
&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;if i &gt; 40 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function drawPath()
&#9;&#9;mPartPool:ResetPointer()
&#9;&#9;for i = 1, #mLightningPath - 1 do
&#9;&#9;&#9;local a = mLightningPath[i].P
&#9;&#9;&#9;local b = mLightningPath[i+1].P
&#9;&#9;&#9;--
&#9;&#9;&#9;local frac = i / (#mLightningPath-1)
&#9;&#9;&#9;local w = 0.2 + 0.2*(1 - 2*math.abs(frac - 0.5))
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = mPartPool:Allocate()
&#9;&#9;&#9;part.Size = Vector3.new(w, w, (a-b).magnitude)
&#9;&#9;&#9;part.CFrame = CFrame.new(0.5*(a+b), b)
&#9;&#9;&#9;part.Parent = parent
&#9;&#9;&#9;part.Transparency = 1
&#9;&#9;end
&#9;&#9;mPartPool:HideRest()
&#9;&#9;mLightningPart.CFrame = CFrame.new(mTo)
&#9;&#9;mLightningPart.Parent = parent
&#9;end
&#9;
&#9;function this:Set(from, to)
&#9;&#9;mFrom = from
&#9;&#9;mTo = to
&#9;end
&#9;
&#9;function this:SetActive(state)
&#9;&#9;if mActive == state then return end
&#9;&#9;mActive = state
&#9;&#9;if mActive then
&#9;&#9;&#9;mActivatedAt = tick()
&#9;&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;&#9;for i = 2, #mLightningPath do
&#9;&#9;&#9;&#9;mLightningPath[i] = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;mPartPool:HideAll()
&#9;&#9;&#9;mLightningPart.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;if mActive then
&#9;&#9;&#9;tickPath(dt)
&#9;&#9;&#9;drawPath()
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;mPartPool:Destroy()
&#9;end
&#9;
&#9;return this
end

local BREAKOFF_TIME = 1
local FLOAT_FINISH_TIME = 3
local FLOAT_HEIGHT = 10
--
local RISE_VELOCITY = FLOAT_FINISH_TIME / FLOAT_HEIGHT

local function TransformationSequence(character)
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;local dir = torso.CFrame.lookVector
&#9;local transformBase = CFrame.new(torso.Position, torso.Position + Vector3.new(dir.X, 0, dir.Z))
&#9;
&#9;-- Remove the tools
&#9;Delay(0.2, function()
&#9;&#9;for _, tool in pairs(Player:WaitForChild(&apos;Backpack&apos;):GetChildren()) do
&#9;&#9;&#9;if tool:IsA(&apos;Tool&apos;) or tool:IsA(&apos;Hopperbin&apos;) then
&#9;&#9;&#9;&#9;tool.Parent = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for _, tool in pairs(Character:GetChildren()) do
&#9;&#9;&#9;if tool:IsA(&apos;Tool&apos;) then
&#9;&#9;&#9;&#9;tool.Parent = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;
&#9;-- If not filtering, we can clone the viewLocal into the other clients
&#9;local addViewCn;
&#9;if not Workspace.FilteringEnabled then
&#9;&#9;local viewLocal = script:WaitForChild(&apos;ViewLocal&apos;)
&#9;&#9;for _, player in pairs(Players:GetChildren()) do
&#9;&#9;&#9;if player ~= Player then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;local cl = viewLocal:Clone()
&#9;&#9;&#9;&#9;&#9;cl:WaitForChild(&apos;TargetCharacter&apos;).Value = character
&#9;&#9;&#9;&#9;&#9;cl.Disabled = false
&#9;&#9;&#9;&#9;&#9;while not player.Character do player.Changed:wait() end
&#9;&#9;&#9;&#9;&#9;cl.Parent = player.Character
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;-- .PlayerAdded does not work for other players on the client
&#9;&#9;addViewCn = Players.ChildAdded:connect(function(player)
&#9;&#9;&#9;if not player:IsA(&apos;Player&apos;) then return end
&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;local cl = viewLocal:Clone()
&#9;&#9;&#9;&#9;cl:WaitForChild(&apos;TargetCharacter&apos;).Value = character
&#9;&#9;&#9;&#9;cl.Disabled = false
&#9;&#9;&#9;&#9;while not player.Character do player.Changed:wait() end
&#9;&#9;&#9;&#9;cl.Parent = player.Character
&#9;&#9;&#9;end)&#9;&#9;&#9;
&#9;&#9;end)
&#9;end
&#9;
&#9;-- Gather the parts to do the tween on
&#9;local partsToTween = {}
&#9;local function gatherParts(object)
&#9;&#9;for _, ch in pairs(object:GetChildren()) do
&#9;&#9;&#9;if ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;local tweenPart = {
&#9;&#9;&#9;&#9;&#9;Part = ch;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;table.insert(partsToTween, tweenPart)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;gatherParts(ch)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;gatherParts(character)
&#9;
&#9;-- The effect model
&#9;local effectModel = CreateEffectModel(character)
&#9;
&#9;-- Duplicate the parts we want normally, but want to make fly away
&#9;local flyAwayParts = DuplicateCharacterInto(character, effectModel)
&#9;
&#9;-- Put the body parts into a set
&#9;local flyAwayPartSet = {}

&#9;-- Decide what to do with each of the parts
&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;if flyAwayParts[dat.Part.Name] then
&#9;&#9;&#9;flyAwayPartSet[dat.Part] = true
&#9;&#9;&#9;dat.Mode = &apos;BreakAway&apos;
&#9;&#9;&#9;dat.BreakAwayPart = flyAwayParts[dat.Part.Name]
&#9;&#9;else
&#9;&#9;&#9;dat.Mode = &apos;Fade&apos;
&#9;&#9;end
&#9;end
&#9;
&#9;-- Anchor and ready the character
&#9;torso.Anchored = true
&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;
&#9;-- Go into the transformation sequence
&#9;local transformStart = tick()
&#9;local transformLast = transformStart
&#9;local transformBase = character.Torso.CFrame * CFrame.new(0, -3, 0)
&#9;transformBase = CFrame.new(transformBase.p, transformBase.p + Vector3.new(transformBase.lookVector.X, 0, transformBase.lookVector.z))
&#9;
&#9;-- Generate some of the effects
&#9;local effectSet = {}

&#9;-- Takeoff ground waves
&#9;do
&#9;&#9;local waves = {}
&#9;&#9;for i = 1, 4 do
&#9;&#9;&#9;local wave = {}
&#9;&#9;&#9;wave.Delay = ((i-1)/4)*0.25 + math.random()*0.3
&#9;&#9;&#9;wave.Size = ((5-i)/4)*15 + math.random()*3
&#9;&#9;&#9;wave.Duration = 0.5 + math.random()*0.2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.CFrame = transformBase * CFrame.new(math.random()*4-2, 0, math.random()*4-2)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Sphere&apos;
&#9;&#9;&#9;wave.Part = part
&#9;&#9;&#9;wave.Mesh = mesh
&#9;&#9;&#9;table.insert(waves, wave)
&#9;&#9;end
&#9;&#9;local function updateWaves(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay + wave.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - wave.Delay) / wave.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local fracIn = 1 - frac^0.25
&#9;&#9;&#9;&#9;&#9;&#9;local fracOut = frac^5
&#9;&#9;&#9;&#9;&#9;&#9;wave.Mesh.Scale = Vector3.new(wave.Size * fracIn, 0.1 + 9*fracOut, wave.Size * fracIn)
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Transparency = 0.3 + 0.7*fracOut
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyWaves()
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateWaves;
&#9;&#9;&#9;Destroy = destroyWaves;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Takeoff vertical risers
&#9;do
&#9;&#9;local risers = {}
&#9;&#9;for i = 1, 6 do
&#9;&#9;&#9;local riser = {}
&#9;&#9;&#9;riser.Delay = 0.3 + math.random() * 0.4
&#9;&#9;&#9;riser.Duration = 1 + math.random() * 1.5
&#9;&#9;&#9;riser.Offset = CFrame.new(math.random()*4 - 2, 0, math.random()*4 - 2)
&#9;&#9;&#9;riser.Width = 0.3 + math.random() * 0.5
&#9;&#9;&#9;riser.Height = 1 + math.random() * 2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Brick&apos;
&#9;&#9;&#9;riser.Part = part
&#9;&#9;&#9;riser.Mesh = mesh
&#9;&#9;&#9;table.insert(risers, riser)
&#9;&#9;end
&#9;&#9;local function updateRisers(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay + riser.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - riser.Delay) / riser.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local rampFrac = 1 - math.abs(frac - 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;local widthFrac = rampFrac^2
&#9;&#9;&#9;&#9;&#9;&#9;local heightFrac = rampFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Mesh.Scale = Vector3.new(riser.Width * widthFrac, riser.Height * heightFrac, riser.Width * widthFrac)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Transparency = 0.2 --widthFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.CFrame = transformBase * riser.Offset * CFrame.new(0, -riser.Height/2 + frac^2*(6 + riser.Height), 0) * CFrame.Angles(0, frac*8, 0)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyRisers()
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateRisers;
&#9;&#9;&#9;Destroy = destroyRisers;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Main effect
&#9;local blurEffect = CreateBlurEffect(effectModel, flyAwayPartSet)
&#9;
&#9;-- The ring effect
&#9;local ringEffect = CreateSpinEffect(effectModel)
&#9;
&#9;-- Main transformation sequence
&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;-- How much time has elapsed
&#9;&#9;local now = tick()
&#9;&#9;local dt = now - transformLast
&#9;&#9;local elapsed = now - transformStart
&#9;&#9;transformLast = now
&#9;&#9;
&#9;&#9;-- Run any effects
&#9;&#9;for effect, _ in pairs(effectSet) do
&#9;&#9;&#9;if effect.Update(elapsed, dt) then
&#9;&#9;&#9;&#9;effect.Destroy()
&#9;&#9;&#9;&#9;effectSet[effect] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Main timer
&#9;&#9;local frac = math.min(1, elapsed / FLOAT_FINISH_TIME)
&#9;&#9;local breakFrac = math.max(0, math.min(1, (elapsed - BREAKOFF_TIME) / (FLOAT_FINISH_TIME - BREAKOFF_TIME)))
&#9;&#9;local moveFrac = frac^1.2
&#9;&#9;
&#9;&#9;-- Float up the torso
&#9;&#9;if not Workspace.FilteringEnabled then
&#9;&#9;&#9;torso.Anchored = false
&#9;&#9;&#9;torso.CFrame = transformBase * CFrame.new(0, 3 + moveFrac * FLOAT_HEIGHT, 0)&#9;
&#9;&#9;&#9;torso.Anchored = true
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Tween part positions + transparency
&#9;&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;&#9;if dat.Mode == &apos;Fade&apos; then
&#9;&#9;&#9;&#9;dat.Part.Transparency = frac
&#9;&#9;&#9;elseif dat.Mode == &apos;BreakAway&apos; then
&#9;&#9;&#9;&#9;if dat.Part.Name == &apos;Head&apos; then
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 0.99
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if elapsed &gt; BREAKOFF_TIME then
&#9;&#9;&#9;&#9;&#9;if not dat.Broken then
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;&#9;&#9;for _, ch in pairs(dat.Part:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ch:IsA(&apos;Decal&apos;) then ch:Destroy() end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakVelocity = Vector3.new(math.random()-0.5, 1, math.random()-0.5).unit * 4*(1+math.random())
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakRotVelocity = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5)*5
&#9;&#9;&#9;&#9;&#9;&#9;dat.Broken = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local rvelo = dat.BreakRotVelocity*dt
&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = (dat.BreakCFrame + dat.BreakVelocity*dt) * CFrame.Angles(rvelo.X, rvelo.Y, rvelo.Z)
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.BreakCFrame
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.Transparency = (frac &lt; 0.5) and 0 or ((frac-0.5)/0.5)^2
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;assert(false, &quot;unreachable&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Fade in blur effect
&#9;&#9;blurEffect:SetTransparency(1 - frac*0.7)
&#9;&#9;blurEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Fade in ring effect
&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;ringEffect:SetTransparency(1 - breakFrac*0.7)
&#9;&#9;ringEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Exit
&#9;&#9;if elapsed &gt; FLOAT_FINISH_TIME + 0.5 then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;
&#9;&#9;RunService.RenderStepped:wait()
&#9;end
&#9;
&#9;for _, part in pairs(flyAwayParts) do
&#9;&#9;part:Destroy()
&#9;end
&#9;for _, obj in pairs(effectModel:GetChildren()) do
&#9;&#9;if obj:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;obj:Destroy()
&#9;&#9;end
&#9;end
&#9;blurEffect:SetTransparency(0.3)
&#9;blurEffect:Update(0)
&#9;ringEffect:SetTransparency(0.3)
&#9;ringEffect:Update(0)
&#9;
&#9;return addViewCn, effectModel, blurEffect, ringEffect
end

local mDirectionKey = {
&#9;w = Vector3.new(0, 0, -1);
&#9;s = Vector3.new(0, 0, 1);
&#9;a = Vector3.new(-1, 0, 0);
&#9;d = Vector3.new(1, 0, 0);
&#9;[string.char(17)] = Vector3.new(0, 0, -1);
&#9;[string.char(18)] = Vector3.new(0, 0, 1);
&#9;[string.char(20)] = Vector3.new(-1, 0, 0);
&#9;[string.char(19)] = Vector3.new(1, 0, 0);
}
local mKeySet = {}

local MouseDown = false

local Anim;

function RunController(addViewCn, character, effectModel, blurEffect, ringEffect)
&#9;-- Already dead
&#9;if not (character.Parent and character:FindFirstChild(&apos;Humanoid&apos;) and character.Humanoid.Health &gt; 0) then
&#9;&#9;effectModel:Destroy()
&#9;&#9;if addViewCn then
&#9;&#9;&#9;addViewCn:disconnect()
&#9;&#9;end
&#9;&#9;return nil
&#9;end
&#9;--
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;local anim = script:WaitForChild(&apos;FlyAnimation&apos;)
&#9;Anim = humanoid:LoadAnimation(anim)
&#9;Anim:Play(2)
&#9;--
&#9;local turn, move;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;turn = torso:WaitForChild(&apos;Turn&apos;)
&#9;&#9;move = torso:WaitForChild(&apos;Move&apos;)
&#9;else
&#9;&#9;turn = Instance.new(&apos;BodyGyro&apos;, torso)
&#9;&#9;turn.maxTorque = Vector3.new(10000, 10000, 10000)
&#9;&#9;turn.cframe = torso.CFrame
&#9;&#9;--
&#9;&#9;move = Instance.new(&apos;BodyPosition&apos;, torso)
&#9;&#9;move.maxForce = Vector3.new(10000, 10000, 10000)
&#9;&#9;move.position = torso.Position
&#9;end
&#9;--
&#9;local fireSound = Instance.new(&apos;Sound&apos;, effectModel)
&#9;fireSound.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound.Pitch = 1.5
&#9;fireSound.Volume = 0.25
&#9;fireSound.Looped = true
&#9;local fireSound2 = Instance.new(&apos;Sound&apos;, effectModel)
&#9;fireSound2.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound2.Pitch = 1.5
&#9;fireSound2.Volume = 0.25
&#9;fireSound2.Looped = true&#9;
&#9;--
&#9;local UpdateMove;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;UpdateMove = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;UpdateMove&apos;)
&#9;&#9;local val = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;ControlReady&apos;)
&#9;&#9;while not val.Value do val.Changed:wait() end
&#9;end
&#9;--
&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;torso.Anchored = false
&#9;--
&#9;local mMovementPosition = torso.Position
&#9;local mMoveVelocity = Vector3.new()
&#9;local mMoveYVelocity = 0
&#9;--
&#9;local function updateMove(dt)
&#9;&#9;-- Get the local space move direction
&#9;&#9;local moveDir = Vector3.new()
&#9;&#9;for key, d in pairs(mDirectionKey) do
&#9;&#9;&#9;if mKeySet[key] then
&#9;&#9;&#9;&#9;moveDir = moveDir + d
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;moveDir = moveDir.unit
&#9;&#9;
&#9;&#9;-- To global space
&#9;&#9;local cam = Workspace.CurrentCamera.CoordinateFrame
&#9;&#9;local dirCF = CFrame.new(cam.p, cam.p + Vector3.new(cam.lookVector.x, 0, cam.lookVector.z))
&#9;&#9;moveDir = dirCF:vectorToWorldSpace(moveDir)
&#9;&#9;
&#9;&#9;-- Accelerate
&#9;&#9;if moveDir.magnitude &gt; 0.01 then
&#9;&#9;&#9;mMoveVelocity = mMoveVelocity + moveDir*(dt*80)
&#9;&#9;&#9;if mMoveVelocity.magnitude &gt; 20 then
&#9;&#9;&#9;&#9;mMoveVelocity = mMoveVelocity.unit*20
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;if mMoveVelocity.magnitude &gt; 0 then
&#9;&#9;&#9;&#9;mMoveVelocity = mMoveVelocity.unit * math.max(0, mMoveVelocity.magnitude - dt*30)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Move
&#9;&#9;mMovementPosition = mMovementPosition + mMoveVelocity*dt
&#9;&#9;
&#9;&#9;-- Movement is blocked
&#9;&#9;if (mMovementPosition - torso.Position).magnitude &gt; 5 then
&#9;&#9;&#9;mMovementPosition = mMovementPosition + (torso.Position - mMovementPosition).unit * 5
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Adjust height
&#9;&#9;local toIgnore = {Character}
&#9;&#9;local downRay = Ray.new(mMovementPosition, Vector3.new(0, -1000, 0))
&#9;&#9;local hit, at = Workspace:FindPartOnRayWithIgnoreList(downRay, toIgnore)
&#9;&#9;while hit and not hit.CanCollide do
&#9;&#9;&#9;table.insert(toIgnore, hit)
&#9;&#9;&#9;downRay = Ray.new(at, Vector3.new(0, -1000, 0))
&#9;&#9;&#9;hit, at = Workspace:FindPartOnRayWithIgnoreList(downRay, toIgnore)
&#9;&#9;end
&#9;&#9;local float = (at - mMovementPosition).magnitude
&#9;&#9;if float &gt; FLOAT_HEIGHT then
&#9;&#9;&#9;mMoveYVelocity = mMoveYVelocity - 9.81*20*dt
&#9;&#9;&#9;mMovementPosition = mMovementPosition + Vector3.new(0, math.min(float - FLOAT_HEIGHT, mMoveYVelocity*dt), 0)
&#9;&#9;else
&#9;&#9;&#9;mMoveYVelocity = 0
&#9;&#9;&#9;mMovementPosition = mMovementPosition + Vector3.new(0, math.max(FLOAT_HEIGHT - float - 1), 0)
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Update objects
&#9;&#9;move.position = mMovementPosition
&#9;&#9;if mMoveVelocity.magnitude &gt; 0 then
&#9;&#9;&#9;turn.cframe = CFrame.new(Vector3.new(), mMoveVelocity)
&#9;&#9;end
&#9;end
&#9;--
&#9;local lightningEffect = CreateLightningEffect(effectModel)
&#9;lightningEffect:SetActive(true)
&#9;--
&#9;local lightningActive = false
&#9;local lightningActiveSince = 0
&#9;local lightningRunId = 0
&#9;--
&#9;local lastDamagedHum = nil
&#9;local lastDamagedAt = 0
&#9;local lastDamagedCreator;
&#9;local DamagePerSecond = 70
&#9;--
&#9;Spawn(function()
&#9;&#9;local lastTime = tick()
&#9;&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now

&#9;&#9;&#9;-- Movement
&#9;&#9;&#9;updateMove(dt)
&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;UpdateMove:InvokeServer(Workspace.DistributedGameTime, mMovementPosition, mMoveVelocity, mMoveYVelocity)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Attack effect
&#9;&#9;&#9;local toIgnore = {Character, effectModel}
&#9;&#9;&#9;local ray = Ray.new(Mouse.UnitRay.Origin, Mouse.UnitRay.Direction*999)
&#9;&#9;&#9;local hit, at = Workspace:FindPartOnRayWithIgnoreList(ray, toIgnore)
&#9;&#9;&#9;while hit and hit.Transparency == 1 do
&#9;&#9;&#9;&#9;table.insert(toIgnore, hit)
&#9;&#9;&#9;&#9;hit, at = Workspace:FindPartOnRayWithIgnoreList(ray, toIgnore)
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;local hitHumanoid;
&#9;&#9;&#9;if hit then
&#9;&#9;&#9;&#9;local hum = hit.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;&#9;if hum then hitHumanoid = hum end
&#9;&#9;&#9;&#9;if hit.Parent.Parent then
&#9;&#9;&#9;&#9;&#9;hum = hit.Parent.Parent:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;&#9;&#9;&#9;if hum then hitHumanoid = hum end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;local mouseAt = at
&#9;&#9;&#9;local vec = mouseAt - torso.Position
&#9;&#9;&#9;if not MouseDown or not hit or vec.magnitude &gt; 60 then
&#9;&#9;&#9;&#9;lightningEffect:SetActive(false)
&#9;&#9;&#9;&#9;if lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActive = false
&#9;&#9;&#9;&#9;&#9;fireSound:Stop()
&#9;&#9;&#9;&#9;&#9;fireSound2:Stop()
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if lastDamagedHum then
&#9;&#9;&#9;&#9;&#9;if not Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;&#9;-- Deal remaining damage to the old target
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum:TakeDamage((now - lastDamagedAt)*DamagePerSecond)
&#9;&#9;&#9;&#9;&#9;&#9;Game:GetService(&apos;Debris&apos;):AddItem(lastDamagedCreator, 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator = nil
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum = nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local sc = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;)
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;IsShooting&apos;).Value = false
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;HumanoidToDamage&apos;).Value = nil
&#9;&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;UpdateShoot&apos;):FireServer(false, Vector3.new(), Vector3.new(), nil)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if not lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActive = true
&#9;&#9;&#9;&#9;&#9;lightningActiveSince = now
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound:Play()
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;&#9;local thisRunId = lightningRunId
&#9;&#9;&#9;&#9;&#9;Delay(0.2, function()
&#9;&#9;&#9;&#9;&#9;&#9;if lightningRunId == thisRunId then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;fireSound2:Play()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local frac = math.min(1, (now - lightningActiveSince) / 0.3)
&#9;&#9;&#9;&#9;&#9;local modPitch = 1.5 - 0.7*(1-frac)
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = modPitch
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = modPitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;lightningEffect:Set(torso.Position, torso.Position + vec)
&#9;&#9;&#9;&#9;lightningEffect:SetActive(true)
&#9;&#9;&#9;&#9;lightningEffect:Update(dt)
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;if not Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;-- Do damage on the client
&#9;&#9;&#9;&#9;&#9;if lastDamagedHum ~= hitHumanoid then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Switch target&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;if lastDamagedHum then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum:TakeDamage((now - lastDamagedAt)*DamagePerSecond)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Game:GetService(&apos;Debris&apos;):AddItem(lastDamagedCreator, 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum = hitHumanoid
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator = Instance.new(&apos;ObjectValue&apos;)
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Value = Player
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Name = &apos;creator&apos;
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedCreator.Parent = hitHumanoid
&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedAt = now
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if lastDamagedHum then
&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Try damage target&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;if (now - lastDamagedAt) &gt; 0.1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Damage target&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedHum:TakeDamage((now - lastDamagedAt)*DamagePerSecond)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lastDamagedAt = now
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local sc = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;)
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;ShootFrom&apos;).Value = torso.Position
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;ShootTo&apos;).Value = torso.Position + vec
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;HumanoidToDamage&apos;).Value = hitHumanoid
&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;IsShooting&apos;).Value = true
&#9;&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;sc:WaitForChild(&apos;UpdateShoot&apos;):FireServer(true, torso.Position, torso.Position + vec, hitHumanoid)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Character effects
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;blurEffect:SetVelocity(torso.Velocity)
&#9;&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;--
&#9;&#9;&#9;while _G.Stop do wait() end
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end
&#9;&#9;
&#9;&#9;if addViewCn then
&#9;&#9;&#9;addViewCn:disconnect()
&#9;&#9;end
&#9;&#9;if lastDamagedCreator then
&#9;&#9;&#9;Game:GetService(&apos;Debris&apos;):AddItem(lastDamagedCreator, 1)
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Destroy the movers
&#9;&#9;turn:Destroy()
&#9;&#9;move:Destroy()
&#9;&#9;
&#9;&#9;-- Turn off the lightning if still running
&#9;&#9;fireSound:Stop()
&#9;&#9;fireSound2:Stop()
&#9;&#9;local sc = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;)
&#9;&#9;sc:WaitForChild(&apos;IsShooting&apos;).Value = false
&#9;&#9;lightningEffect:SetActive(false)&#9;&#9;
&#9;&#9;
&#9;&#9;-- Fade out the other effects
&#9;&#9;local lastTime = tick()
&#9;&#9;local trans = 0.3
&#9;&#9;while character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;trans = math.min(1, trans + 0.5*dt)
&#9;&#9;&#9;blurEffect:SetTransparency(trans)
&#9;&#9;&#9;ringEffect:SetTransparency(trans)
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Finally Kill the effects and end
&#9;&#9;effectModel:Destroy()
&#9;end)
&#9;--
&#9;local this = {}
&#9;--
&#9;function this:ShootAt()
&#9;&#9;
&#9;end
&#9;--&#9;
&#9;return this
end

local addViewCn, effectModel, blurEffect, ringEffect = TransformationSequence(Character)
local Controller = RunController(addViewCn, Character, effectModel, blurEffect, ringEffect)

if Controller then
&#9;Mouse.Button1Down:connect(function()
&#9;&#9;Controller:ShootAt()
&#9;&#9;MouseDown = true
&#9;end)
&#9;Mouse.Button1Up:connect(function()
&#9;&#9;MouseDown = false
&#9;end)
&#9;Mouse.KeyDown:connect(function(key)
&#9;&#9;print(&quot;Key:&quot;, string.byte(key))
&#9;&#9;key = key:lower()
&#9;&#9;mKeySet[key] = true
&#9;end)
&#9;Mouse.KeyUp:connect(function(key)
&#9;&#9;key = key:lower()
&#9;&#9;mKeySet[key] = nil
&#9;end)
end












</ProtectedString>
			</Properties>
			<Item class="LocalScript" referent="RBX17">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ViewLocal</string>
					<ProtectedString name="Source">Players = Game:GetService(&apos;Players&apos;)
RunService = Game:GetService(&apos;RunService&apos;)

-- Remove us from the hierarchy, so that we stay around even if the player running is respawns
coroutine.yield()
script.Parent = nil

-- Get the charater to use
local TargetCharacter = script:WaitForChild(&apos;TargetCharacter&apos;)
while not TargetCharacter.Value do TargetCharacter.Changed:wait() end
local Character = TargetCharacter.Value
if not Character then return end
local Player = Players:GetPlayerFromCharacter(Character)
if not Player then return end
-- 

local PartList = {
&#9;{
&#9;&#9;-- 15 degrees
&#9;&#9;Sweep = 20;
&#9;&#9;Mesh = &apos;rbxassetid://168892318&apos;;
&#9;&#9;CFrame = CFrame.new(-2.028, 0.003, 0.063, 0.482962936, -0.258818984, -0.836516321, 0.129409432, 0.965925813, -0.224143848, 0.866025388, 6.70552254e-008, 0.5);
&#9;},
&#9;{
&#9;&#9;-- 180 degrees
&#9;&#9;Sweep = 180;
&#9;&#9;Mesh = &apos;rbxassetid://168892343&apos;;
&#9;&#9;CFrame = CFrame.new(-0.500, -0.169, -0.275, -0.546336055, 0.136979967, 0.826288223, -0.0343417339, 0.982042372, -0.185506523, -0.836861134, -0.129725233, -0.531821132);
&#9;},
&#9;{
&#9;&#9;-- 30 degrees
&#9;&#9;Sweep = 40;
&#9;&#9;Mesh = &apos;rbxassetid://168892363&apos;;
&#9;&#9;CFrame = CFrame.new(-1.738, -0.056, -0.034, 0.913205206, -0.157400429, -0.375873566, 0.0347544663, 0.949112594, -0.313011229, 0.406014502, 0.272780538, 0.872205615);
&#9;},
&#9;{
&#9;&#9;-- 250 degrees
&#9;&#9;Sweep = 250;
&#9;&#9;Mesh = &apos;rbxassetid://168892387&apos;;
&#9;&#9;CFrame = CFrame.new(0.033, -0.053, -0.015, -0.947963715, 0.129520699, 0.290842265, 0.0606384911, 0.970239401, -0.23443158, -0.312550366, -0.20459649, -0.927605391);
&#9;},
&#9;{
&#9;&#9;-- 200 degrees
&#9;&#9;Sweep = 200;
&#9;&#9;Mesh = &apos;rbxassetid://168892408&apos;;
&#9;&#9;CFrame = CFrame.new(-0.293, -0.027, -0.226, -0.517871141, -0.154164821, -0.841452301, 0.081988588, 0.970154822, -0.228204504, 0.85152036, -0.187170446, -0.489775389);
&#9;},
}

local MainBodyPartList = {
&#9;&apos;Head&apos;, &apos;Torso&apos;, &apos;Right Arm&apos;, &apos;Left Arm&apos;, &apos;Right Leg&apos;, &apos;Left Leg&apos;;
}

local function DuplicateCharacterInto(character, parent)
&#9;local partSet = {}
&#9;--
&#9;for _, ch in pairs(character:GetChildren()) do
&#9;&#9;if ch:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;ch:Clone().Parent = parent
&#9;&#9;end
&#9;end
&#9;for _, partName in pairs(MainBodyPartList) do
&#9;&#9;local ch = Character:FindFirstChild(partName)
&#9;&#9;if ch and ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;local c = ch:Clone()
&#9;&#9;&#9;c.Parent = parent
&#9;&#9;&#9;c.Anchored = true
&#9;&#9;&#9;c.CanCollide = false
&#9;&#9;&#9;c.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.RightSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.LeftSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.FrontSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c.BackSurface = &apos;Smooth&apos;
&#9;&#9;&#9;c:BreakJoints()
&#9;&#9;&#9;partSet[c.Name] = c
&#9;&#9;end
&#9;end
&#9;--
&#9;return partSet
end

local function CreateEffectModel(character)
&#9;local model;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, character)
&#9;else
&#9;&#9;model = Instance.new(&apos;Configuration&apos;, Workspace.CurrentCamera)
&#9;end
&#9;model.Name = Player.Name..&quot;_EffectModel&quot;
&#9;return model
end

local function CreatePartPool()
&#9;local this = {}
&#9;
&#9;local mPartPoolPtr = 0
&#9;local mPartPool = {}
&#9;
&#9;function this:Allocate()
&#9;&#9;mPartPoolPtr = mPartPoolPtr + 1
&#9;&#9;local part = mPartPool[mPartPoolPtr]
&#9;&#9;if not part then
&#9;&#9;&#9;part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;local box = Instance.new(&apos;SelectionBox&apos;, part)
&#9;&#9;&#9;box.Adornee = part
&#9;&#9;&#9;box.Transparency = 0.3
&#9;&#9;&#9;box.Color = BrickColor.new(1010)
&#9;&#9;&#9;--
&#9;&#9;&#9;mPartPool[mPartPoolPtr] = part
&#9;&#9;end
&#9;&#9;return part
&#9;end
&#9;
&#9;function this:ResetPointer()
&#9;&#9;mPartPoolPtr = 0
&#9;end
&#9;
&#9;function this:HideRest()
&#9;&#9;for i = mPartPoolPtr+1, #mPartPool do
&#9;&#9;&#9;mPartPool[i].Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:HideAll()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for _, part in pairs(mPartPool) do
&#9;&#9;&#9;part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateBlurEffect(parent, partSet)
&#9;local this = {}
&#9;local mTransparency = 0.5
&#9;local mVelocity = Vector3.new(0, 0, 0)
&#9;local mRiseDir = Vector3.new(0, 1, 0)
&#9;--
&#9;local mPartList = {}
&#9;local mTweenSet = {}
&#9;--
&#9;local tm = tick()
&#9;for part, _ in pairs(partSet) do
&#9;&#9;local dat = {}
&#9;&#9;dat.Part = part
&#9;&#9;dat.NextEmit = tm + math.random()*0.5
&#9;&#9;table.insert(mPartList, dat)
&#9;end
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;function this:SetVelocity(velo)
&#9;&#9;mVelocity = velo
&#9;end
&#9;
&#9;local function emit(part)
&#9;&#9;local dir = (CFrame.new(Vector3.new(), mRiseDir) * CFrame.Angles(0, 0, math.pi*2*math.random()) * CFrame.Angles(2*math.random(), 0, 0)).lookVector
&#9;&#9;local dat = {}
&#9;&#9;dat.CFrame = part.CFrame
&#9;&#9;dat.Direction = dir
&#9;&#9;dat.Emitted = tick()
&#9;&#9;dat.Lifetime = 0.4 + math.random()*0.3
&#9;&#9;dat.SpeedFactor = 1 + (math.random()*2-1)*0.5
&#9;&#9;dat.BaseSize = part.Size
&#9;&#9;dat.Velocity = mVelocity
&#9;&#9;local newPart = part:Clone()
&#9;&#9;dat.Part = newPart
&#9;&#9;newPart.Anchored = true
&#9;&#9;newPart.CanCollide = false
&#9;&#9;newPart.FormFactor = &apos;Custom&apos;
&#9;&#9;newPart.Transparency = mTransparency
&#9;&#9;newPart.BrickColor = BrickColor.new(23)
&#9;&#9;newPart.TopSurface = &apos;Smooth&apos;
&#9;&#9;newPart.BottomSurface = &apos;Smooth&apos;
&#9;&#9;newPart.RightSurface = &apos;Smooth&apos;
&#9;&#9;newPart.LeftSurface = &apos;Smooth&apos;
&#9;&#9;newPart:BreakJoints()
&#9;&#9;mTweenSet[dat] = true
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;-- Update rise dir&#9;
&#9;&#9;local desiredRise = (Vector3.new(0, 2, 0) - mVelocity).unit
&#9;&#9;if (desiredRise - mRiseDir).magnitude &lt;= 2*dt then
&#9;&#9;&#9;mRiseDir = desiredRise
&#9;&#9;else
&#9;&#9;&#9;mRiseDir = (mRiseDir + (desiredRise - mRiseDir).unit * (2*dt)).unit
&#9;&#9;end&#9;
&#9;&#9;
&#9;&#9;-- Update part list
&#9;&#9;for _, dat in pairs(mPartList) do
&#9;&#9;&#9;if tick() &gt; dat.NextEmit then
&#9;&#9;&#9;&#9;emit(dat.Part)
&#9;&#9;&#9;&#9;dat.NextEmit = tick() + (0.1 + math.random()*0.2)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Update the tween parts
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;local frac = (tick() - dat.Emitted) / dat.Lifetime
&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;mTweenSet[dat] = nil
&#9;&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;dat.Part.Parent = parent
&#9;&#9;&#9;&#9;dat.Part:BreakJoints()
&#9;&#9;&#9;&#9;dat.Part.Size = dat.BaseSize * (1 - 0.3*frac)
&#9;&#9;&#9;&#9;dat.CFrame = dat.CFrame + (frac^1.5*dt*20*dat.SpeedFactor)*dat.Direction + dat.Velocity*dt
&#9;&#9;&#9;&#9;dat.Part.CFrame = dat.CFrame
&#9;&#9;&#9;&#9;dat.Part.Transparency = mTransparency + (1 - mTransparency)*(frac^1.5)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;for dat, _ in pairs(mTweenSet) do
&#9;&#9;&#9;dat.Part:Destroy()
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateSpinEffect(parent)
&#9;local this = {}
&#9;
&#9;local mTransparency = 0.5
&#9;local mCFrame = CFrame.new()
&#9;
&#9;local mRingSet = {}
&#9;local mRingCount = 0
&#9;local mNextRingAt = tick() + 0.5
&#9;local mDesiredRingCount = 8
&#9;
&#9;function this:SetTransparency(trans)
&#9;&#9;mTransparency = trans
&#9;end
&#9;
&#9;function this:SetCFrame(cf)
&#9;&#9;mCFrame = CFrame.new(cf.p)
&#9;end
&#9;
&#9;function this:AddRing()
&#9;&#9;local ring = PartList[math.random(1, #PartList)] 
&#9;&#9;mRingCount = mRingCount + 1
&#9;&#9;--
&#9;&#9;local dat = {}
&#9;&#9;dat.Started = tick()
&#9;&#9;dat.Created = dat.Started
&#9;&#9;dat.Mode = &apos;In&apos;
&#9;&#9;dat.PartRotOffset = (ring.CFrame - ring.CFrame.p)
&#9;&#9;dat.PartMoveOffset = ring.CFrame.p
&#9;&#9;--
&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;part.Anchored = true
&#9;&#9;part.CanCollide = false
&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;mesh.TextureId = &apos;rbxassetid://168892465&apos;
&#9;&#9;mesh.MeshId = ring.Mesh
&#9;&#9;mesh.VertexColor = Vector3.new(0, 0.5, 1)
&#9;&#9;--
&#9;&#9;dat.Part = part
&#9;&#9;dat.Mesh = mesh
&#9;&#9;dat.VerticalOffset = 4*(math.random()*2-1)
&#9;&#9;dat.Radius = 2 + 5*math.sqrt(1 - math.abs(dat.VerticalOffset/4))
&#9;&#9;dat.Theta = (math.random()*math.pi*2)
&#9;&#9;dat.TurnDirection = (math.random(0,1)*2-1)
&#9;&#9;dat.TurnSpeed = 3 + (math.random()*2-1)*2
&#9;&#9;mRingSet[dat] = true
&#9;end
&#9;
&#9;function this:ShedRing()
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;ring.Mode = &apos;Out&apos;
&#9;&#9;&#9;&#9;ring.Started = tick()
&#9;&#9;&#9;&#9;mRingCount = mRingCount - 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;local now = tick()
&#9;&#9;
&#9;&#9;if now &gt; mNextRingAt then&#9;&#9;&#9;
&#9;&#9;&#9;if mRingCount &gt; mDesiredRingCount then
&#9;&#9;&#9;&#9;this:ShedRing()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;this:AddRing()
&#9;&#9;&#9;end
&#9;&#9;&#9;mNextRingAt = now + (0.1 + math.random()*(0.3 * (mRingCount / mDesiredRingCount)))
&#9;&#9;end
&#9;&#9;
&#9;&#9;for ring, _ in pairs(mRingSet) do
&#9;&#9;&#9;local frac = (now - ring.Started) / 2
&#9;&#9;&#9;local radius = nil
&#9;&#9;&#9;local trans = nil
&#9;&#9;&#9;if ring.Mode == &apos;In&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;ring.Mode = &apos;Norm&apos;
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local turnFactor = 0.2 + 0.8*(0.5+0.5*math.cos(frac*math.pi))^2
&#9;&#9;&#9;&#9;&#9;local turnSpeed = ring.TurnSpeed + turnFactor*10
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*turnSpeed)
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + turnFactor*5
&#9;&#9;&#9;&#9;&#9;trans = frac
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif ring.Mode == &apos;Out&apos; then
&#9;&#9;&#9;&#9;if frac &gt; 1 then
&#9;&#9;&#9;&#9;&#9;mRingSet[ring] = nil
&#9;&#9;&#9;&#9;&#9;ring.Part:Destroy()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;radius = ring.Radius + 5*(frac^2)
&#9;&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)
&#9;&#9;&#9;&#9;&#9;trans = frac^2
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if ring.Mode == &apos;Norm&apos; then
&#9;&#9;&#9;&#9;radius = ring.Radius
&#9;&#9;&#9;&#9;trans = 1
&#9;&#9;&#9;&#9;ring.Theta = ring.Theta + dt*(ring.TurnDirection*ring.TurnSpeed)&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;--
&#9;&#9;&#9;if mRingSet[ring] then
&#9;&#9;&#9;&#9;local sz = radius / 4
&#9;&#9;&#9;&#9;ring.Mesh.Scale = Vector3.new(sz, 1, sz)
&#9;&#9;&#9;&#9;ring.Part.Parent = parent
&#9;&#9;&#9;&#9;ring.Part.CFrame = (mCFrame * CFrame.new(0, ring.VerticalOffset, 0) * CFrame.Angles(0, ring.Theta, 0) * CFrame.new(ring.PartMoveOffset*sz)) * ring.PartRotOffset
&#9;&#9;&#9;&#9;ring.Part.Transparency = 1 - (1-mTransparency)*(1-trans)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;return this
end

local function CreateLightningEffect(parent)
&#9;local this = {}
&#9;
&#9;local mPartPool = CreatePartPool()
&#9;local mActive = false
&#9;local mActivatedAt = 0
&#9;local mFrom = Vector3.new()
&#9;local mTo = Vector3.new()
&#9;local mLightningPath = {{P = mFrom; T = tick(); Expiry = 0}}
&#9;local mLightningPart = Instance.new(&apos;Part&apos;)
&#9;mLightningPart.Anchored = true
&#9;mLightningPart.CanCollide = false
&#9;mLightningPart.FormFactor = &apos;Custom&apos;
&#9;mLightningPart.Size = Vector3.new()
&#9;mLightningPart.Transparency = 1
&#9;local fire = Instance.new(&apos;Fire&apos;, mLightningPart)
&#9;fire.Heat = 20
&#9;fire.Color = Color3.new(10/255, 149/255, 255/255)
&#9;fire.SecondaryColor = Color3.new(0, 0, 0)
&#9;fire.Size = 5
&#9;fire:Clone().Parent = mLightningPart
&#9;local light = Instance.new(&apos;PointLight&apos;, mLightningPart)
&#9;light.Brightness = 2
&#9;light.Range = 4
&#9;light.Color = Color3.new(0/255, 153/255, 255/255)
&#9;
&#9;function this:GetLightningPart()
&#9;&#9;return mLightningPart
&#9;end
&#9;
&#9;local function tickPath(dt)
&#9;&#9;local cachedPoints = {}
&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;local i = 1
&#9;&#9;local now = tick()&#9;
&#9;&#9;while true do&#9;
&#9;&#9;&#9;-- Fudge the current point&#9;&#9;
&#9;&#9;&#9;local currentPoint = mLightningPath[i]
&#9;&#9;&#9;currentPoint.P = currentPoint.P + Vector3.new(math.random()*2-1, math.random()*2-1, math.random()*2-1)*(5*dt)
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;-- Are we at the goal?&#9;
&#9;&#9;&#9;-- If we are then clear out the other points
&#9;&#9;&#9;if (currentPoint.P - mTo).magnitude &lt; 0.5 then
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Not at the goal, do we have a next point?
&#9;&#9;&#9;local useNext;
&#9;&#9;&#9;local nextPoint = mLightningPath[i+1]
&#9;&#9;&#9;if nextPoint then
&#9;&#9;&#9;&#9;local toNext = nextPoint.P - currentPoint.P
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Is the next point near the goal?&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.6 then
&#9;&#9;&#9;&#9;&#9;-- Just snap it to the goal
&#9;&#9;&#9;&#9;&#9;nextPoint.P = mTo
&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- 
&#9;&#9;&#9;&#9;&#9;if math.acos(toNext.unit:Dot(toGoal.unit)) &gt; math.pi/2 then
&#9;&#9;&#9;&#9;&#9;&#9;-- The next point is too far out of direction
&#9;&#9;&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;useNext = true
&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;if useNext and (now - currentPoint.T) &gt; currentPoint.Expiry then
&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P - mFrom).magnitude / (mFrom - mTo).magnitude&#9;
&#9;&#9;&#9;&#9;currentPoint.Expiry = math.random()*0.1 + 0.6*fracThere
&#9;&#9;&#9;&#9;currentPoint.T = now
&#9;&#9;&#9;&#9;useNext = false
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- If we can&apos;t use the next then we need to do some work
&#9;&#9;&#9;if not useNext then
&#9;&#9;&#9;&#9;-- Move all the points ahead to the cached list
&#9;&#9;&#9;&#9;for j = i+1, #mLightningPath do
&#9;&#9;&#9;&#9;&#9;table.insert(cachedPoints, mLightningPath[j])
&#9;&#9;&#9;&#9;&#9;mLightningPath[j] = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Create the next point
&#9;&#9;&#9;&#9;local toGoal = mTo - currentPoint.P
&#9;&#9;&#9;&#9;if toGoal.magnitude &lt; 4.5 then
&#9;&#9;&#9;&#9;&#9;-- If we&apos;re close enough to the goal, just snap there
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {P = mTo; T = now; Expiry = math.random()*0.4})
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- Otherwise, perturb the direction
&#9;&#9;&#9;&#9;&#9;local upwards = math.min(1, (now - mActivatedAt) / 0.8)
&#9;&#9;&#9;&#9;&#9;if upwards == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;mActivatedAt = now
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local dir = CFrame.new(Vector3.new(), toGoal) * CFrame.Angles(0.2 + upwards*0.5, 0, 0) * CFrame.Angles(0, 0, math.random()*math.pi*2) * CFrame.Angles(math.random()*math.pi/3, 0, 0)
&#9;&#9;&#9;&#9;&#9;dir = dir.lookVector * (2 + math.random()*1)
&#9;&#9;&#9;&#9;&#9;local fracThere = (currentPoint.P + dir - mFrom).magnitude / (mFrom - mTo).magnitude
&#9;&#9;&#9;&#9;&#9;table.insert(mLightningPath, {
&#9;&#9;&#9;&#9;&#9;&#9;P = currentPoint.P + dir;
&#9;&#9;&#9;&#9;&#9;&#9;T = now;
&#9;&#9;&#9;&#9;&#9;&#9;Expiry = math.random()*0.1 + 0.6*fracThere;
&#9;&#9;&#9;&#9;&#9;})
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Done
&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;if i &gt; 40 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function drawPath()
&#9;&#9;mPartPool:ResetPointer()
&#9;&#9;for i = 1, #mLightningPath - 1 do
&#9;&#9;&#9;local a = mLightningPath[i].P
&#9;&#9;&#9;local b = mLightningPath[i+1].P
&#9;&#9;&#9;--
&#9;&#9;&#9;local frac = i / (#mLightningPath-1)
&#9;&#9;&#9;local w = 0.2 + 0.2*(1 - 2*math.abs(frac - 0.5))
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = mPartPool:Allocate()
&#9;&#9;&#9;part.Size = Vector3.new(w, w, (a-b).magnitude)
&#9;&#9;&#9;part.CFrame = CFrame.new(0.5*(a+b), b)
&#9;&#9;&#9;part.Parent = parent
&#9;&#9;&#9;part.Transparency = 1
&#9;&#9;end
&#9;&#9;mPartPool:HideRest()
&#9;&#9;mLightningPart.CFrame = CFrame.new(mTo)
&#9;&#9;mLightningPart.Parent = parent
&#9;end
&#9;
&#9;function this:Set(from, to)
&#9;&#9;mFrom = from
&#9;&#9;mTo = to
&#9;end
&#9;
&#9;function this:SetActive(state)
&#9;&#9;if mActive == state then return end
&#9;&#9;mActive = state
&#9;&#9;if mActive then
&#9;&#9;&#9;mActivatedAt = tick()
&#9;&#9;&#9;mLightningPath[1].P = mFrom
&#9;&#9;&#9;for i = 2, #mLightningPath do
&#9;&#9;&#9;&#9;mLightningPath[i] = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;mPartPool:HideAll()
&#9;&#9;&#9;mLightningPart.Parent = nil
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Update(dt)
&#9;&#9;if mActive then
&#9;&#9;&#9;tickPath(dt)
&#9;&#9;&#9;drawPath()
&#9;&#9;end
&#9;end
&#9;
&#9;function this:Destroy()
&#9;&#9;mPartPool:Destroy()
&#9;end
&#9;
&#9;return this
end

local BREAKOFF_TIME = 1
local FLOAT_FINISH_TIME = 3
local FLOAT_HEIGHT = 10
--
local RISE_VELOCITY = FLOAT_FINISH_TIME / FLOAT_HEIGHT

local function TransformationSequence(character)
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;local dir = torso.CFrame.lookVector
&#9;local transformBase = CFrame.new(torso.Position, torso.Position + Vector3.new(dir.X, 0, dir.Z))

&#9;-- Gather the parts to do the tween on
&#9;local partsToTween = {}
&#9;local function gatherParts(object)
&#9;&#9;for _, ch in pairs(object:GetChildren()) do
&#9;&#9;&#9;if ch:IsA(&apos;BasePart&apos;) then
&#9;&#9;&#9;&#9;local tweenPart = {
&#9;&#9;&#9;&#9;&#9;Part = ch;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;table.insert(partsToTween, tweenPart)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;gatherParts(ch)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;gatherParts(character)
&#9;
&#9;-- The effect model
&#9;local effectModel = CreateEffectModel(character)
&#9;
&#9;-- Duplicate the parts we want normally, but want to make fly away
&#9;local flyAwayParts = DuplicateCharacterInto(character, effectModel)
&#9;
&#9;-- Put the body parts into a set
&#9;local flyAwayPartSet = {}

&#9;-- Decide what to do with each of the parts
&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;if flyAwayParts[dat.Part.Name] then
&#9;&#9;&#9;flyAwayPartSet[dat.Part] = true
&#9;&#9;&#9;dat.Mode = &apos;BreakAway&apos;
&#9;&#9;&#9;dat.BreakAwayPart = flyAwayParts[dat.Part.Name]
&#9;&#9;else
&#9;&#9;&#9;dat.Mode = &apos;Fade&apos;
&#9;&#9;end
&#9;end
&#9;
&#9;--[[
&#9;-- Anchor and ready the character
&#9;torso.Anchored = true
&#9;humanoid:ChangeState(&apos;Physics&apos;)
&#9;]]
&#9;
&#9;-- Go into the transformation sequence
&#9;local transformStart = tick()
&#9;local transformLast = transformStart
&#9;local transformBase = character.Torso.CFrame * CFrame.new(0, -3, 0)
&#9;transformBase = CFrame.new(transformBase.p, transformBase.p + Vector3.new(transformBase.lookVector.X, 0, transformBase.lookVector.z))
&#9;
&#9;-- Generate some of the effects
&#9;local effectSet = {}

&#9;-- Takeoff ground waves
&#9;do
&#9;&#9;local waves = {}
&#9;&#9;for i = 1, 4 do
&#9;&#9;&#9;local wave = {}
&#9;&#9;&#9;wave.Delay = ((i-1)/4)*0.25 + math.random()*0.3
&#9;&#9;&#9;wave.Size = ((5-i)/4)*15 + math.random()*3
&#9;&#9;&#9;wave.Duration = 0.5 + math.random()*0.2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.CFrame = transformBase * CFrame.new(math.random()*4-2, 0, math.random()*4-2)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Sphere&apos;
&#9;&#9;&#9;wave.Part = part
&#9;&#9;&#9;wave.Mesh = mesh
&#9;&#9;&#9;table.insert(waves, wave)
&#9;&#9;end
&#9;&#9;local function updateWaves(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; wave.Delay + wave.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - wave.Delay) / wave.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local fracIn = 1 - frac^0.25
&#9;&#9;&#9;&#9;&#9;&#9;local fracOut = frac^5
&#9;&#9;&#9;&#9;&#9;&#9;wave.Mesh.Scale = Vector3.new(wave.Size * fracIn, 0.1 + 9*fracOut, wave.Size * fracIn)
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Transparency = 0.3 + 0.7*fracOut
&#9;&#9;&#9;&#9;&#9;&#9;wave.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyWaves()
&#9;&#9;&#9;for _, wave in pairs(waves) do
&#9;&#9;&#9;&#9;wave.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateWaves;
&#9;&#9;&#9;Destroy = destroyWaves;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Takeoff vertical risers
&#9;do
&#9;&#9;local risers = {}
&#9;&#9;for i = 1, 6 do
&#9;&#9;&#9;local riser = {}
&#9;&#9;&#9;riser.Delay = 0.3 + math.random() * 0.4
&#9;&#9;&#9;riser.Duration = 1 + math.random() * 1.5
&#9;&#9;&#9;riser.Offset = CFrame.new(math.random()*4 - 2, 0, math.random()*4 - 2)
&#9;&#9;&#9;riser.Width = 0.3 + math.random() * 0.5
&#9;&#9;&#9;riser.Height = 1 + math.random() * 2
&#9;&#9;&#9;--
&#9;&#9;&#9;local part = Instance.new(&apos;Part&apos;)
&#9;&#9;&#9;part.FormFactor = &apos;Custom&apos;
&#9;&#9;&#9;part.Size = Vector3.new(1, 1, 1)
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;part.BrickColor = BrickColor.new(23)
&#9;&#9;&#9;part.TopSurface = &apos;Smooth&apos;
&#9;&#9;&#9;part.BottomSurface = &apos;Smooth&apos;
&#9;&#9;&#9;--
&#9;&#9;&#9;local mesh = Instance.new(&apos;SpecialMesh&apos;, part)
&#9;&#9;&#9;mesh.MeshType = &apos;Brick&apos;
&#9;&#9;&#9;riser.Part = part
&#9;&#9;&#9;riser.Mesh = mesh
&#9;&#9;&#9;table.insert(risers, riser)
&#9;&#9;end
&#9;&#9;local function updateRisers(elapsed, dt)
&#9;&#9;&#9;local allDone = true
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay then
&#9;&#9;&#9;&#9;&#9;if elapsed &gt; riser.Delay + riser.Duration then
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;&#9;&#9;-- Normal case
&#9;&#9;&#9;&#9;&#9;&#9;local frac = (elapsed - riser.Delay) / riser.Duration
&#9;&#9;&#9;&#9;&#9;&#9;local rampFrac = 1 - math.abs(frac - 0.5)
&#9;&#9;&#9;&#9;&#9;&#9;local widthFrac = rampFrac^2
&#9;&#9;&#9;&#9;&#9;&#9;local heightFrac = rampFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Mesh.Scale = Vector3.new(riser.Width * widthFrac, riser.Height * heightFrac, riser.Width * widthFrac)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Transparency = 0.2 --widthFrac
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.CFrame = transformBase * riser.Offset * CFrame.new(0, -riser.Height/2 + frac^2*(6 + riser.Height), 0) * CFrame.Angles(0, frac*8, 0)
&#9;&#9;&#9;&#9;&#9;&#9;riser.Part.Parent = effectModel
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;allDone = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return allDone
&#9;&#9;end
&#9;&#9;local function destroyRisers()
&#9;&#9;&#9;for _, riser in pairs(risers) do
&#9;&#9;&#9;&#9;riser.Part:Destroy()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;effectSet[{
&#9;&#9;&#9;Update = updateRisers;
&#9;&#9;&#9;Destroy = destroyRisers;
&#9;&#9;}] = true
&#9;end
&#9;
&#9;-- Main effect
&#9;local blurEffect = CreateBlurEffect(effectModel, flyAwayPartSet)
&#9;
&#9;-- The ring effect
&#9;local ringEffect = CreateSpinEffect(effectModel)
&#9;
&#9;-- Main transformation sequence
&#9;while true do
&#9;&#9;-- How much time has elapsed
&#9;&#9;local now = tick()
&#9;&#9;local dt = now - transformLast
&#9;&#9;local elapsed = now - transformStart
&#9;&#9;transformLast = now
&#9;&#9;
&#9;&#9;-- Run any effects
&#9;&#9;for effect, _ in pairs(effectSet) do
&#9;&#9;&#9;if effect.Update(elapsed, dt) then
&#9;&#9;&#9;&#9;effect.Destroy()
&#9;&#9;&#9;&#9;effectSet[effect] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Main timer
&#9;&#9;local frac = math.min(1, elapsed / FLOAT_FINISH_TIME)
&#9;&#9;local breakFrac = math.max(0, math.min(1, (elapsed - BREAKOFF_TIME) / (FLOAT_FINISH_TIME - BREAKOFF_TIME)))
&#9;&#9;local moveFrac = frac^1.2
&#9;&#9;
&#9;&#9;-- Float up the torso (already done by the server or the other client
&#9;&#9;--[[
&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;torso.Anchored = false
&#9;&#9;&#9;torso.CFrame = transformBase * CFrame.new(0, 3 + moveFrac * FLOAT_HEIGHT, 0)&#9;
&#9;&#9;&#9;torso.Anchored = true
&#9;&#9;end
&#9;&#9;--]]
&#9;&#9;
&#9;&#9;-- Tween part positions + transparency
&#9;&#9;for _, dat in pairs(partsToTween) do
&#9;&#9;&#9;if dat.Mode == &apos;Fade&apos; then
&#9;&#9;&#9;&#9;-- Only fade parts on under filtering
&#9;&#9;&#9;&#9;if Workspace.FilteringEnabled then
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = frac
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif dat.Mode == &apos;BreakAway&apos; then
&#9;&#9;&#9;&#9;if dat.Part.Name == &apos;Head&apos; then
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 0.99
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.Part.Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if elapsed &gt; BREAKOFF_TIME then
&#9;&#9;&#9;&#9;&#9;if not dat.Broken then
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;&#9;&#9;for _, ch in pairs(dat.Part:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if ch:IsA(&apos;Decal&apos;) then ch:Destroy() end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakVelocity = Vector3.new(math.random()-0.5, 1, math.random()-0.5).unit * 4*(1+math.random())
&#9;&#9;&#9;&#9;&#9;&#9;dat.BreakRotVelocity = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5)*5
&#9;&#9;&#9;&#9;&#9;&#9;dat.Broken = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local rvelo = dat.BreakRotVelocity*dt
&#9;&#9;&#9;&#9;&#9;dat.BreakCFrame = (dat.BreakCFrame + dat.BreakVelocity*dt) * CFrame.Angles(rvelo.X, rvelo.Y, rvelo.Z)
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.BreakCFrame
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.Transparency = (frac &lt; 0.5) and 0 or ((frac-0.5)/0.5)^2
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dat.BreakAwayPart.CFrame = dat.Part.CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;assert(false, &quot;unreachable&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Fade in blur effect
&#9;&#9;blurEffect:SetTransparency(1 - frac*0.7)
&#9;&#9;blurEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Fade in ring effect
&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;ringEffect:SetTransparency(1 - breakFrac*0.7)
&#9;&#9;ringEffect:Update(dt)
&#9;&#9;
&#9;&#9;-- Exit
&#9;&#9;if elapsed &gt; FLOAT_FINISH_TIME + 0.5 then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;
&#9;&#9;RunService.RenderStepped:wait()
&#9;end
&#9;
&#9;for _, part in pairs(flyAwayParts) do
&#9;&#9;part:Destroy()
&#9;end
&#9;for _, obj in pairs(effectModel:GetChildren()) do
&#9;&#9;if obj:IsA(&apos;Clothing&apos;) then
&#9;&#9;&#9;obj:Destroy()
&#9;&#9;end
&#9;end
&#9;blurEffect:SetTransparency(0.3)
&#9;blurEffect:Update(0)
&#9;ringEffect:SetTransparency(0.3)
&#9;ringEffect:Update(0)
&#9;
&#9;return effectModel, blurEffect, ringEffect
end

function RunController(character, effectModel, blurEffect, ringEffect)
&#9;-- Already dead
&#9;if not (character.Parent and character:FindFirstChild(&apos;Humanoid&apos;) and character.Humanoid.Health &gt; 0) then
&#9;&#9;effectModel:Destroy()
&#9;&#9;return nil
&#9;end&#9;
&#9;--
&#9;local torso = character:WaitForChild(&apos;HumanoidRootPart&apos;)
&#9;local humanoid = character:WaitForChild(&apos;Humanoid&apos;)
&#9;--
&#9;local UpdateMove;
&#9;if Workspace.FilteringEnabled then
&#9;&#9;UpdateMove = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;UpdateMove&apos;)
&#9;&#9;local val = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;):WaitForChild(&apos;ControlReady&apos;)
&#9;&#9;while not val.Value do val.Changed:wait() end
&#9;end
&#9;--
&#9;local bin = Character:WaitForChild(&apos;RunGlobal_SSTool&apos;)
&#9;local IsShooting = bin:WaitForChild(&apos;IsShooting&apos;)
&#9;local ShootFrom = bin:WaitForChild(&apos;ShootFrom&apos;)
&#9;local ShootTo = bin:WaitForChild(&apos;ShootTo&apos;)
&#9;local HumanoidToDamage = bin:WaitForChild(&apos;HumanoidToDamage&apos;)
&#9;--
&#9;local lightningEffect = CreateLightningEffect(effectModel)
&#9;lightningEffect:SetActive(true)
&#9;local lightningActive = false
&#9;local lightningActiveSince = 0
&#9;local lightningRunId = 0
&#9;--
&#9;local fireSound = Instance.new(&apos;Sound&apos;, lightningEffect:GetLightningPart())
&#9;fireSound.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound.Pitch = 1.5
&#9;fireSound.Volume = 0.25
&#9;fireSound.Looped = true
&#9;local fireSound2 = Instance.new(&apos;Sound&apos;, lightningEffect:GetLightningPart())
&#9;fireSound2.SoundId = &apos;rbxassetid://69446845&apos;
&#9;fireSound2.Pitch = 1.5
&#9;fireSound2.Volume = 0.25
&#9;fireSound2.Looped = true
&#9;--
&#9;Spawn(function()
&#9;&#9;local lastTime = tick()
&#9;&#9;while humanoid.Health &gt; 0 and character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;
&#9;&#9;&#9;-- Movement (done by server or owning client)

&#9;&#9;&#9;-- Attack effect
&#9;&#9;&#9;if not IsShooting.Value then
&#9;&#9;&#9;&#9;if lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActive = false
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = 1.5
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;&#9;fireSound2:Stop()
&#9;&#9;&#9;&#9;&#9;fireSound:Stop()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;lightningEffect:SetActive(false)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if not lightningActive then
&#9;&#9;&#9;&#9;&#9;lightningActiveSince = now
&#9;&#9;&#9;&#9;&#9;lightningActive = true
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = 1.5 - 0.7
&#9;&#9;&#9;&#9;&#9;fireSound:Play()
&#9;&#9;&#9;&#9;&#9;lightningRunId = lightningRunId + 1
&#9;&#9;&#9;&#9;&#9;local thisRunId = lightningRunId
&#9;&#9;&#9;&#9;&#9;Delay(0.2, function()
&#9;&#9;&#9;&#9;&#9;&#9;if lightningRunId == thisRunId then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;fireSound2:Play()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local frac = math.min(1, (now - lightningActiveSince) / 0.3)
&#9;&#9;&#9;&#9;&#9;local modPitch = 1.5 - 0.7*(1-frac)
&#9;&#9;&#9;&#9;&#9;fireSound.Pitch = modPitch
&#9;&#9;&#9;&#9;&#9;fireSound2.Pitch = modPitch
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;lightningEffect:SetActive(true)
&#9;&#9;&#9;&#9;lightningEffect:Set(ShootFrom.Value, ShootTo.Value)
&#9;&#9;&#9;&#9;lightningEffect:Update(dt)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Character effects
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;blurEffect:SetVelocity(torso.Velocity)
&#9;&#9;&#9;ringEffect:SetCFrame(torso.CFrame)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;--
&#9;&#9;&#9;while _G.Stop do wait() end
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end

&#9;&#9;-- Turn off the lightning if still running
&#9;&#9;lightningEffect:SetActive(false)
&#9;&#9;fireSound:Stop()&#9;&#9;
&#9;&#9;
&#9;&#9;-- Fade out the other effects
&#9;&#9;local lastTime = tick()
&#9;&#9;local trans = 0.3
&#9;&#9;while character.Parent do
&#9;&#9;&#9;local now = tick()
&#9;&#9;&#9;local dt = (now - lastTime)
&#9;&#9;&#9;lastTime = now
&#9;&#9;&#9;trans = math.min(1, trans + 0.5*dt)
&#9;&#9;&#9;blurEffect:SetTransparency(trans)
&#9;&#9;&#9;ringEffect:SetTransparency(trans)
&#9;&#9;&#9;blurEffect:Update(dt)
&#9;&#9;&#9;ringEffect:Update(dt)
&#9;&#9;&#9;RunService.RenderStepped:wait()
&#9;&#9;end
&#9;&#9;
&#9;&#9;-- Finally Kill the effects and end
&#9;&#9;effectModel:Destroy()
&#9;end)
&#9;--
&#9;local this = {}
&#9;--
&#9;function this:ShootAt()
&#9;&#9;
&#9;end
&#9;--&#9;
&#9;return this
end

local effectModel, blurEffect, ringEffect = TransformationSequence(Character)
local Controller = RunController(Character, effectModel, blurEffect, ringEffect)

</ProtectedString>
				</Properties>
				<Item class="ObjectValue" referent="RBX18">
					<Properties>
						<string name="Name">TargetCharacter</string>
						<Ref name="Value">null</Ref>
					</Properties>
				</Item>
			</Item>
			<Item class="Animation" referent="RBX19">
				<Properties>
					<Content name="AnimationId"><url>rbxassetid://169638954</url></Content>
					<string name="Name">FlyAnimation</string>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>