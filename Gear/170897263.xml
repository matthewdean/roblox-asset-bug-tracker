<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX732AE4A544B143EF96FF084E89E57E9D">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0.349999994</Y>
				<Z>0.75</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>-0.330350399</R11>
				<R12>0.943858445</R12>
				<R20>0</R20>
				<R21>-0.943858325</R21>
				<R22>-0.330350429</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">Mad Murderer Knife</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=165710403</url></Content>
			<string name="ToolTip">Mad Murderer Knife</string>
		</Properties>
		<Item class="Part" referent="RBX07CCB4B4D1E941C5AD50162504B0777C">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">199</int>
				<CoordinateFrame name="CFrame">
					<X>-10.6000042</X>
					<Y>103.500023</Y>
					<Z>55.4749985</Z>
					<R00>-0.899517119</R00>
					<R01>-0.404009193</R01>
					<R02>-0.166266292</R02>
					<R10>0.0580105893</R10>
					<R11>0.266750485</R11>
					<R12>-0.962017655</R12>
					<R20>0.433016002</R20>
					<R21>-0.87499702</R21>
					<R22>-0.216509879</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0.400000006</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.400000036</X>
					<Y>1.12</Y>
					<Z>2.59999919</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBXE73FD5FF67394210B2FA4A4692056881">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=165710339</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.5</X>
						<Y>0.5</Y>
						<Z>0.5</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=165710383</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX24BD24E708C84B6CB35BB29E4C2DA56C">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Swing</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=169285411</url></Content>
					<float name="Volume">0.5</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBXFC87A0641BED4EF7920E81DA5B3D79AF">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GunScript</string>
				<ProtectedString name="Source">--Murderer knife action script, original code from The Mad Murderer, by loleris.

wait(0.5)
local camera = game.Workspace.CurrentCamera
local player = game.Players.LocalPlayer
local character = player.Character
local humanoid = character.Humanoid
local head = character.Head
local torso = character.Torso
local tool = script.Parent
local pl_mouse = player:GetMouse()
local handle = script.Parent:WaitForChild(&quot;Handle&quot;);

local rs = game:GetService(&quot;RunService&quot;)

local stab_damage = 110
local walkspeeds = {16, 19}

Settings = {
&#9;Equip_time = 0.4,
&#9;Idle_speed = 5,
&#9;Attack_speed = 0.65,
}

local assetlink = &quot;http://www.roblox.com/asset/?id=&quot;
local hit_sounds = {&quot;169310515&quot;, &quot;169310520&quot;, &quot;169310529&quot;, &quot;169310534&quot;}
local death_sounds = {&quot;169310273&quot;, &quot;169310284&quot;, &quot;169310295&quot;}
function HIT_HANDLE(hit, dmg, pos)
&#9;if hit == nil then return end
&#9;local h = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;if h == nil then
&#9;&#9;h = hit.Parent.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;end
&#9;if h == nil then return end
&#9;if h.Health &lt;= 0 then return end
&#9;
&#9;local head = h.Parent:findFirstChild(&quot;Head&quot;)
&#9;if head == nil then return end
&#9;
&#9;local sound_part = Instance.new(&quot;Part&quot;)
&#9;sound_part.formFactor = &quot;Custom&quot;
&#9;sound_part.Size = Vector3.new(0.2, 0.2, 0.2)
&#9;sound_part.Transparency = 1
&#9;sound_part.CanCollide = false
&#9;sound_part.Anchored = true
&#9;sound_part.CFrame = head.CFrame
&#9;local cls = script.clean:clone()
&#9;cls.Disabled = false
&#9;cls.Parent = sound_part
&#9;sound_part.Parent = Workspace
&#9;local s_hit = Instance.new(&quot;Sound&quot;)
&#9;s_hit.Volume = 1
&#9;s_hit.SoundId = assetlink .. hit_sounds[math.random(1, #hit_sounds)]
&#9;s_hit.Parent = sound_part
&#9;local s_die = Instance.new(&quot;Sound&quot;)
&#9;s_die.Volume = 1
&#9;s_die.SoundId = assetlink .. death_sounds[math.random(1, #death_sounds)]
&#9;s_die.Parent = sound_part
&#9;
&#9;s_hit:play()
&#9;
&#9;local c_tag = Instance.new(&quot;ObjectValue&quot;)
&#9;c_tag.Name = &quot;creator&quot;
&#9;c_tag.Value = player
&#9;c_tag.Parent = h
&#9;h:TakeDamage(stab_damage)
&#9;
&#9;if h.Health &lt;= dmg then
&#9;&#9;s_die:play()
&#9;end
end

function GENERATE_IGNORELIST()
&#9;local result = {character, camera}
&#9;local plr = game.Players:GetPlayers()
&#9;for i = 1, #plr do
&#9;&#9;if plr[i] ~= player then
&#9;&#9;&#9;local char = plr[i].Character
&#9;&#9;&#9;if char ~= nil then
&#9;&#9;&#9;&#9;local ch = char:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #ch do
&#9;&#9;&#9;&#9;&#9;if ch[i]:IsA(&quot;Hat&quot;) or ch[i]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;result[#result + 1] = ch[i]
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return result
end

function RayCast(pos1, pos2, dist, ign)
&#9;local ray = Ray.new(
&#9;&#9;pos1,
&#9;&#9;(pos2 - pos1).unit * math.abs(dist)
&#9;) 
&#9;local hit, hpos = Workspace:FindPartOnRayWithIgnoreList(ray, ign, false)
&#9;return hit, hpos
end

local larm = character:findFirstChild(&quot;Left Arm&quot;)
local rarm = character:findFirstChild(&quot;Right Arm&quot;)
function Slash(del)
&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;local hits = {}
&#9;&#9;
&#9;&#9;local start = tick()
&#9;&#9;local actv = true
&#9;&#9;
&#9;&#9;local function ishitted(obj)
&#9;&#9;&#9;for i = 1, #hits do
&#9;&#9;&#9;&#9;if obj:IsDescendantOf(hits[i]) then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function hitp(hit)
&#9;&#9;&#9;if ishitted(hit) then return end
&#9;&#9;&#9;local h = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;if h == nil then
&#9;&#9;&#9;&#9;h = hit.Parent.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;if h == nil then return end
&#9;&#9;&#9;hits[#hits + 1] = h.Parent
&#9;&#9;&#9;HIT_HANDLE(hit, stab_damage)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local con = {
&#9;&#9;&#9;larm.Touched:connect(hitp),
&#9;&#9;&#9;rarm.Touched:connect(hitp),
&#9;&#9;}
&#9;&#9;
&#9;&#9;while tick() - start &lt;= Settings.Attack_speed do wait() end
&#9;&#9;actv = false
&#9;&#9;con[1]:disconnect()
&#9;&#9;con[2]:disconnect()
&#9;end))
end

local dg_sounds = {
&#9;equip = {
&#9;&#9;&quot;169310310&quot;
&#9;},
&#9;hit = {
&#9;&#9;&quot;169310515&quot;,
&#9;&#9;&quot;169310520&quot;,
&#9;&#9;&quot;169310529&quot;,
&#9;&#9;&quot;169310534&quot;
&#9;},
&#9;swing = {
&#9;&#9;&quot;169310429&quot;,
&#9;&#9;&quot;169310436&quot;,
&#9;&#9;&quot;169310447&quot;,
&#9;&#9;&quot;169310455&quot;
&#9;}
}

local dg_soundobj = {}
for k, v in pairs(dg_sounds) do
&#9;dg_soundobj[k] = {}
&#9;for i = 1, #v do
&#9;&#9;local ns = Instance.new(&quot;Sound&quot;)
&#9;&#9;ns.SoundId = assetlink .. v[i]
&#9;&#9;ns.Volume = 1
&#9;&#9;dg_soundobj[k][#dg_soundobj[k] + 1] = ns
&#9;end
end

function LoadSounds()
&#9;for __, v in pairs(dg_soundobj) do
&#9;&#9;for i = 1, #v do
&#9;&#9;&#9;v[i].Parent = head
&#9;&#9;end
&#9;end
end
function RemoveSounds()
&#9;for __, v in pairs(dg_soundobj) do
&#9;&#9;for i = 1, #v do
&#9;&#9;&#9;v[i].Parent = nil
&#9;&#9;end
&#9;end
end
function PlaySound(nm, dl)
&#9;if dl == nil then
&#9;&#9;dg_soundobj[nm][math.random(1, #dg_soundobj[nm])]:play()
&#9;else
&#9;&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;&#9;wait(dl)
&#9;&#9;&#9;dg_soundobj[nm][math.random(1, #dg_soundobj[nm])]:play()
&#9;&#9;end))
&#9;end
end

_G.MurderKnife_AnimType = &quot;Default&quot;
_G.MurderKnife_AnimState = 0

function Animate(tp, st)
&#9;_G.MurderKnife_AnimType = tp
&#9;_G.MurderKnife_AnimState = st
end

tool.Equipped:connect(function(mouse) --Default, Idle1, Idle2, Attack1, Attack2
&#9;humanoid.WalkSpeed = walkspeeds[2]
&#9;handle.Transparency = 1;
&#9;mouse.Icon = assetlink .. &quot;54019936&quot;
&#9;Animate(&quot;Equip&quot;, 0)
&#9;LoadSounds()
&#9;PlaySound(&quot;equip&quot;, 0.1)
&#9;
&#9;local anim_equip = 1
&#9;local last_action = tick()
&#9;local idle_rand = math.random(4, 7)
&#9;local idle_perform = 0
&#9;local idle_type = 1
&#9;
&#9;local attack_perform = 0
&#9;local attack_type = 1
&#9;
&#9;local running = true
&#9;local last_c = tick()
&#9;
&#9;local click_start = tick()
&#9;mouse.Button1Down:connect(function()
&#9;&#9;if not running or anim_equip &gt; 0 then return end
&#9;&#9;if tick() - attack_perform &lt;= Settings.Attack_speed then return end
&#9;&#9;attack_perform = tick()
&#9;&#9;last_action = tick()
&#9;&#9;attack_type = math.random(1, 3)
&#9;&#9;idle_perform = 0
&#9;&#9;PlaySound(&quot;swing&quot;, 0.15)
&#9;&#9;Slash(0.17)
&#9;end)
&#9;
&#9;local conn = rs.RenderStepped:connect(function()
&#9;&#9;if not running then return end
&#9;&#9;local delta = tick() - last_c
&#9;&#9;last_c = tick()
&#9;&#9;
&#9;&#9;if anim_equip &gt; 0 then
&#9;&#9;&#9;anim_equip = math.max(0, anim_equip - (delta / Settings.Equip_time))
&#9;&#9;&#9;Animate(&quot;Equip&quot;, 1 - anim_equip)
&#9;&#9;elseif tick() - attack_perform &lt;= Settings.Attack_speed then
&#9;&#9;&#9;Animate(&quot;Attack&quot; .. attack_type, (tick() - attack_perform) / Settings.Attack_speed)
&#9;&#9;&#9;idle_perform = 0
&#9;&#9;elseif tick() - idle_perform &lt;= Settings.Idle_speed then
&#9;&#9;&#9;Animate(&quot;Idle&quot; .. idle_type, (tick() - idle_perform) / Settings.Idle_speed)
&#9;&#9;else
&#9;&#9;&#9;Animate(&quot;Default&quot;, 0)
&#9;&#9;end
&#9;&#9;
&#9;&#9;if tick() - last_action &gt;= idle_rand then
&#9;&#9;&#9;idle_rand = math.random(12, 20)
&#9;&#9;&#9;last_action = tick()
&#9;&#9;&#9;idle_perform = tick()
&#9;&#9;&#9;idle_type = math.random(1, 2)
&#9;&#9;end
&#9;&#9;
&#9;end)
&#9;tool.Unequipped:connect(function() running = false conn:disconnect() end)
end)
tool.Unequipped:connect(function()
&#9;RemoveSounds()
&#9;humanoid.WalkSpeed = walkspeeds[1]
&#9;handle.Transparency = 0;
end)
</ProtectedString>
			</Properties>
			<Item class="IntValue" referent="RBX1A85FCC5332945BB8FFBE37FE7CCAD4B">
				<Properties>
					<string name="Name">Clip</string>
					<int name="Value">18</int>
				</Properties>
			</Item>
			<Item class="IntValue" referent="RBX7B8744DC933E498DBF49C272C8E24A9F">
				<Properties>
					<string name="Name">Ammo</string>
					<int name="Value">50</int>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX3C10454F54F74CB29E314CE8BC91982A">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">dmg_script</string>
					<ProtectedString name="Source">script.Parent:TakeDamage(script.amm.Value)</ProtectedString>
				</Properties>
				<Item class="NumberValue" referent="RBX22AC6206D1334B80A36E1115E1071DFB">
					<Properties>
						<string name="Name">amm</string>
						<double name="Value">0</double>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBXDDFC7F7341764A75A43D39BDFAEB6A45">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">clean</string>
					<ProtectedString name="Source">wait(6)
script.Parent:remove()</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXDA1F1FBF112543B88F785CB221FEAF28">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">k_clean</string>
					<ProtectedString name="Source">wait(10)
local start_t = script.Parent.Transparency
local st = 0
while st ~= 1 do
&#9;st = math.min(1, st + wait())
&#9;script.Parent.Transparency = start_t + ((1 - start_t) * st)
end
script.Parent:remove()</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBXF6517AE26F4848808A3B835C8CB8F197">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GunAnimation</string>
				<ProtectedString name="Source">--Murderer knife animation module, original code from The Mad Murderer, by loleris.

wait(0.5)
local tool = script.Parent
local player = game.Players.LocalPlayer
local character = player.Character
local humanoid = character:findFirstChild(&quot;Humanoid&quot;)
local camera = Workspace.CurrentCamera
local mouse = player:GetMouse()
local conn_type = &quot;Snap&quot;
local anim_head = false
weapon_properties = {
&#9;mesh_id = &quot;http://www.roblox.com/asset/?id=165710339&quot;,
&#9;texture_id = &quot;http://www.roblox.com/asset/?id=165710383&quot;,
&#9;scale = Vector3.new(0.5, 0.5, 0.5),
&#9;transparency = 0,
&#9;reflectance = 0,
&#9;brick_color = BrickColor.new(&quot;Really black&quot;),
}
--How did I make all of this? Magic. Didn&apos;t even need an animation editor :)
Animations = {
&#9;Default = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
&#9;},
&#9;Equip = {
&#9;&#9;{{}, 0, CFrame.new(0, 0, 0) * CFrame.Angles(-1.571, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(-1.571, 0, 0), CFrame.new(0, -1.3, -0.5) * CFrame.Angles(-2.618, 0, 0)},
&#9;&#9;{{0.8, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.524, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;},
&#9;Idle1 = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.3, 2}, 0, CFrame.new(0.8, -0.301, 0.2) * CFrame.Angles(-0.35, 0, 0.872), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.523, 1.221, -0.699), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 1.221, 0)},
&#9;&#9;{{0.55, 2}, 0, CFrame.new(0.2, -0.5, 0.2) * CFrame.Angles(-0.14, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0, 1.221, -0.175), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.746, 1.221, 0.174)},
&#9;&#9;{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;},
&#9;Idle2 = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.3, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.524, 0, 0.872), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, -0.175, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0.523, 0)},
&#9;&#9;{{0.3, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(0.349, 0, 0.523), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.174, 0.698, -0.524), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, -1.222, 0)},
&#9;&#9;{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(0.61, 0, 0.349), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.139, 0.663, -0.489), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, -1.222, 0)},
&#9;&#9;{{0.2, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
&#9;},
&#9;Attack1 = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.048, 0, 0.349), CFrame.new(-0.201, 0, 0) * CFrame.Angles(0.872, 0.349, 0.087), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.15, 2}, 0, CFrame.new(0.4, -0.101, 0.1) * CFrame.Angles(-1.571, 0, -0.35), CFrame.new(-0.301, -0.301, 0.1) * CFrame.Angles(-1.048, -0.175, -0.524), CFrame.new(0, -1.201, -0.801) * CFrame.Angles(-2.095, 0, 0)},
&#9;&#9;{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
&#9;},
&#9;Attack2 = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.699, 0, 0.872), CFrame.new(-0.401, 0.3, 0.1) * CFrame.Angles(1.919, 2.443, -1.222), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.048, 0, -0.524), CFrame.new(-0.5, -0.201, -0.101) * CFrame.Angles(0.523, 1.396, -0.873), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)}
&#9;},
&#9;Attack3 = {
&#9;&#9;{{}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)},
&#9;&#9;{{0.25, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.397, 0, 0.174), CFrame.new(-0.401, -0.201, 0) * CFrame.Angles(1.396, 0.698, -1.571), CFrame.new(0, -1.3, -0.401) * CFrame.Angles(-2.444, 0, 0)},
&#9;&#9;{{0.15, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-1.397, 0, 0.174), CFrame.new(-0.401, 0.1, 0) * CFrame.Angles(0.349, 2.094, -0.524), CFrame.new(0, -1.3, 0.1) * CFrame.Angles(-3.84, 0, 0)},
&#9;&#9;{{0.6, 2}, 0, CFrame.new(0.4, -0.201, 0.2) * CFrame.Angles(-0.873, 0, 0.698), CFrame.new(-0.201, 0, 0) * CFrame.Angles(-0.175, 0.349, -0.262), CFrame.new(0, -0.95, -0.801) * CFrame.Angles(-1.571, 0, 0)} --Psst. Create a dummy, try setting position and angles of limbs and the weapon, save CFrame data to code. Easy? Yes. When making a single knife tool, it was all you needed.
&#9;}
}
function CFrameTrans(GetCFrame1, GetCFrame2, GetNumber)
&#9;local Diff2 = GetCFrame2.p - GetCFrame1.p
&#9;GetCFrame1_s = GetCFrame1 - GetCFrame1.p
&#9;GetCFrame2 = GetCFrame2 - GetCFrame2.p
&#9;local Diff = GetCFrame1_s:inverse() * GetCFrame2
&#9;local x1, y1, z1 = Diff:toEulerAnglesXYZ()
&#9;return (GetCFrame1 + (Diff2 * GetNumber)) * CFrame.Angles(x1 * GetNumber, y1 * GetNumber, z1 * GetNumber)
end

function TransEff(x, type)
&#9;if type == 1 then
&#9;&#9;return x
&#9;elseif type == 2 then
&#9;&#9;return x*x*(3 - 2*x)
&#9;elseif type == 3 then
&#9;&#9;return math.sin(math.rad(x * 90))
&#9;elseif type == 4 then
&#9;&#9;return 1 - math.sin(math.rad((1 - x) * 90))
&#9;end
end

function num_trans(n1, n2, x)
&#9;return n1 + ((n2 - n1) * x)
end

function PlayAnimation(anim_name, tm) --return {left, right, wep, trans}
&#9;tm = math.min(1, math.max(0, tm))
&#9;local animd = Animations[anim_name]
&#9;if #animd == 1 then
&#9;&#9;return {animd[1][3], animd[1][4], animd[1][5], animd[1][2]}
&#9;else
&#9;&#9;local trans_from = 1
&#9;&#9;local trans_to = 1
&#9;&#9;local tm_left = tm
&#9;&#9;for i = 2, #animd do
&#9;&#9;&#9;tm_left = tm_left - animd[i][1][1]
&#9;&#9;&#9;if tm_left &lt;= 0 then
&#9;&#9;&#9;&#9;trans_from = i - 1
&#9;&#9;&#9;&#9;trans_to = i
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local trans_amm = TransEff((animd[trans_to][1][1] + tm_left) / animd[trans_to][1][1], animd[trans_to][1][2])
&#9;&#9;return {
&#9;&#9;&#9;CFrameTrans(animd[trans_from][3], animd[trans_to][3], trans_amm),
&#9;&#9;&#9;CFrameTrans(animd[trans_from][4], animd[trans_to][4], trans_amm),
&#9;&#9;&#9;CFrameTrans(animd[trans_from][5], animd[trans_to][5], trans_amm),
&#9;&#9;&#9;num_trans(animd[trans_from][2], animd[trans_to][2], trans_amm)
&#9;&#9;}
&#9;end
end

rot_amplitude_head = 20
rot_amplitude_chest = 15

anim_p = {
&#9;cam_offset = CFrame.new(0.2, -0.37, 0.91) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)),
&#9;aim_amp = 0.5,
&#9;aim_max_change = 4,
&#9;aim_retract = 15,
&#9;aim_max_deg = 20,
}

local weapon_model = Instance.new(&quot;Part&quot;)
weapon_model.CanCollide = false
weapon_model.Name = &quot;WeaponObject&quot;
weapon_model.formFactor = &quot;Custom&quot;
weapon_model.Size = Vector3.new(0.2, 0.2, 0.2)
weapon_model.TopSurface = 0
weapon_model.BottomSurface = 0
weapon_model.BrickColor = weapon_properties.brick_color
weapon_model.Transparency = weapon_properties.transparency
weapon_model.Reflectance = weapon_properties.reflectance
local mesh = Instance.new(&quot;SpecialMesh&quot;, weapon_model)
mesh.Scale = weapon_properties.scale
mesh.MeshId = weapon_properties.mesh_id
mesh.TextureId = weapon_properties.texture_id

torso = character.Torso
head = character.Head

motors = {torso:findFirstChild(&quot;Left Shoulder&quot;), torso:findFirstChild(&quot;Right Shoulder&quot;), torso:findFirstChild(&quot;Neck&quot;)}
welds = {nil, nil, nil}
weapon_parts = {weapon_model:clone(), weapon_model:clone()}
weapon_model = nil

function EndAnimation()
&#9;if motors[1] then
&#9;&#9;motors[1].Part1 = character:findFirstChild(&quot;Left Arm&quot;)
&#9;end
&#9;if motors[2] then
&#9;&#9;motors[2].Part1 = character:findFirstChild(&quot;Right Arm&quot;)
&#9;end
&#9;if motors[3] then
&#9;&#9;motors[3].Part1 = character:findFirstChild(&quot;Head&quot;)
&#9;end
&#9;if welds[1] then
&#9;&#9;welds[1]:remove()
&#9;&#9;welds[1] = nil
&#9;end
&#9;if welds[2] then
&#9;&#9;welds[2]:remove()
&#9;&#9;welds[2] = nil
&#9;end
&#9;if welds[3] then
&#9;&#9;welds[3]:remove()
&#9;&#9;welds[3] = nil
&#9;end
&#9;weapon_parts[1].Parent = nil
&#9;if weapon_model then
&#9;&#9;weapon_model.Parent = nil
&#9;end
&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;local swm = weapon_model
&#9;&#9;wait()
&#9;&#9;swm.Parent = nil
&#9;&#9;wait(0.1)
&#9;&#9;swm.Parent =  nil
&#9;&#9;wait(0.5)
&#9;&#9;swm.Parent =  nil
&#9;end))
end

local anim_model = Instance.new(&quot;Model&quot;)
anim_model.Name = &quot;WeaponAnimation&quot;
weapon_model = anim_model
&#9;
local cam_larm = Instance.new(&quot;Part&quot;)
cam_larm.Parent = anim_model
cam_larm.BrickColor = BrickColor.new(&quot;Really black&quot;)
cam_larm.formFactor = &quot;Custom&quot;
cam_larm.Size = Vector3.new(0.2, 0.2, 0.2)
cam_larm.TopSurface = 0
cam_larm.BottomSurface = 0
cam_larm.Transparency = 0.4
cam_larm.CanCollide = false
local hmesh = Instance.new(&quot;BlockMesh&quot;, cam_larm)
hmesh.Scale = Vector3.new(5, 10, 5)

local cam_rarm = cam_larm:clone()
cam_rarm.Parent = anim_model

function StartAnimation()
&#9;local check = {torso:findFirstChild(&quot;LeftWeld&quot;), torso:findFirstChild(&quot;RightWeld&quot;), torso:findFirstChild(&quot;HeadWeld&quot;)}
&#9;if check[1] then check[1]:remove() end
&#9;if check[2] then check[2]:remove() end
&#9;if check[3] then check[3]:remove() end
&#9;local check2 = {character:findFirstChild(&quot;WeaponObject&quot;), camera:findFirstChild(&quot;WeaponAnimation&quot;)}
&#9;if check2[1] then check2[1].Parent = nil end
&#9;if check2[2] then check2[2].Parent = nil end
&#9;if motors[1] then
&#9;&#9;motors[1].Part1 = nil
&#9;end
&#9;if motors[2] then
&#9;&#9;motors[2].Part1 = nil
&#9;end
&#9;if motors[3] then
&#9;&#9;motors[3].Part1 = nil
&#9;end
&#9;welds = {Instance.new(conn_type), Instance.new(conn_type), Instance.new(conn_type)}
&#9;welds[1].Part0 = torso
&#9;welds[2].Part0 = torso
&#9;welds[3].Part0 = torso
&#9;welds[1].Part1 = character:findFirstChild(&quot;Left Arm&quot;)
&#9;welds[2].Part1 = character:findFirstChild(&quot;Right Arm&quot;)
&#9;welds[3].Part1 = character:findFirstChild(&quot;Head&quot;)
&#9;welds[1].Name = &quot;LeftWeld&quot;
&#9;welds[2].Name = &quot;RightWeld&quot;
&#9;welds[2].Name = &quot;HeadWeld&quot;
&#9;welds[1].C0 = CFrame.new(-1.5, 0, 0)
&#9;welds[2].C0 = CFrame.new(1.5, 0, 0)
&#9;welds[3].C0 = CFrame.new(0, 1.5, 0)
&#9;welds[1].Parent = torso
&#9;welds[2].Parent = torso
&#9;welds[3].Parent = torso
&#9;
&#9;weapon_parts[1].Parent = character
&#9;local wep_weld = Instance.new(conn_type)
&#9;wep_weld.Part0 = character:findFirstChild(&quot;Right Arm&quot;)
&#9;wep_weld.Part1 = weapon_parts[1]
&#9;wep_weld.C0 = CFrame.new()
&#9;wep_weld.Parent = weapon_parts[1]
&#9;
&#9;local weld1 = welds[1]
&#9;local weld2 = welds[2]
&#9;local weld3 = welds[3]
&#9;
&#9;local cam_welds = {Instance.new(conn_type), Instance.new(conn_type), Instance.new(conn_type)}
&#9;cam_welds[1].Part0 = torso
&#9;cam_welds[1].Part1 = cam_larm
&#9;cam_welds[1].Parent = cam_larm
&#9;cam_welds[2].Part0 = torso
&#9;cam_welds[2].Part1 = cam_rarm
&#9;cam_welds[2].Parent = cam_rarm
&#9;cam_welds[3].Part0 = cam_rarm
&#9;cam_welds[3].Part1 = weapon_parts[2]
&#9;cam_welds[3].Parent = weapon_parts[2]
&#9;weapon_parts[2].Parent = anim_model
&#9;
&#9;local move_anim_speed = 3
&#9;local last_p = Vector3.new()
&#9;local move_amm = 0
&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;while weld1.Parent ~= nil do
&#9;&#9;&#9;local delta = wait(1/25)
&#9;&#9;&#9;local cur_p = torso.Position
&#9;&#9;&#9;if (cur_p - last_p).magnitude &gt;= 0.1 then
&#9;&#9;&#9;&#9;move_amm = math.min(1, move_amm + delta * move_anim_speed)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;move_amm = math.max(0, move_amm - delta * move_anim_speed)
&#9;&#9;&#9;end
&#9;&#9;&#9;last_p = cur_p
&#9;&#9;end
&#9;end))
&#9;
&#9;local r_serv = game:GetService(&quot;RunService&quot;)
&#9;
&#9;--EASTER EGG
&#9;function easein(x)
&#9;&#9;return math.sin(math.rad(x * 90))
&#9;end

&#9;local a_horse = (character:findFirstChild(&quot;HorseHead&quot;) ~= nil)
&#9;local horse_displace = {0, 0}
&#9;local horse_cf = CFrame.Angles(0.0001, 0.0001, 0)
&#9;if a_horse then
&#9;&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;&#9;while weld1.Parent ~= nil do
&#9;&#9;&#9;&#9;local rndwait = (math.random(100, 1000) / 1000) * 4
&#9;&#9;&#9;&#9;wait(rndwait)
&#9;&#9;&#9;&#9;local oldd = {horse_displace[1], horse_displace[2]}
&#9;&#9;&#9;&#9;local disp2 = {math.random(-60, 60), math.random(0, 25)}
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local ld = 0
&#9;&#9;&#9;&#9;while ld ~= 1 do
&#9;&#9;&#9;&#9;&#9;local st = tick()
&#9;&#9;&#9;&#9;&#9;r_serv.RenderStepped:wait()
&#9;&#9;&#9;&#9;&#9;ld = math.min(1, ld + ((tick() - st) * 4))
&#9;&#9;&#9;&#9;&#9;local eff = easein(ld)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;local x = oldd[1] - ((oldd[1] - disp2[1]) * eff)
&#9;&#9;&#9;&#9;&#9;local y = oldd[2] - ((oldd[2] - disp2[2]) * eff)
&#9;&#9;&#9;&#9;&#9;horse_displace = {x, y}
&#9;&#9;&#9;&#9;&#9;horse_cf = CFrame.Angles(math.rad(y), math.rad(x) , 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end))
&#9;end
&#9;
&#9;--EASTER EGG
&#9;
&#9;local last_va = 0
&#9;local last_va2 = 0
&#9;local view_velocity = {0, 0}
&#9;
&#9;coroutine.resume(coroutine.create(function()
&#9;&#9;local last_time = tick()
&#9;&#9;while weld1.Parent ~= nil do
&#9;&#9;&#9;r_serv.RenderStepped:wait() ------------------------------------------------
&#9;&#9;&#9;local delta = tick() - last_time
&#9;&#9;&#9;last_time = tick()
&#9;&#9;&#9;
&#9;&#9;&#9;local breathe_amp = 2
&#9;&#9;&#9;local breathe_freq = 0.8
&#9;&#9;&#9;local breathe = math.sin(math.rad(tick() * 90 * breathe_freq)) * breathe_amp
&#9;&#9;&#9;
&#9;&#9;&#9;local shake_freq = 5
&#9;&#9;&#9;local shake_amp = {0.05, 0.05}
&#9;&#9;&#9;local arm_shake = CFrame.new(
&#9;&#9;&#9;&#9;math.sin(math.rad(tick() * 90 * shake_freq)) * move_amm * shake_amp[1],
&#9;&#9;&#9;&#9;0,
&#9;&#9;&#9;&#9;math.abs(math.sin(math.rad(tick() * 90 * shake_freq)) * move_amm * shake_amp[2]))


&#9;&#9;&#9;--ANIMATION LOOP
&#9;&#9;&#9;local p_distance = (head.Position - mouse.Hit.p).magnitude
&#9;&#9;&#9;if p_distance == 0 then p_distance = 0.0001 end
&#9;&#9;&#9;local p_height = mouse.Hit.p.y - head.Position.y
&#9;&#9;&#9;local view_angle 
&#9;&#9;&#9;if p_height ~= 0 then
&#9;&#9;&#9;&#9;view_angle = math.deg(math.asin(math.abs(p_height) / p_distance)) * (math.abs(p_height) / p_height)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;view_angle = 0
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local cam_cf = camera.CoordinateFrame
&#9;&#9;&#9;local looking_at = cam_cf * CFrame.new(0, 0, -100)
&#9;&#9;&#9;local view_angle2 = math.deg(math.atan2(cam_cf.p.x - looking_at.p.x, cam_cf.p.z - looking_at.p.z)) + 180
&#9;&#9;&#9;
&#9;&#9;&#9;local v_delta1, v_delta2
&#9;&#9;&#9;local dir1 = 0
&#9;&#9;&#9;local dir2 = 0
&#9;&#9;&#9;v_delta1 = math.abs(view_angle - last_va)
&#9;&#9;&#9;if v_delta1 ~= 0 then
&#9;&#9;&#9;&#9;dir1 = (view_angle - last_va) / v_delta1
&#9;&#9;&#9;end
&#9;&#9;&#9;local va_check = {math.abs(view_angle2 - last_va2), 360 - math.abs(view_angle2 - last_va2)}
&#9;&#9;&#9;if view_angle2 == last_va2 then
&#9;&#9;&#9;&#9;dir2 = 0
&#9;&#9;&#9;&#9;v_delta2 = 0
&#9;&#9;&#9;elseif va_check[1] &lt; va_check[2] then
&#9;&#9;&#9;&#9;v_delta2 = va_check[1]
&#9;&#9;&#9;&#9;dir2 = (view_angle2 - last_va2) / va_check[1]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;v_delta2 = va_check[2]
&#9;&#9;&#9;&#9;if last_va2 &gt; view_angle2 then
&#9;&#9;&#9;&#9;&#9;dir2 = 1
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;dir2 = -1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;last_va = view_angle
&#9;&#9;&#9;last_va2 = view_angle2
&#9;&#9;&#9;
&#9;&#9;&#9;view_velocity[1] = view_velocity[1] / (1 + (delta * anim_p.aim_retract))
&#9;&#9;&#9;view_velocity[2] = view_velocity[2] / (1 + (delta * anim_p.aim_retract))
&#9;&#9;&#9;
&#9;&#9;&#9;local calc1 = v_delta1 * dir1 * anim_p.aim_amp
&#9;&#9;&#9;if calc1 ~= 0 then
&#9;&#9;&#9;&#9;view_velocity[1] = view_velocity[1] + (math.min(anim_p.aim_max_change, math.abs(calc1)) * (calc1 / math.abs(calc1)))
&#9;&#9;&#9;end
&#9;&#9;&#9;local calc2 = v_delta2 * dir2 * anim_p.aim_amp
&#9;&#9;&#9;if calc2 ~= 0 then
&#9;&#9;&#9;&#9;view_velocity[2] = view_velocity[2] + (math.min(anim_p.aim_max_change, math.abs(calc2)) * (calc2 / math.abs(calc2)))
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if view_velocity[1] ~= 0 then
&#9;&#9;&#9;&#9;view_velocity[1] = math.min(anim_p.aim_max_deg, math.abs(view_velocity[1])) * (math.abs(view_velocity[1]) / view_velocity[1])
&#9;&#9;&#9;end
&#9;&#9;&#9;if view_velocity[2] ~= 0 then
&#9;&#9;&#9;&#9;view_velocity[2] = math.min(anim_p.aim_max_deg, math.abs(view_velocity[2])) * (math.abs(view_velocity[2]) / view_velocity[2])
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local anmtp = _G.MurderKnife_AnimType
&#9;&#9;&#9;local anmst = _G.MurderKnife_AnimState
&#9;&#9;&#9;
&#9;&#9;&#9;if anmst == nil then
&#9;&#9;&#9;&#9;anmst = 0
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if anmtp ~= nil then
&#9;&#9;&#9;&#9;if Animations[anmtp] == nil then
&#9;&#9;&#9;&#9;&#9;anmtp = &quot;Default&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;anmtp = &quot;Default&quot;
&#9;&#9;&#9;end
&#9;&#9;&#9;local curr_anim = PlayAnimation(anmtp, anmst) --left, right, weapon, wep trans
&#9;&#9;&#9;
&#9;&#9;&#9;--curr_anim = {Animations.Default[1][3], Animations.Default[1][4], Animations.Default[1][5], 0}
&#9;&#9;&#9;
&#9;&#9;&#9;local chestCF = CFrame.new(0, 0.5, 0) * CFrame.Angles(math.rad(math.max(-rot_amplitude_chest, math.min(rot_amplitude_chest, view_angle)) + 90 + breathe), 0, 0)
&#9;&#9;&#9;weld1.C1 = (chestCF * curr_anim[1] * CFrame.new(0, -0.5, 0)):inverse()
&#9;&#9;&#9;weld2.C1 = (chestCF * curr_anim[2] * CFrame.new(0, -0.5, 0)):inverse()
&#9;&#9;&#9;wep_weld.C1 = (curr_anim[3] * CFrame.new(0,.0125,0) * CFrame.Angles(90, 0, 0)):inverse()
&#9;&#9;&#9;weapon_parts[1].Transparency = curr_anim[4]
&#9;&#9;&#9;if anim_head then
&#9;&#9;&#9;&#9;weld3.C1 = (CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.max(-rot_amplitude_head, math.min(rot_amplitude_head, view_angle))), 0, 0) * horse_cf):inverse()
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;weld3.C1 = (CFrame.new(0, 0, 0)):inverse()
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if (head.Position - camera.CoordinateFrame.p).magnitude &lt; 3 then
&#9;&#9;&#9;&#9;if anim_model.Parent == nil then
&#9;&#9;&#9;&#9;&#9;anim_model.Parent = camera
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;cam_welds[1].Parent = cam_larm
&#9;&#9;&#9;&#9;cam_welds[2].Parent = cam_rarm
&#9;&#9;&#9;&#9;cam_welds[3].Parent = weapon_parts[2]
&#9;&#9;&#9;&#9;local cam_cf = camera.CoordinateFrame * CFrame.Angles(math.rad(90 + (breathe / 2) - view_velocity[1]), 0, math.rad(view_velocity[2])) * arm_shake * anim_p.cam_offset
&#9;&#9;&#9;&#9;cam_welds[1].C1 = (torso.CFrame:inverse() * cam_cf * CFrame.new(-1.5, 0, 0) * curr_anim[1] * CFrame.new(0, -0.5, 0)):inverse()
&#9;&#9;&#9;&#9;cam_welds[2].C1 = (torso.CFrame:inverse() * cam_cf * CFrame.new(1.5, 0, 0) * curr_anim[2] * CFrame.new(0, -0.5, 0)):inverse()
&#9;&#9;&#9;&#9;cam_welds[3].C1 = (curr_anim[3] * CFrame.Angles(90, 0, 0)):inverse()
&#9;&#9;&#9;&#9;weapon_parts[2].Transparency = curr_anim[4]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if anim_model.Parent ~= nil then
&#9;&#9;&#9;&#9;&#9;anim_model.Parent = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;--ANIMATION LOOP
&#9;&#9;end
&#9;end))
end

local last_st = 0
local eq = false
tool.Equipped:connect(function(mouse)
&#9;if eq then return end
&#9;eq = true
&#9;wait()
&#9;StartAnimation()
end)

tool.Unequipped:connect(function()
&#9;eq = false
&#9;EndAnimation()
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBXEFB212A7C6904C1D85411D4B8173E649">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-11.6203814</X>
					<Y>103.901192</Y>
					<Z>56.9723701</Z>
					<R00>0.812921405</R00>
					<R01>0.06269297</R01>
					<R02>-0.578989148</R02>
					<R10>-0</R10>
					<R11>0.994188786</R11>
					<R12>0.107650779</R12>
					<R20>0.582373559</R20>
					<R21>-0.0875116214</R21>
					<R22>0.8081972</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-10.4624033</X>
					<Y>103.68589</Y>
					<Z>55.3559761</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX8AD7696A06CB4280A6C398D23F079202">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PreloadAssets</string>
				<ProtectedString name="Source">local ContentProvider = game:GetService(&quot;ContentProvider&quot;)
 
local function LoadAssets(AssetList)
 
&#9;for _, AssetId in pairs(AssetList) do
&#9;&#9;ContentProvider:Preload(&quot;http://www.roblox.com/asset/?id=&quot; .. AssetId)
&#9;end
end
 
LoadAssets({169310515,169310520,169310529,169310534,169310273,169310284,169310295})</ProtectedString>
			</Properties>
		</Item>
	</Item>
</roblox>