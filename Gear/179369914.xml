<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX8542C93943194841B87E351F79A3BD4E">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0.300000012</X>
				<Y>-0.5</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<bool name="ManualActivationOnly">false</bool>
			<string name="Name">HalloweenTank</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=177480115</url></Content>
			<string name="ToolTip">RC Tank</string>
		</Properties>
		<Item class="Script" referent="RBX8C326B1E69C94E2CAD21625EAED7E67E">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<ProtectedString name="Source">--Rescripted by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild(&quot;Handle&quot;)
Mesh = Handle:WaitForChild(&quot;Mesh&quot;)

Players = game:GetService(&quot;Players&quot;)
Debris = game:GetService(&quot;Debris&quot;)
RunService = game:GetService(&quot;RunService&quot;)

RbxUtility = LoadLibrary(&quot;RbxUtility&quot;)

Create = RbxUtility.Create

Remover = script:WaitForChild(&quot;Remover&quot;)

Tank = nil

Directions = {
&#9;Forward = {
&#9;&#9;Keys = {
&#9;&#9;&#9;Key = &quot;w&quot;,
&#9;&#9;&#9;ByteKey = 17,
&#9;&#9;},
&#9;&#9;Direction = Vector3.new(0, 1, 0),
&#9;&#9;State = false,
&#9;&#9;LastDown = 0
&#9;},
&#9;Backward = {
&#9;&#9;Keys = {
&#9;&#9;&#9;Key = &quot;s&quot;,
&#9;&#9;&#9;ByteKey = 18,
&#9;&#9;},
&#9;&#9;Direction = Vector3.new(0, -1, 0),
&#9;&#9;State = false,
&#9;&#9;LastDown = 0
&#9;},
&#9;Left = {
&#9;&#9;Keys = {
&#9;&#9;&#9;Key = &quot;a&quot;,
&#9;&#9;&#9;ByteKey = 20,
&#9;&#9;},
&#9;&#9;Direction = Vector3.new(-1, 0, 0),
&#9;&#9;State = false,
&#9;&#9;LastDown = 0
&#9;},
&#9;Right = {
&#9;&#9;Keys = {
&#9;&#9;&#9;Key = &quot;d&quot;,
&#9;&#9;&#9;ByteKey = 19,
&#9;&#9;},
&#9;&#9;Direction = Vector3.new(1, 0, 0),
&#9;&#9;State = false,
&#9;&#9;LastDown = 0
&#9;}
}

ShotDamage = 90

IsPlayingDrive = false
LastDrivingTime = 0

ReloadTime = 1
LastShotTime = 0

ToolCurrentlyEquipped = false

NoteGui = Create(&quot;ScreenGui&quot;){
&#9;Create(&quot;ImageLabel&quot;){
&#9;&#9;Name = &quot;DriveNote&quot;,
&#9;&#9;Position = UDim2.new(0.5, (-128 + 8), 1, -200),
&#9;&#9;Size = UDim2.new(0, 128, 0, 64),
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Image = &quot;http://www.roblox.com/asset/?id=82229919&quot;,
&#9;&#9;Visible = false,
&#9;},
&#9;Create(&quot;ImageLabel&quot;){
&#9;&#9;Name = &quot;FireNote&quot;,
&#9;&#9;Position = UDim2.new(0.5, 0-8, 1, -200),
&#9;&#9;Size = UDim2.new(0, 128, 0, 64),
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Image = &quot;http://www.roblox.com/asset/?id=82071115&quot;,
&#9;&#9;Visible = false,
&#9;},
&#9;Create(&quot;ImageLabel&quot;){
&#9;&#9;Name = &quot;CreateNote&quot;,
&#9;&#9;Position = UDim2.new(0.5, -64, 1, -200),
&#9;&#9;Size = UDim2.new(0, 128, 0, 64),
&#9;&#9;BackgroundTransparency = 1,
&#9;&#9;Image = &quot;http://www.roblox.com/asset/?id=82071122&quot;,
&#9;&#9;Visible = true,
&#9;},
}

CastInfo = {
&#9;{
&#9;&#9;Name = &quot;FrontRight&quot;,
&#9;&#9;Ahead = CFrame.new(1.2, 2.3, 0.3),
&#9;&#9;AheadDesired = 1.24,
&#9;&#9;Stand = CFrame.new(1.2, 1.1, 0),
&#9;&#9;StandDesired = 0.94,
&#9;},
&#9;{
&#9;&#9;Name = &quot;FrontLeft&quot;,
&#9;&#9;Ahead = CFrame.new(-1.2, 2.3, 0.3),
&#9;&#9;AheadDesired = 1.24,
&#9;&#9;Stand = CFrame.new(-1.2, 1.1, 0),
&#9;&#9;StandDesired = 0.94,
&#9;},
&#9;{
&#9;&#9;Name = &quot;BackRight&quot;,
&#9;&#9;Ahead = CFrame.new(1.2, -2.3, 0.3),
&#9;&#9;AheadDesired = 1.24,
&#9;&#9;Stand = CFrame.new(1.2, -1.6, 0),
&#9;&#9;StandDesired = 0.94,
&#9;}, 
&#9;{
&#9;&#9;Name = &quot;BackLeft&quot;,
&#9;&#9;Ahead = CFrame.new(-1.2, -2.3, 0.3),
&#9;&#9;AheadDesired = 1.24,
&#9;&#9;Stand = CFrame.new(-1.2, -1.6, 0),
&#9;&#9;StandDesired = 0.94,
&#9;},
}

for _, dat in pairs(CastInfo) do
&#9;dat.LocalAxis = dat.Stand.p:Cross(Vector3.new(0, 0, 1)).unit
&#9;dat.AheadLength = dat.Ahead.p.magnitude
&#9;dat.StandLength = dat.Stand.p.magnitude
end

Tool.Grip = CFrame.new(-0.191770241, 0.0683477223, -0.607085466, -0.87758249, 0, -0.479425609, -0.420735568, 0.47942549, 0.770151138, 0.229848862, 0.87758261, -0.420735419)
Mesh.MeshId = &quot;http://www.roblox.com/asset/?id=81616133&quot;

ServerControl = (Tool:FindFirstChild(&quot;ServerControl&quot;) or Instance.new(&quot;RemoteFunction&quot;))
ServerControl.Name = &quot;ServerControl&quot;
ServerControl.Parent = Tool

ClientControl = (Tool:FindFirstChild(&quot;ClientControl&quot;) or Instance.new(&quot;RemoteFunction&quot;))
ClientControl.Name = &quot;ClientControl&quot;
ClientControl.Parent = Tool

Handle.Transparency = 0
Tool.Enabled = true

ServerControl.OnServerInvoke = (function(player, Mode, Value)
&#9;if player == Player and CheckIfAlive() then
&#9;&#9;if Mode == &quot;MouseClick&quot; and Value.Down then
&#9;&#9;&#9;--Activated()
&#9;&#9;elseif Mode == &quot;MouseMove&quot; and not CheckIfTankAlive() then
&#9;&#9;&#9;local MousePosition = InvokeClient(&quot;MousePosition&quot;)
&#9;&#9;&#9;if (Torso.Position - MousePosition).magnitude &lt; 20 then
&#9;&#9;&#9;&#9;InvokeClient(&quot;SetMouseIcon&quot;, &quot;http://www.roblox.com/asset/?id=82230945&quot;)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;InvokeClient(&quot;SetMouseIcon&quot;, &quot;http://www.roblox.com/asset/?id=82071072&quot;)
&#9;&#9;&#9;end
&#9;&#9;elseif Mode == &quot;KeyPress&quot; then
&#9;&#9;&#9;local Key = Value.Key
&#9;&#9;&#9;local ByteKey = string.byte(Key)
&#9;&#9;&#9;local Down = Value.Down
&#9;&#9;&#9;if Down then
&#9;&#9;&#9;&#9;local DirectionKeyPressed = false
&#9;&#9;&#9;&#9;for i, v in pairs(Directions) do
&#9;&#9;&#9;&#9;&#9;for ii, vv in pairs(v.Keys) do
&#9;&#9;&#9;&#9;&#9;&#9;if ((ii == &quot;Key&quot; and vv == Key) or (ii == &quot;ByteKey&quot; and vv == ByteKey)) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Directions[i].State = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Directions[i].LastDown = 0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;DirectionKeyPressed = true
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if ToolCurrentlyEquipped and CheckIfAlive() and CheckIfTankAlive() then
&#9;&#9;&#9;&#9;&#9;if DirectionKeyPressed and not IsPlayingDrive then
&#9;&#9;&#9;&#9;&#9;&#9;IsPlayingDrive = true
&#9;&#9;&#9;&#9;&#9;&#9;StartSound:Play()
&#9;&#9;&#9;&#9;&#9;&#9;DriveSound:Play()
&#9;&#9;&#9;&#9;&#9;&#9;IdleSound:Stop()
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;for i, v in pairs(Directions) do
&#9;&#9;&#9;&#9;&#9;for ii, vv in pairs(v.Keys) do
&#9;&#9;&#9;&#9;&#9;&#9;if ((ii == &quot;Key&quot; and vv == Key) or (ii == &quot;ByteKey&quot; and vv == ByteKey)) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Directions[i].State = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Directions[i].LastDown = tick()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if Tank and IsPlayingDrive then
&#9;&#9;&#9;&#9;&#9;local IsDriving = false
&#9;&#9;&#9;&#9;&#9;for i, v in pairs(Directions) do
&#9;&#9;&#9;&#9;&#9;&#9;if v.State then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;IsDriving = true
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if not IsDriving then
&#9;&#9;&#9;&#9;&#9;&#9;IsPlayingDrive = false
&#9;&#9;&#9;&#9;&#9;&#9;LastDrivingTime = tick()
&#9;&#9;&#9;&#9;&#9;&#9;DriveSound:Stop()
&#9;&#9;&#9;&#9;&#9;&#9;IdleSound:Play()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)

function InvokeClient(Mode, Value)
&#9;local ClientReturn = nil
&#9;pcall(function()
&#9;&#9;ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
&#9;end)
&#9;return ClientReturn
end

function TopVector(cframe)
&#9;local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
&#9;return Vector3.new(R01, R11, R21)
end

function BackVector(cframe)
&#9;local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
&#9;return Vector3.new(R02, R12, R22)
end

function RightVector(cframe)
&#9;local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components()
&#9;return Vector3.new(R00, R10, R20)
end

function CFrameFromTopBack(at, top, back)
&#9;local Right = top:Cross(back)
&#9;return CFrame.new(
&#9;&#9;at.x, at.y, at.z,
&#9;&#9;Right.x, top.x, back.x,
&#9;&#9;Right.y, top.y, back.y,
&#9;&#9;Right.z, top.z, back.z
&#9;)
end

function CreateTank()
&#9;local Body = Create(&quot;Part&quot;){
&#9;&#9;Name = &quot;Torso&quot;,
&#9;&#9;FormFactor = &quot;Custom&quot;,
&#9;&#9;Size = Vector3.new(2.8, 4.25, 1.75),
&#9;&#9;Create(&quot;SpecialMesh&quot;){
&#9;&#9;&#9;Scale = Vector3.new(2.5, 2, 2.5),
&#9;&#9;&#9;MeshId = &quot;http://www.roblox.com/asset/?id=81616058&quot;,
&#9;&#9;&#9;TextureId = &quot;http://www.roblox.com/asset/?id=177480340&quot;,
&#9;&#9;},
&#9;&#9;Create(&quot;BodyGyro&quot;){
&#9;&#9;&#9;maxTorque = Vector3.new(math.huge, math.huge, math.huge),
&#9;&#9;&#9;cframe = CFrame.new(0, 0, 0),
&#9;&#9;},
&#9;&#9;Create(&quot;Sound&quot;){
&#9;&#9;&#9;Name = &quot;FireSound&quot;,
&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=81116734&quot;,
&#9;&#9;},
&#9;&#9;Create(&quot;Sound&quot;){
&#9;&#9;&#9;Name = &quot;ExplodeSound&quot;,
&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=81116747&quot;,
&#9;&#9;},
&#9;&#9;Create(&quot;Sound&quot;){
&#9;&#9;&#9;Name = &quot;IdleSound&quot;,
&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=82229695&quot;,
&#9;&#9;&#9;Looped = true,
&#9;&#9;&#9;Pitch = 0.6,
&#9;&#9;&#9;Volume = 0.2,
&#9;&#9;},
&#9;&#9;Create(&quot;Sound&quot;){
&#9;&#9;&#9;Name = &quot;StartSound&quot;,
&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=82229695&quot;,
&#9;&#9;&#9;Pitch = 0.8,
&#9;&#9;&#9;Volume = 1.0,
&#9;&#9;},
&#9;&#9;Create(&quot;Sound&quot;){
&#9;&#9;&#9;Name = &quot;DriveSound&quot;,
&#9;&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=82229584&quot;,
&#9;&#9;&#9;Pitch = 1.5,
&#9;&#9;&#9;Volume = 1.0,
&#9;&#9;&#9;Looped = true,
&#9;&#9;},
&#9;}
&#9;
&#9;BodyGyro = Body:FindFirstChild(&quot;BodyGyro&quot;)
&#9;FireSound = Body:FindFirstChild(&quot;FireSound&quot;)
&#9;ExplodeSound = Body:FindFirstChild(&quot;ExplodeSound&quot;)
&#9;IdleSound = Body:FindFirstChild(&quot;IdleSound&quot;)
&#9;StartSound = Body:FindFirstChild(&quot;StartSound&quot;)
&#9;DriveSound = Body:FindFirstChild(&quot;DriveSound&quot;)
&#9;
&#9;local Turret = Create(&quot;Part&quot;){
&#9;&#9;Name = &quot;Head&quot;,
&#9;&#9;FormFactor = &quot;Custom&quot;,
&#9;&#9;Size = Vector3.new(2.4, 1.6, 0.7),
&#9;&#9;CanCollide = false,
&#9;&#9;Create(&quot;SpecialMesh&quot;){
&#9;&#9;&#9;Scale = Vector3.new(2.5, 2, 3.5),
&#9;&#9;&#9;MeshId = &quot;http://www.roblox.com/asset/?id=81616087&quot;,
&#9;&#9;&#9;TextureId = &quot;http://www.roblox.com/asset/?id=177480340&quot;,
&#9;&#9;},
&#9;}
&#9;
&#9;local Cannon = Create(&quot;Part&quot;){
&#9;&#9;Name = &quot;Cannon&quot;,
&#9;&#9;FormFactor = &quot;Custom&quot;,
&#9;&#9;Size = Vector3.new(0.4, 0.4, 0.4),
&#9;&#9;Create(&quot;SpecialMesh&quot;){
&#9;&#9;&#9;Scale = Vector3.new(5, 2, 5),
&#9;&#9;&#9;MeshId = &quot;http://www.roblox.com/asset/?id=81616091&quot;,
&#9;&#9;&#9;TextureId = &quot;http://www.roblox.com/asset/?id=177480340&quot;,
&#9;&#9;},
&#9;}
&#9;
&#9;local Humanoid = Create(&quot;Humanoid&quot;){
&#9;&#9;PlatformStand = true,
&#9;}
&#9;
&#9;local TurretAttach = Create(&quot;Weld&quot;){
&#9;&#9;Name = &quot;Neck&quot;,
&#9;&#9;Parent = Body,
&#9;&#9;Part0 = Body,
&#9;&#9;Part1 = Turret,
&#9;&#9;C0 = CFrame.new(0, 0, 0.5),
&#9;&#9;C1 = CFrame.new(0, 0, -0.4),
&#9;}
&#9;
&#9;local CannonAttach = Create(&quot;Weld&quot;){
&#9;&#9;Name = &quot;CannonAttach&quot;,
&#9;&#9;Parent = Turret,
&#9;&#9;Part0 = Turret,
&#9;&#9;Part1 = Cannon,
&#9;&#9;C0 = CFrame.new(0, 0.875, -0.2),
&#9;&#9;C1 = CFrame.new(0, 0.1, 0),
&#9;}
&#9;
&#9;local Model = Create(&quot;Model&quot;){
&#9;&#9;Name = &quot;Tank&quot;,
&#9;}
&#9;
&#9;Body.Parent = Model
&#9;Turret.Parent = Model
&#9;Cannon.Parent = Model
&#9;Humanoid.Parent = Model
&#9;Humanoid.MaxHealth = 500
&#9;Humanoid.Health = Humanoid.MaxHealth

&#9;return {
&#9;&#9;Model = Model,
&#9;&#9;Body = Body,
&#9;&#9;BodyGyro = BodyGyro,
&#9;&#9;Turret = Turret,
&#9;&#9;Cannon = Cannon,
&#9;&#9;TurretAttach = TurretAttach,
&#9;&#9;CannonAttach = CannonAttach,
&#9;&#9;Humanoid = Humanoid,
&#9;}
&#9;
end

function DoCastDown(Offset, Dir)
&#9;Dir = (Dir or Vector3.new(0, -1, 0))
&#9;local CastFrom = ((Tank.Body.CFrame * Offset).p - Dir * 2.5)
&#9;
&#9;local ray = Ray.new(CastFrom, Dir * 999)
&#9;local Part, at = game:GetService(&quot;Workspace&quot;):FindPartOnRay(ray, Tank.Model)
&#9;if Part and (not Part.CanCollide or Part.Transparency == 1) then
&#9;&#9;local Parts = {Tank.Body, Tank.Turret, Tank.Cannon}
&#9;&#9;while Part and (not Part.CanCollide or Part.Transparency == 1) do
&#9;&#9;&#9;Parts[#Parts + 1] = Part
&#9;&#9;&#9;Part, at = game:GetService(&quot;Workspace&quot;):FindPartOnRayWithIgnoreList(ray, Parts)
&#9;&#9;end
&#9;end
&#9;
&#9;return Part, at, ((CastFrom - at).magnitude - 2.5)
end

function Clamp(n, min, max)
&#9;return math.max(math.min(max, n), min)
end

function Sign(n)
&#9;return (((n &gt;= 0) and 1) or -1)
end

function CheckIfTankAlive()
&#9;return (Tank and Tank.Model and Tank.Model.Parent and Tank.Body and Tank.Body.Parent and Tank.Turret and Tank.Turret.Parent and Tank.Cannon and Tank.Cannon.Parent and Tank.Humanoid and Tank.Humanoid.Parent and Tank.Humanoid.Health &gt; 0)
end

function EnableSteering()
&#9;local LastTime = tick()
&#9;local LastTimeInAir = 0
&#9;local LastVelocity = 0
&#9;local DesiredHeading = Vector3.new()
&#9;local IsOnGround = false
&#9;local TurnSpeed = 1.8 -- rad / sec
&#9;local MoveSpeed = 11.0 -- stud / sec

&#9;local CurrentlyEquipped = true
&#9;local Connected = true

&#9;for i, v in pairs({TankControl, ToolUnequipped}) do
&#9;&#9;if v then
&#9;&#9;&#9;v:disconnect()
&#9;&#9;end
&#9;end
&#9;
&#9;ToolUnequipped = Tool.Unequipped:connect(function()
&#9;&#9;CurrentlyEquipped = false
&#9;end)
&#9;
&#9;TankControl = RunService.Heartbeat:connect(function()

&#9;&#9;if not CurrentlyEquipped or not CheckIfAlive() or not CheckIfTankAlive() then
&#9;&#9;&#9;Connected = false
&#9;&#9;&#9;for i, v in pairs({TankControl, ToolUnequipped}) do
&#9;&#9;&#9;&#9;if v then
&#9;&#9;&#9;&#9;&#9;v:disconnect()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if Connected then
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local dt = (t - LastTime)
&#9;&#9;&#9;LastTime = t
&#9;&#9;&#9;
&#9;&#9;&#9;local MousePosition = InvokeClient(&quot;MousePosition&quot;)
&#9;&#9;&#9;
&#9;&#9;&#9;if (Tank.Turret.Position - MousePosition).magnitude &lt; 140 then
&#9;&#9;&#9;&#9;InvokeClient(&quot;SetMouseIcon&quot;, &quot;http://www.roblox.com/asset/?id=82071097&quot;)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;InvokeClient(&quot;SetMouseIcon&quot;, &quot;http://www.roblox.com/asset/?id=82071109&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local _, _, DistOffGround = DoCastDown(CFrame.new())
&#9;&#9;&#9;DistOffGround = (DistOffGround - 0.94)
&#9;&#9;&#9;if DistOffGround &gt; 3 then
&#9;&#9;&#9;&#9;if IsOnGround then
&#9;&#9;&#9;&#9;&#9;IsOnGround = false
&#9;&#9;&#9;&#9;&#9;BodyGyro.maxTorque = Vector3.new(0, 0, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;LastTimeInAir = t
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;DriveSound.Pitch = 1.8
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;elseif (t - LastTimeInAir) &gt; 2 then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;DriveSound.Pitch = (1.2 + 0.6 * LastVelocity)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if not IsOnGround then
&#9;&#9;&#9;&#9;&#9;IsOnGround = true
&#9;&#9;&#9;&#9;&#9;BodyGyro.maxTorque = Vector3.new(math.huge, math.huge, math.huge)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local BodyLook = TopVector(Tank.Body.CFrame)
&#9;&#9;&#9;&#9;DesiredHeading = Vector3.new(BodyLook.x, 0, BodyLook.z).unit
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local TankSavedPositionHack = Tank.Body.CFrame
&#9;&#9;&#9;&#9;local TurretToHitVec = (MousePosition - Tank.Turret.Position)
&#9;&#9;&#9;&#9;local DistToHit = TurretToHitVec.magnitude
&#9;&#9;&#9;&#9;local RotAxis = TurretToHitVec:Cross(TurretToHitVec - Vector3.new(0, TurretToHitVec.y, 0)).unit
&#9;&#9;&#9;&#9;if TurretToHitVec.y &gt; 0 then
&#9;&#9;&#9;&#9;&#9;RotAxis = -RotAxis
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local TurretToHit = (CFrame.fromAxisAngle(RotAxis, math.min(1, DistToHit / 140) * math.pi / 3.5) * TurretToHitVec.unit)
&#9;&#9;&#9;&#9;local SwivelPlaneNormal = Tank.Body.CFrame.lookVector
&#9;&#9;&#9;&#9;local TurretDir = (TurretToHit - SwivelPlaneNormal * TurretToHit:Dot(SwivelPlaneNormal)).unit
&#9;&#9;&#9;&#9;local DesiredTurretCF = CFrameFromTopBack(Tank.Turret.Position, TurretDir, -SwivelPlaneNormal) * CFrame.Angles(0, 0.01, 0)
&#9;&#9;&#9;&#9;Tank.Body.CFrame = TankSavedPositionHack
&#9;&#9;&#9;&#9;Tank.TurretAttach.C1 = DesiredTurretCF:inverse() * Tank.Body.CFrame * CFrame.new(0, 0, 0.5)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local DesiredCannonCF = CFrameFromTopBack((Tank.Turret.CFrame * CFrame.new(0, 1.125, -0.2)).p, TurretToHit, TurretToHit:Cross(RightVector(DesiredTurretCF)))
&#9;&#9;&#9;&#9;--[[if (t - LastShotTime) &lt; 1 then
&#9;&#9;&#9;&#9;&#9;local Elapsed = (t - LastShotTime)
&#9;&#9;&#9;&#9;&#9;if Elapsed &lt; 0.1 then
&#9;&#9;&#9;&#9;&#9;&#9;DesiredCannonCF = DesiredCannonCF * CFrame.new(0, -((Elapsed / 0.1) * 0.8), 0)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;DesiredCannonCF = DesiredCannonCF * CFrame.new(0, -((1 - ((Elapsed - 0.1) / 0.9)) * 0.8),0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end]]
&#9;&#9;&#9;&#9;Tank.CannonAttach.C1 = DesiredCannonCF:inverse() * Tank.Turret.CFrame * CFrame.new(0, 1.125, -0.2)
&#9;&#9;&#9;&#9;Tank.Body.CFrame = TankSavedPositionHack
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local CoordinateFrame = InvokeClient(&quot;GetCamera&quot;, {Property = &quot;CoordinateFrame&quot;})
&#9;&#9;&#9;&#9;local CamLook = CoordinateFrame.lookVector
&#9;&#9;&#9;&#9;local CamDir = Vector3.new(CamLook.x, 0, CamLook.z).unit
&#9;&#9;&#9;&#9;local CamPerpDir = CamDir:Cross(Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local MoveDirs = Vector3.new()
&#9;&#9;&#9;&#9;local function Decay(v)
&#9;&#9;&#9;&#9;&#9;return (1 - math.sqrt(1 - v))
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;for i, v in pairs(Directions) do
&#9;&#9;&#9;&#9;&#9;if Directions[i].State then
&#9;&#9;&#9;&#9;&#9;&#9;MoveDirs = (MoveDirs + v.Direction)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;local Delay = 0.8
&#9;&#9;&#9;&#9;&#9;if v.Direction.X ~= 0 then
&#9;&#9;&#9;&#9;&#9;&#9;Delay = 0.4
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if (t - Directions[i].LastDown) &lt; Delay then
&#9;&#9;&#9;&#9;&#9;&#9;MoveDirs = (MoveDirs + v.Direction * Decay(Delay - (t - Directions[i].LastDown)))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local KeyHeading = (CamDir * MoveDirs.y + CamPerpDir * MoveDirs.x)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local SpeedFactor = KeyHeading:Dot(DesiredHeading)
&#9;&#9;&#9;&#9;local TurnFactor
&#9;&#9;&#9;&#9;if KeyHeading.magnitude &gt; 0 then
&#9;&#9;&#9;&#9;&#9;TurnFactor = -KeyHeading.unit:Cross(DesiredHeading).y
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;TurnFactor = 0
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;LastVelocity = math.abs(SpeedFactor)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local TankLevelCF = CFrameFromTopBack(Tank.Body.Position, DesiredHeading, Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;if TurnFactor ~= 0 or SpeedFactor ~= 0 then
&#9;&#9;&#9;&#9;&#9;local TankCFrame = TankLevelCF * CFrame.Angles(0, 0, (TurnFactor * TurnSpeed * dt)) * CFrame.new(0, (SpeedFactor * MoveSpeed * dt), 0)
&#9;&#9;&#9;&#9;&#9;local PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22 = TankCFrame:components()
&#9;&#9;&#9;&#9;&#9;if tostring(PX) ~= &quot;-1.#IND&quot; and tostring(PY) ~= &quot;-1.#IND&quot; and tostring(PZ) ~= &quot;-1.#IND&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;Tank.Body.CFrame = CFrame.new(PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;local PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22 = TankLevelCF:components()
&#9;&#9;&#9;&#9;&#9;if tostring(PX) ~= &quot;-1.#IND&quot; and tostring(PY) ~= &quot;-1.#IND&quot; and tostring(PZ) ~= &quot;-1.#IND&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;Tank.Body.CFrame = CFrame.new(PX, PY, PZ, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local AvrDisp = 0
&#9;&#9;&#9;&#9;local NumDisps = 0
&#9;&#9;&#9;&#9;for _, Cast in pairs(CastInfo) do
&#9;&#9;&#9;&#9;&#9;local _, _, aheadH = DoCastDown(Cast.Ahead)
&#9;&#9;&#9;&#9;&#9;local _, _, standH = DoCastDown(Cast.Stand)
&#9;&#9;&#9;&#9;&#9;Cast.AheadH = (aheadH - Cast.AheadDesired)
&#9;&#9;&#9;&#9;&#9;Cast.StandH = (standH - Cast.StandDesired)
&#9;&#9;&#9;&#9;&#9;if Cast.AheadH &lt; 3 then
&#9;&#9;&#9;&#9;&#9;&#9;AvrDisp = (AvrDisp + Cast.AheadH)
&#9;&#9;&#9;&#9;&#9;&#9;NumDisps = (NumDisps + 1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;AvrDisp = ((NumDisps &gt; 0) and (AvrDisp / NumDisps) or 0)
&#9;&#9;&#9;&#9;local tankRot = Tank.Body.CFrame - Tank.Body.CFrame.p
&#9;&#9;&#9;&#9;local RotAmountX = 0
&#9;&#9;&#9;&#9;local RotAmountY = 0
&#9;&#9;&#9;&#9;local NumRots = 0
&#9;&#9;&#9;&#9;for _, Cast in pairs(CastInfo) do
&#9;&#9;&#9;&#9;&#9;local Which = nil
&#9;&#9;&#9;&#9;&#9;if Cast.AheadH &gt; 3 and Cast.StandH &gt; 3 then
&#9;&#9;&#9;&#9;&#9;elseif Cast.AheadH &gt; 3 then
&#9;&#9;&#9;&#9;&#9;&#9;Which = true
&#9;&#9;&#9;&#9;&#9;elseif Cast.StandH &gt; 3 then
&#9;&#9;&#9;&#9;&#9;&#9;Which = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;Which = (Cast.StandH &lt; Cast.AheadH)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if Which ~= nil then
&#9;&#9;&#9;&#9;&#9;&#9;local h, distOut
&#9;&#9;&#9;&#9;&#9;&#9;if Which then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;h = Cast.StandH
&#9;&#9;&#9;&#9;&#9;&#9;&#9;distOut = Cast.StandLength
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;h = Cast.AheadH
&#9;&#9;&#9;&#9;&#9;&#9;&#9;distOut = Cast.AheadLength
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;h = (h - AvrDisp)
&#9;&#9;&#9;&#9;&#9;&#9;local theta = -math.atan(h / distOut)
&#9;&#9;&#9;&#9;&#9;&#9;RotAmountX = (RotAmountX + theta * Cast.LocalAxis.x)
&#9;&#9;&#9;&#9;&#9;&#9;RotAmountY = (RotAmountY + theta * Cast.LocalAxis.y)
&#9;&#9;&#9;&#9;&#9;&#9;NumRots = (NumRots + 1)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;Tank.BodyGyro.cframe = CFrame.new(0, -AvrDisp, 0) * Tank.Body.CFrame * CFrame.Angles((RotAmountX / NumRots * 2), 0, 0) * CFrame.Angles(0, (RotAmountY / NumRots * 2), 0)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local _, _, RightFudge = DoCastDown(CFrame.new(1.2, 0, 0))
&#9;&#9;&#9;&#9;local _, _, LeftFudge = DoCastDown(CFrame.new(-1.2, 0, 0))
&#9;&#9;&#9;&#9;RightFudge = ((RightFudge - 0.94) / math.cos(RotAmountX / NumRots * 2))
&#9;&#9;&#9;&#9;LeftFudge = ((LeftFudge - 0.94) / math.cos(RotAmountX / NumRots * 2))
&#9;&#9;&#9;&#9;if RightFudge &lt; 1 and LeftFudge &lt; 1 then
&#9;&#9;&#9;&#9;&#9;Tank.BodyGyro.cframe = CFrame.new(0, -0.5 * (RightFudge + LeftFudge), 0) * Tank.Body.CFrame
&#9;&#9;&#9;&#9;elseif RightFudge &lt; 1 then
&#9;&#9;&#9;&#9;&#9;Tank.BodyGyro.cframe = CFrame.new(0, -RightFudge, 0) * Tank.Body.CFrame
&#9;&#9;&#9;&#9;elseif LeftFudge &lt; 1 then
&#9;&#9;&#9;&#9;&#9;Tank.BodyGyro.cframe = CFrame.new(0, -LeftFudge, 0) * Tank.Body.CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local DesiredLen = 0.6
&#9;&#9;&#9;&#9;local CastDir = TopVector(Tank.Body.CFrame)
&#9;&#9;&#9;&#9;local Parta, ata, dista = DoCastDown(CFrame.new(1.2, 1.5, 0.5), CastDir)
&#9;&#9;&#9;&#9;local Partb, atb, distb = DoCastDown(CFrame.new(-1.2, 1.5, 0.5), CastDir)
&#9;&#9;&#9;&#9;local smallerGap = (math.min(dista, distb) - DesiredLen)
&#9;&#9;&#9;&#9;if smallerGap &lt; 0 then
&#9;&#9;&#9;&#9;&#9;Tank.Body.CFrame = Tank.Body.CFrame * CFrame.new(0, smallerGap, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--falling
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
end

function TagHumanoid(humanoid, player)
&#9;local Creator_Tag = Instance.new(&quot;ObjectValue&quot;)
&#9;Creator_Tag.Name = &quot;creator&quot;
&#9;Creator_Tag.Value = player
&#9;Debris:AddItem(Creator_Tag, 2)
&#9;Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
&#9;for i, v in pairs(humanoid:GetChildren()) do
&#9;&#9;if v:IsA(&quot;ObjectValue&quot;) and v.Name == &quot;creator&quot; then
&#9;&#9;&#9;v:Destroy()
&#9;&#9;end
&#9;end
end

function Fire(Origin, TargetPosition, Direction)
&#9;local Projectile = Instance.new(&quot;Part&quot;)
&#9;Projectile.Name = &quot;Projectile&quot;
&#9;Projectile.Material = Enum.Material.Plastic
&#9;Projectile.Shape = Enum.PartType.Block
&#9;Projectile.TopSurface = Enum.SurfaceType.Smooth
&#9;Projectile.BottomSurface = Enum.SurfaceType.Smooth
&#9;Projectile.FormFactor = Enum.FormFactor.Custom
&#9;Projectile.CFrame = CFrame.new(Origin)
&#9;Projectile.Shape = Enum.PartType.Ball
&#9;Projectile.Size = Vector3.new(1, 1, 1)
&#9;local ProjectileMesh = Create(&quot;SpecialMesh&quot;){
&#9;&#9;MeshId = &quot;http://www.roblox.com/asset/?id=1158007&quot;,
&#9;&#9;TextureId = &quot;http://www.roblox.com/asset/?id=1158033&quot;,
&#9;&#9;Scale = Vector3.new(0.25, 0.25, 0.25),
&#9;&#9;Parent = Projectile,
&#9;}
&#9;local BodyPosition = Create(&quot;BodyPosition&quot;){
&#9;&#9;maxForce = Vector3.new(10000, 10000, 10000),
&#9;&#9;P = 30000,
&#9;&#9;Parent = Projectile,
&#9;}
&#9;local ExplodeSound = Create(&quot;Sound&quot;){
&#9;&#9;SoundId = &quot;http://www.roblox.com/asset/?id=81116747&quot;,
&#9;&#9;Parent = Projectile,
&#9;}&#9;
&#9;local TotalDist = (TargetPosition - Origin).magnitude
&#9;local Speed = 80 --studs/sec
&#9;local FlightTime = (TotalDist / Speed)
&#9;local Exploded = false
&#9;local function Explode()
&#9;&#9;if Exploded then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;Exploded = true
&#9;&#9;Projectile.Transparency = 1
&#9;&#9;Projectile.Anchored = true
&#9;&#9;local Explosion = Create(&quot;Explosion&quot;){
&#9;&#9;&#9;BlastPressure = 0,
&#9;&#9;&#9;BlastRadius = 12,
&#9;&#9;&#9;Position = Projectile.Position,
&#9;&#9;}
&#9;&#9;local HitHumanoids = {}
&#9;&#9;Explosion.Hit:connect(function(Hit)
&#9;&#9;&#9;if not Hit or not Hit.Parent then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;local character = Hit.Parent
&#9;&#9;&#9;local humanoid = character:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;&#9;if humanoid and not HitHumanoids[humanoid] and humanoid ~= Tank.Humanoid and humanoid ~= Humanoid then
&#9;&#9;&#9;&#9;HitHumanoids[humanoid] = true
&#9;&#9;&#9;&#9;UntagHumanoid(humanoid)
&#9;&#9;&#9;&#9;TagHumanoid(humanoid, Player)
&#9;&#9;&#9;&#9;humanoid:TakeDamage(ShotDamage)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;Explosion.Parent = game:GetService(&quot;Workspace&quot;)
&#9;&#9;ExplodeSound:Play()
&#9;&#9;Debris:AddItem(Projectile, 2)
&#9;&#9;Debris:AddItem(Explosion, 2)
&#9;end

&#9;Projectile.Touched:connect(function(Hit)
&#9;&#9;if not Hit or not Hit.Parent then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;local character = Hit.Parent
&#9;&#9;if character == Tank.Model then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;Explode()
&#9;end)
&#9;
&#9;Debris:AddItem(Projectile, 5)
&#9;Projectile.Parent = game:GetService(&quot;Workspace&quot;)&#9;
&#9;
&#9;local AheadVector = (Direction.unit * TotalDist)
&#9;local FlightVector = (TargetPosition - Origin)
&#9;
&#9;--keep flying
&#9;Projectile.Anchored = false
&#9;for t = 0, FlightTime, 0.033 do
&#9;&#9;if Exploded then
&#9;&#9;&#9;break
&#9;&#9;end
&#9;&#9;local f = (t / FlightTime)
&#9;&#9;--
&#9;&#9;BodyPosition.position = (Origin + ((AheadVector * f) * ( 1 - f) + (FlightVector * f) * f))
&#9;&#9;--
&#9;&#9;wait(0.03)
&#9;end
&#9;BodyPosition.position = TargetPosition
&#9;Spawn(function()
&#9;&#9;while Projectile and Projectile.Parent and (Projectile.Position - TargetPosition).magnitude &gt; 1 do
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;&#9;Explode()
&#9;end)

end

function Activated()
&#9;if not CheckIfAlive() then
&#9;&#9;return
&#9;end
&#9;local MousePosition = InvokeClient(&quot;MousePosition&quot;)
&#9;if Tank and Tank.Model and Tank.Model.Parent then
&#9;&#9;if (tick() - LastShotTime) &gt; ReloadTime then
&#9;&#9;&#9;local Origin = (Tank.Cannon.CFrame * CFrame.new(0, 3, 0)).p
&#9;&#9;&#9;local Direction = TopVector(Tank.Cannon.CFrame)
&#9;&#9;&#9;if (MousePosition - Origin).magnitude &lt; 140 then
&#9;&#9;&#9;&#9;LastShotTime = tick()
&#9;&#9;&#9;&#9;FireSound:Play()
&#9;&#9;&#9;&#9;Fire(Origin, MousePosition, Direction)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif (Torso.Position - MousePosition).magnitude &lt; 20 then
&#9;&#9;Tank = CreateTank()
&#9;&#9;
&#9;&#9;local ScriptName = (Player.Name .. Remover.Name)
&#9;&#9;local RemoverClone = game:GetService(&quot;Workspace&quot;):FindFirstChild(ScriptName)
&#9;&#9;if RemoverClone then
&#9;&#9;&#9;RemoverClone:Destroy()
&#9;&#9;end
&#9;&#9;RemoverClone = Remover:Clone()
&#9;&#9;RemoverClone.Name = ScriptName
&#9;&#9;local CreatorValue = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;CreatorValue.Name = &quot;Creator&quot;
&#9;&#9;CreatorValue.Value = Player
&#9;&#9;CreatorValue.Parent = RemoverClone
&#9;&#9;local ToolValue = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;ToolValue.Name = &quot;Tool&quot;
&#9;&#9;ToolValue.Value = Tool
&#9;&#9;ToolValue.Parent = RemoverClone
&#9;&#9;local ModelValue = Instance.new(&quot;ObjectValue&quot;)
&#9;&#9;ModelValue.Name = &quot;Model&quot;
&#9;&#9;ModelValue.Value = Tank.Model
&#9;&#9;ModelValue.Parent = RemoverClone
&#9;&#9;RemoverClone.Disabled = false
&#9;&#9;RemoverClone.Parent = game:GetService(&quot;Workspace&quot;)
&#9;&#9;
&#9;&#9;Tank.Model.Parent = game:GetService(&quot;Workspace&quot;)
&#9;&#9;
&#9;&#9;local TankCFrame = CFrameFromTopBack((MousePosition + Vector3.new(0, 1.8, 0)), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0))
&#9;&#9;Tank.Body.CFrame = TankCFrame
&#9;&#9;Tank.BodyGyro.cframe = TankCFrame 
&#9;&#9;&#9;
&#9;&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraSubject&quot;, Value = Tank.Model})
&#9;&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraType&quot;, Value = Enum.CameraType.Track})
&#9;&#9;
&#9;&#9;IdleSound:Play()
&#9;&#9;
&#9;&#9;Humanoid.WalkSpeed = 0

&#9;&#9;if NoteGuiClone and NoteGuiClone.Parent then
&#9;&#9;&#9;NoteGuiClone.CreateNote.Visible = false
&#9;&#9;&#9;NoteGuiClone.DriveNote.Visible = true
&#9;&#9;&#9;NoteGuiClone.FireNote.Visible = true
&#9;&#9;end
&#9;&#9;
&#9;&#9;Tank.Humanoid.Died:connect(function()
&#9;&#9;&#9;game.Debris:AddItem(Tank.Model, 2)
&#9;&#9;&#9;Tank.Model:BreakJoints()
&#9;&#9;&#9;Tank = nil
&#9;&#9;&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraSubject&quot;, Value = Character})
&#9;&#9;&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraType&quot;, Value = Enum.CameraType.Custom})
&#9;&#9;&#9;if NoteGuiClone and NoteGuiClone.Parent then
&#9;&#9;&#9;&#9;NoteGuiClone.CreateNote.Visible = true
&#9;&#9;&#9;&#9;NoteGuiClone.DriveNote.Visible = false
&#9;&#9;&#9;&#9;NoteGuiClone.FireNote.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;InvokeClient(&quot;DisableJump&quot;, false)
&#9;&#9;&#9;Humanoid.WalkSpeed = 16
&#9;&#9;end)
&#9;&#9;
&#9;&#9;Spawn(function()
&#9;&#9;&#9;EnableSteering()
&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;end
end

function CheckIfAlive()
&#9;return (((Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0 and Torso and Torso.Parent) and true) or false)
end

function Equipped()
&#9;
&#9;Character = Tool.Parent
&#9;Player = Players:GetPlayerFromCharacter(Character)
&#9;PlayerGui = Player:FindFirstChild(&quot;PlayerGui&quot;)
&#9;Humanoid = Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;Torso = Character:FindFirstChild(&quot;Torso&quot;)
&#9;if not CheckIfAlive() then
&#9;&#9;return
&#9;end
&#9;
&#9;ToolCurrentlyEquipped = true
&#9;
&#9;if PlayerGui then
&#9;&#9;NoteGuiClone = NoteGui:Clone()
&#9;&#9;NoteGuiClone.CreateNote.Visible = true
&#9;&#9;NoteGuiClone.DriveNote.Visible = false
&#9;&#9;NoteGuiClone.FireNote.Visible = false
&#9;&#9;NoteGuiClone.Parent = PlayerGui
&#9;end
&#9;&#9;
end

function Unequipped()
&#9;if NoteGuiClone and NoteGuiClone.Parent then
&#9;&#9;NoteGuiClone:Destroy()
&#9;end
&#9;if Tank and Tank.Model and Tank.Model.Parent then
&#9;&#9;Tank.Model:Destroy()
&#9;end
&#9;for i, v in pairs({TankControl, ToolUnequipped}) do
&#9;&#9;if v then
&#9;&#9;&#9;v:disconnect()
&#9;&#9;end
&#9;end
&#9;IsPlayingDrive = false
&#9;LastDrivingTime = 0
&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraType&quot;, Value = Enum.CameraType.Custom})
&#9;InvokeClient(&quot;SetCamera&quot;, {Property = &quot;CameraSubject&quot;, Value = Character})
&#9;InvokeClient(&quot;PreventJump&quot;, false)
&#9;if Humanoid and Humanoid.Parent then
&#9;&#9;Humanoid.WalkSpeed = 16
&#9;end
&#9;ToolCurrentlyEquipped = false
end

Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBX20B9232A0F6944588A4FD471F032AAEB">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Remover</string>
					<ProtectedString name="Source">--Made by Luckymaxer

Debris = game:GetService(&quot;Debris&quot;)

Creator = script:FindFirstChild(&quot;Creator&quot;)
Tool = script:FindFirstChild(&quot;Tool&quot;)
Model = script:WaitForChild(&quot;Model&quot;)

function DestroyModel()
&#9;if Model and Model.Parent then
&#9;&#9;Debris:AddItem(Model, 2)
&#9;end
&#9;Debris:AddItem(script, 2)
end

if not Creator or not Creator.Value or not Creator.Value:IsA(&quot;Player&quot;) or not Creator.Value.Parent or not Tool or not Tool.Value or not Tool.Value.Parent or not Model or not Model.Value then
&#9;DestroyModel()
&#9;return
end

Creator = Creator.Value
Tool = Tool.Value
Model = Model.Value

Character = Creator.Character
if not Character then
&#9;DestroyModel()
&#9;return
end

Creator.Changed:connect(function(Property)
&#9;if Property == &quot;Parent&quot; and not Creator.Parent then
&#9;&#9;DestroyModel()
&#9;end
end)

Character.Changed:connect(function(Property)
&#9;if Property == &quot;Parent&quot; and not Character.Parent then
&#9;&#9;DestroyModel()
&#9;end
end)

Tool.Changed:connect(function(Property)
&#9;if Property == &quot;Parent&quot; then
&#9;&#9;DestroyModel()
&#9;end
end)

Model.Changed:connect(function(Property)
&#9;if Property == &quot;Parent&quot; and not Model.Parent then
&#9;&#9;DestroyModel()
&#9;end
end)</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX891E711B1C764AC09D07F9D04ED2DA2F">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent
Handle = Tool:WaitForChild(&quot;Handle&quot;)

Players = game:GetService(&quot;Players&quot;)
ContentProvider = game:GetService(&quot;ContentProvider&quot;)
RunService = game:GetService(&quot;RunService&quot;)

Camera = game:GetService(&quot;Workspace&quot;).CurrentCamera

Animations = {}

ServerControl = Tool:WaitForChild(&quot;ServerControl&quot;)
ClientControl = Tool:WaitForChild(&quot;ClientControl&quot;)

Equipped = false

ClientControl.OnClientInvoke = (function(Mode, Value)
&#9;if Mode == &quot;PlayAnimation&quot; and Value and Equipped and Humanoid then
&#9;&#9;SetAnimation(&quot;PlayAnimation&quot;, Value)
&#9;elseif Mode == &quot;StopAnimation&quot; and Value then
&#9;&#9;SetAnimation(&quot;StopAnimation&quot;, Value)
&#9;elseif Mode == &quot;Preload&quot; and Value then
&#9;&#9;ContentProvider:Preload(Value)
&#9;elseif Mode == &quot;PlaySound&quot; and Value then
&#9;&#9;Value:Play()
&#9;elseif Mode == &quot;StopSound&quot; and Value then
&#9;&#9;Value:Stop()
&#9;elseif Mode == &quot;MousePosition&quot; then
&#9;&#9;return PlayerMouse.Hit.p
&#9;elseif Mode == &quot;DisableJump&quot; then
&#9;&#9;DisableJump(Value)
&#9;elseif Mode == &quot;SetMouseIcon&quot; and Value then
&#9;&#9;PlayerMouse.Icon = Value
&#9;elseif Mode == &quot;SetLocalTransparencyModifier&quot; and Value then
&#9;&#9;pcall(function()
&#9;&#9;&#9;Value.Object.LocalTransparencyModifier = Value.Transparency
&#9;&#9;end)
&#9;elseif Mode == &quot;GetCamera&quot; and Value then
&#9;&#9;local PropertyValue = nil
&#9;&#9;if Value.Property then
&#9;&#9;&#9;pcall(function()
&#9;&#9;&#9;&#9;PropertyValue = Camera[Value.Property]
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;return PropertyValue
&#9;elseif Mode == &quot;SetCamera&quot; and Value then
&#9;&#9;if Value.Property and Value.Value then
&#9;&#9;&#9;pcall(function()
&#9;&#9;&#9;&#9;Camera[Value.Property] = Value.Value
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;elseif Mode == &quot;SetMouseSensitivity&quot; and Value then
&#9;&#9;if Value.Sensitivity == 1 then
&#9;&#9;&#9;if MouseSensivityConnection then
&#9;&#9;&#9;&#9;MouseSensivityConnection:disconnect()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;SetMouseSensitivity(Value.Sensitivity)
&#9;&#9;end
&#9;end
end)

function InvokeServer(Mode, Value)
&#9;pcall(function()
&#9;&#9;local ServerReturn = ServerControl:InvokeServer(Mode, Value)
&#9;&#9;return ServerReturn
&#9;end)
end

function SetAnimation(Mode, Value)
&#9;if Mode == &quot;PlayAnimation&quot; and Value and Equipped and Humanoid then
&#9;&#9;for i, v in pairs(Animations) do
&#9;&#9;&#9;if v.Animation == Value.Animation then
&#9;&#9;&#9;&#9;v.AnimationTrack:Stop()
&#9;&#9;&#9;&#9;table.remove(Animations, i)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local AnimationTrack = Humanoid:LoadAnimation(Value.Animation)
&#9;&#9;table.insert(Animations, {Animation = Value.Animation, AnimationTrack = AnimationTrack})
&#9;&#9;AnimationTrack:Play(Value.FadeTime, Value.Weight, Value.Speed)
&#9;elseif Mode == &quot;StopAnimation&quot; and Value then
&#9;&#9;for i, v in pairs(Animations) do
&#9;&#9;&#9;if v.Animation == Value.Animation then
&#9;&#9;&#9;&#9;v.AnimationTrack:Stop()
&#9;&#9;&#9;&#9;table.remove(Animations, i)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function DisableJump(Boolean)
&#9;if PreventJump then
&#9;&#9;PreventJump:disconnect()
&#9;end
&#9;if Boolean then
&#9;&#9;PreventJump = Humanoid.Changed:connect(function(Property)
&#9;&#9;&#9;if Property ==  &quot;Jump&quot; then
&#9;&#9;&#9;&#9;Humanoid.Jump = false
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end
end

function SetMouseSensitivity(Sensitivity)

&#9;if MouseSensivityConnection then
&#9;&#9;MouseSensivityConnection:disconnect()
&#9;end&#9;
&#9;
&#9;local function EulerAnglesYX(cframe)
&#9;&#9;local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:components(cframe)
&#9;&#9;return -math.asin(R12), ((math.abs(R12) &gt; 0.99999 and -math.atan2(-R20, R00)) or -math.atan2(-R02, R22))
&#9;end
&#9;
&#9;local DirectionX, DirectionY = EulerAnglesYX(Camera.CoordinateFrame)
&#9;
&#9;local function UpdateSensitivity()
&#9;&#9;local CFrameX, CFrameY = EulerAnglesYX(Camera.CoordinateFrame)
&#9;&#9;DirectionX = (DirectionX * (1 - Sensitivity) + (CFrameX + (math.pi * 2) * math.floor((DirectionX - CFrameX) / (math.pi * 2) + 0.5)) * Sensitivity)
&#9;&#9;DirectionY = (DirectionY * (1 - Sensitivity) + (CFrameY + (math.pi * 2) * math.floor((DirectionY - CFrameY) / (math.pi * 2) + 0.5)) * Sensitivity)
&#9;&#9;Camera.CoordinateFrame = CFrame.Angles(0, DirectionY, 0) * CFrame.Angles(DirectionX, 0, 0) * CFrame.new(0, 0, 0.5) + Camera.Focus.p
&#9;end
&#9;
&#9;MouseSensivityConnection = RunService.RenderStepped:connect(UpdateSensitivity)
&#9;
end

function CheckIfAlive()
&#9;return (Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health &gt; 0)
end

function Equipped(Mouse)
&#9;Character = Tool.Parent
&#9;Player = Players:GetPlayerFromCharacter(Character)
&#9;Humanoid = Character:FindFirstChild(&quot;Humanoid&quot;)
&#9;Equipped = true
&#9;if not CheckIfAlive() then
&#9;&#9;return
&#9;end
&#9;PlayerMouse = Player:GetMouse()
&#9;Mouse.Button1Down:connect(function()
&#9;&#9;InvokeServer(&quot;MouseClick&quot;, {Down = true})
&#9;end)
&#9;Mouse.Move:connect(function()
&#9;&#9;InvokeServer(&quot;MouseMove&quot;, {Target = Mouse.Target, Position = Mouse.Hit.p})
&#9;end)
&#9;Mouse.KeyDown:connect(function(Key)
&#9;&#9;InvokeServer(&quot;KeyPress&quot;, {Key = Key, Down = true})
&#9;end)
&#9;Mouse.KeyUp:connect(function(Key)
&#9;&#9;InvokeServer(&quot;KeyPress&quot;, {Key = Key, Down = false})
&#9;end)
&#9;Mouse.WheelForward:connect(function()
&#9;&#9;InvokeServer(&quot;WheelMoved&quot;, {Forward = true})
&#9;end)
&#9;Mouse.WheelBackward:connect(function()
&#9;&#9;InvokeServer(&quot;WheelMoved&quot;, {Forward = false})
&#9;end)
end

function Unequipped()
&#9;Equipped = false
&#9;for i, v in pairs(Animations) do
&#9;&#9;if v and v.AnimationTrack then
&#9;&#9;&#9;v.AnimationTrack:Stop()
&#9;&#9;end
&#9;end
&#9;for i, v in pairs({PreventJump, MouseSensivityConnection}) do
&#9;&#9;if v then
&#9;&#9;&#9;v:disconnect()
&#9;&#9;end
&#9;end
&#9;PlayerMouse.Icon = &quot;&quot;
&#9;Animations = {}
end

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX6CF899E76F0949078BA89282CB95A183">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<ProtectedString name="Source">--Made by Luckymaxer

Tool = script.Parent

Players = game:GetService(&quot;Players&quot;)

Player = Players.LocalPlayer

Icons = {
&#9;Normal = &quot;rbxasset://textures/GunCursor.png&quot;,
&#9;Reloading = &quot;rbxasset://textures/GunWaitCursor.png&quot;
}

ToolEquipped = false

function UpdateIcon()
&#9;if Mouse and ToolEquipped then
&#9;&#9;Mouse.Icon = (((Tool.Enabled and (Mouse.Icon == Icons.Reloading or Mouse.Icon == &quot;&quot;)) and Icons.Normal) or ((not Tool.Enabled and (Mouse.Icon == Icons.Normal or Mouse.Icon == &quot;&quot;)) and Icons.Reloading) or Mouse.Icon)
&#9;end
end

function Equipped()
&#9;ToolEquipped = true
&#9;Mouse = Player:GetMouse()
&#9;MouseChanged = Mouse.Changed:connect(Changed)
&#9;UpdateIcon()
end

function Unequipped()
&#9;ToolEquipped = false
&#9;Mouse.Icon = &quot;&quot;
&#9;if MouseChanged then
&#9;&#9;MouseChanged:disconnect()
&#9;end
end

function Changed(Property)
&#9;if Property == &quot;Enabled&quot; or (Property == &quot;Icon&quot; and Mouse.Icon == &quot;&quot;) then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Changed:connect(Changed)

Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX3766976AC87342C5942116D202E0625F">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-0.007853508</X>
					<Y>17.3634109</Y>
					<Z>22.1025734</Z>
					<R00>-0.66572535</R00>
					<R01>-0.0181267522</R01>
					<R02>0.745976746</R02>
					<R10>-1.3737448e-014</R10>
					<R11>0.999704897</R11>
					<R12>0.0242921822</R12>
					<R20>-0.746196926</R20>
					<R21>0.016171921</R21>
					<R22>-0.665528893</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>1.20000005</Y>
					<Z>6</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX39949A10B3404869A8A54B42E5C2CAC9">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=82934522</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=177480340 </url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Camera" referent="RBX218CF6C879E7489B90CF380323FF2B80">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-4.52742004</X>
					<Y>17.3755627</Y>
					<Z>23.927166</Z>
					<R00>-0.279558867</R00>
					<R01>0.599889636</R01>
					<R02>-0.749652743</R02>
					<R10>-1.49011612e-008</R10>
					<R11>0.780783713</R11>
					<R12>0.624801397</R12>
					<R20>0.960128546</R20>
					<R21>0.174668789</R21>
					<R22>-0.218274996</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-3.02811408</X>
					<Y>16.1259594</Y>
					<Z>24.3637161</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>