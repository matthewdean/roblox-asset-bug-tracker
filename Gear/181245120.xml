<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBXB12BE286DB4A4EB2BDD1486A4BD8823E">
		<Properties>
			<bool name="CanBeDropped">false</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0.349999994</X>
				<Y>-0.5</Y>
				<Z>0.699999988</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">CandyBomb</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset?id=179628862</url></Content>
			<string name="ToolTip">Candy Bomb</string>
		</Properties>
		<Item class="Part" referent="RBXA5DE46AEF4F84AC2980C1D77BB2E3897">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>1.20500016</X>
					<Y>4.0999999</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">0</token>
				<token name="shape">0</token>
				<Vector3 name="size">
					<X>1.38999987</X>
					<Y>1.38999987</Y>
					<Z>1.38999987</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX7BFD9B2AEA124814996B523930A63B7D">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset?id=179628795</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset?id=179628830</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX79AADF1D3B2C4520B12873F1E5B3502A">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Boom</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX0AD93EE0CCC745F6AD2036D442F72075">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Beep</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94137771</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX917A9097ABEB4E698738D7B33ACE97D4">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CandyBombLocalScript</string>
				<ProtectedString name="Source">-- Made by SolarCrane

local RS = game:GetService(&apos;ReplicatedStorage&apos;)
local PlayersService = game:GetService(&quot;Players&quot;)

local Utility = require(RS:WaitForChild(&apos;Utility&apos;))
local Signal = require(RS:WaitForChild(&apos;Signal&apos;))
local CreateLocalWelder = require(RS:WaitForChild(&apos;LocalEquipWeld&apos;))



local LocalPlayer = PlayersService.LocalPlayer
local Character = nil
local Tool = script.Parent
local Handle = Tool:WaitForChild(&apos;Handle&apos;)

local RequestShootServer = Tool:WaitForChild(&apos;RequestShootServer&apos;)

local COOLDOWN = 4 -- Seconds until tool can be used again
local TIME_BEFORE_RELEASE = 0.3

local ThrowAnimTrack = nil
local HoldAnimTrack = nil
local LastShot = 0
local Equipped = false

-- Code from http://www.miguelcasillas.com/?p=53
local function RayDistanceFromSphereSurface(tRay, sphereCenter, radius)
    -- Create a vector from the ray&apos;s start to the sphere&apos;s center
    local vecV1 = sphereCenter - tRay.Origin

    -- Project this vector onto the ray&apos;s direction vector
    local fD = vecV1:Dot(tRay.Direction.unit)

    -- If the ray is pointing away
    if fD &lt; 0 then
        return math.huge, math.rad(360)
&#9;end

    -- Calculate the closest point to the sphere on the ray
    local vecClosestPoint = tRay.Origin + (tRay.Direction.unit * fD)

&#9;local distanceToSphereSurface = math.max(0, ((sphereCenter - vecClosestPoint).magnitude - radius))

&#9;local angle = math.acos((vecClosestPoint - tRay.Origin).unit:Dot(tRay.Direction.unit))
&#9;if angle == nil then
&#9;&#9;angle = math.rad(360) 
&#9;end
    return distanceToSphereSurface, angle
end


local function FindMonsterAlongRay(ray)
&#9;local monstersByDistance = {}
&#9;local monsterContainer = workspace:FindFirstChild(&quot;MonsterContainer&quot;)
&#9;--local monsterContainer = workspace:FindFirstChild(&quot;TestDummies&quot;)
&#9;if monsterContainer then
&#9;&#9;for _, monster in pairs(monsterContainer:GetChildren()) do
&#9;&#9;&#9;if monster:IsA(&apos;Model&apos;) then
&#9;&#9;&#9;&#9;local monsterCFrame = monster:GetModelCFrame()
&#9;&#9;&#9;&#9;local monsterSize = monster:GetExtentsSize()
&#9;&#9;&#9;&#9;local distance, theta = RayDistanceFromSphereSurface(ray, monsterCFrame.p, math.min(math.min(monsterSize.X, monsterSize.Y), monsterSize.Z)) --monsterSize.magnitude)
&#9;&#9;&#9;&#9;table.insert(monstersByDistance, {Monster = monster; Distance = distance; Theta = theta})
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;-- TODO: also sort by distance from player in this heuristic
&#9;table.sort(monstersByDistance, function(a,b) return a[&apos;Distance&apos;] &lt; b[&apos;Distance&apos;] end)
&#9;return monstersByDistance
end

local function GetShootOrigin()
&#9;return Handle.CFrame.p
end

local function OnMouseDownChanged(down)
&#9;--wait(0) --TODO: Remove when Mouse.Hit and Humanoid.TargetPoint update properly on iPad
&#9;local now = tick()
&#9;if now - LastShot &lt; COOLDOWN then
&#9;&#9;return
&#9;end
&#9;if Equipped and Handle and Utility.CanFire(LocalPlayer) then
&#9;&#9;if down then -- Player just clicked
&#9;&#9;&#9;if HoldAnimTrack then
&#9;&#9;&#9;&#9;HoldAnimTrack:Play(.1,1,1)
&#9;&#9;&#9;end
&#9;&#9;else -- Player just released click
&#9;&#9;&#9;local humanoid = Utility.GetHumanoid(LocalPlayer)
&#9;&#9;&#9;local targetPos = humanoid and humanoid.TargetPoint
&#9;&#9;&#9;local shootOrigin = targetPos and GetShootOrigin(targetPos)
&#9;&#9;&#9;local shootDirection = targetPos and shootOrigin and (targetPos - shootOrigin)
&#9;&#9;&#9;
&#9;&#9;&#9;if targetPos and shootOrigin and shootDirection then
&#9;&#9;&#9;&#9;local shootRay = Ray.new(shootOrigin, shootDirection)
&#9;&#9;
&#9;&#9;&#9;&#9;local monsters = FindMonsterAlongRay(shootRay)
&#9;&#9;&#9;&#9;local desiredShootTarget = monsters and monsters[1] and monsters[1][&apos;Monster&apos;]
&#9;&#9;&#9;&#9;local desiredShootTargetPos = desiredShootTarget and desiredShootTarget:GetModelCFrame().p
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if HoldAnimTrack then
&#9;&#9;&#9;&#9;&#9;HoldAnimTrack:Stop()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if ThrowAnimTrack then
&#9;&#9;&#9;&#9;&#9;ThrowAnimTrack:Play(0.1,1,0.75)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;spawn(function()
&#9;&#9;&#9;&#9;&#9;local projectile = RequestShootServer:InvokeServer(shootRay, tick() + (_G.ClientTimeDiff or 0), desiredShootTarget, desiredShootTargetPos)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;LastShot = now
&#9;&#9;&#9;Tool.Enabled = false
&#9;&#9;&#9;delay(COOLDOWN - (tick() - LastShot), function()
&#9;&#9;&#9;&#9;Tool.Enabled = true
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
end

local mouseButton1DownConn = nil
local mouseButton1UpConn = nil

local function DisconnectMouseEvents()
&#9;if mouseButton1DownConn then
&#9;&#9;mouseButton1DownConn:disconnect()
&#9;end
&#9;if mouseButton1UpConn then
&#9;&#9;mouseButton1UpConn:disconnect()
&#9;end
end

local function OnEquipped(mouse)
&#9;Equipped = true
&#9;local Character = LocalPlayer and LocalPlayer.Character
&#9;DisconnectMouseEvents()
&#9;mouseButton1DownConn = mouse.Button1Down:connect(function() OnMouseDownChanged(true) end)
&#9;mouseButton1UpConn = mouse.Button1Up:connect(function() OnMouseDownChanged(false) end)
&#9;local humanoid = Utility.GetHumanoid(LocalPlayer)
&#9;if humanoid then
&#9;&#9;local ThrowAnim = Tool:FindFirstChild(&apos;Throw&apos;)
&#9;&#9;local HoldAnim = Tool:FindFirstChild(&apos;Hold&apos;)&#9;&#9;
&#9;&#9;
&#9;&#9;ThrowAnimTrack = ThrowAnim and humanoid:LoadAnimation(ThrowAnim)
&#9;&#9;HoldAnimTrack = HoldAnim and humanoid:LoadAnimation(HoldAnim)
&#9;end
end

local function OnUnequipped()
&#9;Equipped = false
&#9;OnMouseDownChanged(false)
&#9;DisconnectMouseEvents()
&#9;if HoldAnimTrack then
&#9;&#9;HoldAnimTrack:Stop()
&#9;end
&#9;if ThrowAnimTrack then
&#9;&#9;ThrowAnimTrack:Stop()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

CreateLocalWelder(Tool)

print&quot;LocalBombLoaded&quot;
</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBXBA298164050B4DD48C5911FCD87BEE8A">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MouseIcon</string>
				<ProtectedString name="Source">local MOUSE_ICON = &apos;rbxasset://textures/GunCursor.png&apos;
local RELOADING_ICON = &apos;rbxasset://textures/GunWaitCursor.png&apos;

local Tool = script.Parent

local Mouse = nil

local function UpdateIcon()
&#9;Mouse.Icon = Tool.Enabled and MOUSE_ICON or RELOADING_ICON
end

local function OnEquipped(mouse)
&#9;Mouse = mouse
&#9;UpdateIcon()
end

local function OnChanged(property)
&#9;if property == &apos;Enabled&apos; then
&#9;&#9;UpdateIcon()
&#9;end
end

Tool.Equipped:connect(OnEquipped)
Tool.Changed:connect(OnChanged)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Animation" referent="RBX630C285FF2994633893107DF6C03C757">
			<Properties>
				<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861246</url></Content>
				<string name="Name">Hold</string>
			</Properties>
		</Item>
		<Item class="Animation" referent="RBX0655FBF4E2C5447F8D63F63FF9E19387">
			<Properties>
				<Content name="AnimationId"><url>http://www.roblox.com/Asset?ID=94861252</url></Content>
				<string name="Name">Throw</string>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXC11E35A94C384C74B6CF575BB32265D9">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CandyBombServerScript</string>
				<ProtectedString name="Source">-- Made by SolarCrane

local RS = game:GetService(&apos;ReplicatedStorage&apos;)
local PlayersService = game:GetService(&quot;Players&quot;)
local Debris = game:GetService(&apos;Debris&apos;)

local Utility = require(RS:WaitForChild(&apos;Utility&apos;))
local Signal = require(RS:WaitForChild(&apos;Signal&apos;))

local SHOOT_VELOCITY = 80
local DEBRIS_TIME = 6
local COOLDOWN = 4 -- Seconds until tool can be used again
local TIME_BEFORE_RELEASE = 0.2

local LastShot = 0
local Equipped = false
local MyPlayer = nil
local Character = nil
local Tool = script.Parent
local Handle = Tool:WaitForChild(&apos;Handle&apos;)

local BeepSound = Handle:WaitForChild(&apos;Beep&apos;)
local BoomSound = Handle:WaitForChild(&apos;Boom&apos;)

local ThrowAnimTrack = nil
local HoldAnimTrack = nil

local BOMB_MESHID = &apos;http://www.roblox.com/asset?id=179628795&apos;
local BOMB_TXID = &apos;http://www.roblox.com/asset?id=179628830&apos;

local BombPrefabScript = script:WaitForChild(&apos;CandyBombExplosionScript&apos;)

local RequestShootServer = Tool:WaitForChild(&apos;RequestShootServer&apos;)

-- Pure functional
local function MakeBaseBomb(myPlayer, bombMesh, bombTexture)
&#9;local bomb = Utility.Create&apos;Part&apos;
&#9;{
&#9;&#9;Name = &apos;Bomb&apos;;
&#9;&#9;TopSurface = &apos;Smooth&apos;;
&#9;&#9;BottomSurface = &apos;Smooth&apos;;
&#9;&#9;CanCollide = false;
&#9;&#9;RotVelocity = Vector3.new(Utility.Random(-math.pi,math.pi),
&#9;&#9;                          Utility.Random(-math.pi,math.pi),
&#9;&#9;                          Utility.Random(-math.pi,math.pi)) * 2;
&#9;&#9;Utility.Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;MeshId = bombMesh;
&#9;&#9;&#9;TextureId = bombTexture;
&#9;&#9;&#9;Scale = Vector3.new(1,1,1);
&#9;&#9;};
&#9;}
&#9;bomb.Shape = Enum.PartType.Ball
&#9;bomb.FormFactor = &apos;Custom&apos;&#9;
&#9;bomb.Size = Vector3.new(1.5, 1.5, 1.5)
&#9;Utility.Create&apos;BodyForce&apos;
&#9;{
&#9;&#9;Name = &quot;FloatForce&quot;;
&#9;&#9;force = Vector3.new(0, bomb:GetMass() * 196.2 * 0.25, 0);
&#9;&#9;Parent = bomb;
&#9;}

&#9;-- Attach creator tags to the bomb early on
&#9;local creatorTag = Instance.new(&apos;ObjectValue&apos;, bomb)
&#9;creatorTag.Name = &apos;creator&apos;
&#9;creatorTag.Value = myPlayer

&#9;return bomb
end

local function GetShootOrigin()
&#9;return Handle.CFrame.p
end


local function OnShoot(player, desiredShootRay, localTime, desiredTarget, desiredTargetPosition)
&#9;-- Someone else is trying to call shoot on my weapon; GET DENIED
&#9;if player ~= MyPlayer then return end
&#9;
&#9;local now = tick()
&#9;if now - LastShot &lt; COOLDOWN then
&#9;&#9;return
&#9;end
&#9;local timeDiff = (tick() - localTime)
&#9;local timeToWait = Utility.Clamp(0, TIME_BEFORE_RELEASE, TIME_BEFORE_RELEASE - timeDiff)
&#9;wait(timeToWait) -- wait for before release, syncing up to our round-trip-time to make it looks smooth back on the local client.
&#9;if Equipped and Handle and Utility.CanFire(MyPlayer) then
&#9;&#9;-- TODO: Add handle velocity to the velocity?
&#9;&#9;local adjustedShootVector = desiredShootRay.Direction
&#9;&#9;local shootOrigin = GetShootOrigin()
&#9;&#9;if shootOrigin then
&#9;&#9;&#9;if desiredTarget and desiredTargetPosition then
&#9;&#9;&#9;&#9;local deltaOffset = desiredTarget:GetModelCFrame().p - desiredTargetPosition
&#9;&#9;&#9;&#9;adjustedShootVector = adjustedShootVector.unit * (desiredTargetPosition - shootOrigin).magnitude
&#9;&#9;&#9;&#9;adjustedShootVector = adjustedShootVector + deltaOffset
&#9;&#9;&#9;&#9;if adjustedShootVector.magnitude == 0 then
&#9;&#9;&#9;&#9;&#9;adjustedShootVector = Vector3.new(0, 1, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local projectile = MakeBaseBomb(MyPlayer, BOMB_MESHID, BOMB_TXID)
&#9;&#9;&#9;projectile.CFrame = CFrame.new(shootOrigin)
&#9;&#9;&#9;projectile.Velocity = adjustedShootVector.unit * SHOOT_VELOCITY

&#9;&#9;&#9;projectile.CanCollide = false
&#9;&#9;&#9;-- this way the projectile doesn&apos;t hit our character; unfortunately it means it doesn&apos;t hit a lot of things.
&#9;&#9;&#9;local touchConn = projectile.Touched:connect(function(other)
&#9;&#9;&#9;&#9;if Character and other then
&#9;&#9;&#9;&#9;&#9;if other.CanCollide == true and not other:IsDescendantOf(Character) then
&#9;&#9;&#9;&#9;&#9;&#9;projectile.CanCollide = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;delay(0.2, function() projectile.CanCollide = true touchConn:disconnect() end)
&#9;&#9;&#9;
&#9;&#9;&#9;Debris:AddItem(projectile, DEBRIS_TIME)
&#9;&#9;&#9;projectile.Parent = workspace
&#9;&#9;&#9;
&#9;&#9;&#9;BeepSound:Clone().Parent = projectile
&#9;&#9;&#9;BoomSound:Clone().Parent = projectile&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;local bombScript = BombPrefabScript:Clone()
&#9;&#9;&#9;bombScript.Parent = projectile
&#9;&#9;&#9;bombScript.Disabled = false
&#9;&#9;&#9;
&#9;&#9;&#9;LastShot = now
&#9;&#9;&#9;return projectile
&#9;&#9;end
&#9;end
end

local function OnEquipped()
&#9;Equipped = true
&#9;Character = Tool.Parent
&#9;if Character then
&#9;&#9;MyPlayer = PlayersService:GetPlayerFromCharacter(Character)
&#9;end
end

local function OnUnequipped()
&#9;Equipped = false
end

--------------------
--| Script Logic |--
--------------------

RequestShootServer.OnServerInvoke = OnShoot

Tool.Equipped:connect(OnEquipped)
Tool.Unequipped:connect(OnUnequipped)

print&quot;ServeBombLoaded&quot;
</ProtectedString>
			</Properties>
			<Item class="Script" referent="RBXE989766986B84984B26E77A9DEB0E3C1">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CandyBombExplosionScript</string>
					<ProtectedString name="Source">-----------------
--| Constants |--
-----------------

local FORCE_GRANULARITY = 2
local RADIUS_FACTOR = 0.75

local BLAST_RADIUS = 13
local BLAST_PRESSURE = 1000000 * FORCE_GRANULARITY

-----------------
--| Variables |--
-----------------

local DebrisService = game:GetService(&apos;Debris&apos;)
local ServerScriptService = game:GetService(&apos;ServerScriptService&apos;)

local TimeBomb = script.Parent

local BombMesh = TimeBomb:WaitForChild(&apos;Mesh&apos;)

local BoomSound = TimeBomb:WaitForChild(&apos;Boom&apos;)
local BeepSound = TimeBomb:WaitForChild(&apos;Beep&apos;)

local CreatorTag = TimeBomb:WaitForChild(&apos;creator&apos;)


local MonsterContainer = workspace:WaitForChild(&quot;MonsterContainer&quot;)
local MonsterManager = require(ServerScriptService.MonsterManager)

local Connection = nil
local XGraceDistance = 2.5
local YGraceDistance = 2.5

local doBlastBack = false

-----------------
--| Functions |--
-----------------


-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
&#9;if subject and subject ~= workspace then
&#9;&#9;local humanoid = subject:FindFirstChild(&apos;Humanoid&apos;)
&#9;&#9;if humanoid then
&#9;&#9;&#9;return subject, humanoid
&#9;&#9;else
&#9;&#9;&#9;return FindCharacterAncestor(subject.Parent)
&#9;&#9;end
&#9;end
&#9;return nil
end


local function cl0(n)
&#9;return (n &gt; 0) and n or 0
end
local abs = math.abs
local function RealDistanceFrom(point, part)
&#9;local p = part.CFrame:vectorToObjectSpace(point-part.Position)
&#9;local hz = part.Size/2
&#9;local sep = Vector3.new(cl0(abs(p.x)-hz.x), cl0(abs(p.y)-hz.y), cl0(abs(p.z)-hz.z))
&#9;return sep.magnitude
end


local function TryDoDamage(humanoid, damage)
&#9;local hitBindable = humanoid:FindFirstChild(&apos;Hit&apos;)
&#9;local wasAlive = humanoid.Health &gt; 0
&#9;if hitBindable then
&#9;&#9;hitBindable:Invoke(damage, CreatorTag)
&#9;else
&#9;&#9;humanoid:TakeDamage(damage)
&#9;&#9;MonsterManager:TagPlayerCollection(CreatorTag.Value, humanoid)
&#9;end
end


-- Needless to say, this should only be called once
local Exploded = false
local function Explode()
&#9;if Exploded then
&#9;&#9;return
&#9;end
&#9;Exploded = true
&#9;if Connection then
&#9;&#9;Connection:disconnect()
&#9;end
&#9;local damagedMonsterSet = {}
&#9;local function onExplosionHit(p, r)
&#9;&#9;local isInCharacter = false
&#9;&#9;if p.Size.magnitude/2 &lt; 20 then
&#9;&#9;&#9;--world-&gt;ticklePrimitive(p, true);
&#9;&#9;&#9;
&#9;&#9;&#9;local doBreakjoints = false
&#9;&#9;&#9;local hitCharacter, hitHumanoid = FindCharacterAncestor(p)
&#9;&#9;&#9;if hitCharacter then
&#9;&#9;&#9;&#9;-- flag as character
&#9;&#9;&#9;&#9;isInCharacter = true&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- don&apos;t breakjoints characters
&#9;&#9;&#9;&#9;doBreakjoints = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- work out what damage to do&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local hitPlayer = game.Players:GetPlayerFromCharacter(hitCharacter)
&#9;&#9;&#9;&#9;local hitMonster = MonsterContainer and hitCharacter:IsDescendantOf(MonsterContainer) and hitCharacter
&#9;&#9;&#9;&#9;local myPlayer = CreatorTag.Value
&#9;&#9;&#9;&#9;if hitMonster and not damagedMonsterSet[hitMonster] then&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- how much damage to do
&#9;&#9;&#9;&#9;&#9;local damageFrac;
&#9;&#9;&#9;&#9;&#9;if r &lt; BLAST_RADIUS/2 then
&#9;&#9;&#9;&#9;&#9;&#9;damageFrac = 1
&#9;&#9;&#9;&#9;&#9;elseif r &lt; BLAST_RADIUS then
&#9;&#9;&#9;&#9;&#9;&#9;damageFrac = 1 - (r - BLAST_RADIUS/2)/(BLAST_RADIUS/2)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;damageFrac = 0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- flag as hit
&#9;&#9;&#9;&#9;&#9;damagedMonsterSet[hitMonster] = true
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- do damage. See how much damage to do&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;TryDoDamage(hitHumanoid, 30 + 70*damageFrac)
&#9;&#9;&#9;&#9;&#9;--print(&quot;Doing damage to:&quot; , hitMonster , &quot;of damage:&quot; , 30 + 70*damageFrac)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;
&#9;&#9;&#9;-- breakjoints stuff
&#9;&#9;&#9;if doBreakjoints then
&#9;&#9;&#9;&#9;-- Don&apos;t breakjoints stuff too far away to reduce lag
&#9;&#9;&#9;&#9;if RealDistanceFrom(TimeBomb.Position, p) &gt; BLAST_RADIUS*RADIUS_FACTOR then
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;p:BreakJoints()
&#9;&#9;&#9;end
&#9;&#9;&#9;if doBlastBack then
&#9;&#9;&#9;&#9;--Vector3 delta = (p-&gt;getCoordinateFrame().translation - position);
&#9;&#9;&#9;&#9;local delta = p.Position - TimeBomb.Position
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--Vector3 normal = 
&#9;&#9;&#9;&#9;--&#9;(delta == Vector3::zero())
&#9;&#9;&#9;&#9;--&#9;? Vector3::unitY()
&#9;&#9;&#9;&#9;--&#9;: delta.direction();
&#9;&#9;&#9;&#9;local normal = (delta == Vector3.new(0,0,0))
&#9;&#9;&#9;&#9;               and Vector3.new(0,1,0)
&#9;&#9;&#9;&#9;               or  delta.unit
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--float radius = p-&gt;getRadius();
&#9;&#9;&#9;&#9;local radius = p.Size.magnitude / 2&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--float surfaceArea = radius * radius;
&#9;&#9;&#9;&#9;local surfaceArea = radius * radius
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--Vector3 impulse = normal * blastPressure * surfaceArea * (1.0f / 4560.0f); // normalizing factor
&#9;&#9;&#9;&#9;local impulse = normal * BLAST_PRESSURE * surfaceArea * (1.0 / 4560.0)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- How much force to apply (for characters, ramp it down towards the edge)
&#9;&#9;&#9;&#9;local frac;
&#9;&#9;&#9;&#9;if isInCharacter then
&#9;&#9;&#9;&#9;&#9;frac = 1 - math.max(0, math.min(1, (r-2)/BLAST_RADIUS))
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;frac = 1
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--p-&gt;getBody()-&gt;accumulateLinearImpulse(impulse, p-&gt;getCoordinateFrame().translation);
&#9;&#9;&#9;&#9;local currentVelocity = p.Velocity
&#9;&#9;&#9;&#9;local deltaVelocity = impulse / p:GetMass() -- m * del-v = F * del-t = Impulse
&#9;&#9;&#9;&#9;local bodyV = Instance.new(&apos;BodyVelocity&apos;, p)
&#9;&#9;&#9;&#9;bodyV.velocity = currentVelocity + deltaVelocity
&#9;&#9;&#9;&#9;local forceNeeded = 196.2 * p:GetMass() -- F = ma
&#9;&#9;&#9;&#9;bodyV.maxForce = Vector3.new(forceNeeded, forceNeeded, forceNeeded) * 10 * frac
&#9;&#9;&#9;&#9;game.Debris:AddItem(bodyV, 0.2/FORCE_GRANULARITY)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;--p-&gt;getBody()-&gt;accumulateRotationalImpulse(impulse * 0.5 * radius); // a somewhat arbitrary, but nice torque
&#9;&#9;&#9;&#9;local rotImpulse = impulse * 0.5 * radius
&#9;&#9;&#9;&#9;local currentRotVelocity = p.RotVelocity
&#9;&#9;&#9;&#9;local momentOfInertia = (2 * p:GetMass() * radius * radius / 5) -- moment of inertia = 2/5*m*r^2 (assuming roughly spherical)
&#9;&#9;&#9;&#9;local deltaRotVelocity = rotImpulse / momentOfInertia 
&#9;&#9;&#9;&#9;local rot = Instance.new(&apos;BodyAngularVelocity&apos;, p)
&#9;&#9;&#9;&#9;local torqueNeeded = 20 * momentOfInertia -- torque = r x F, want about alpha = 20 rad/s^2, alpha * P = torque
&#9;&#9;&#9;&#9;rot.maxTorque = Vector3.new(torqueNeeded, torqueNeeded, torqueNeeded) * 10 * frac
&#9;&#9;&#9;&#9;rot.angularvelocity = currentRotVelocity + deltaRotVelocity
&#9;&#9;&#9;&#9;game.Debris:AddItem(rot, 0.2/FORCE_GRANULARITY)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end&#9;

&#9;local explosion = Instance.new(&apos;Explosion&apos;)
&#9;explosion.BlastRadius = BLAST_RADIUS
&#9;explosion.BlastPressure = 0
&#9;explosion.Position = TimeBomb.Position
&#9;explosion.Hit:connect(onExplosionHit)
&#9;explosion.Parent = workspace

&#9;BoomSound:Play()

&#9;-- NOTE:
&#9;-- If we just destroyed the bomb at this point, the boom sound would be destroyed too,
&#9;-- so instead we will hide the bomb, keep it in the same spot, and schedule it for deletion

&#9;TimeBomb.Transparency = 1
&#9;TimeBomb.CanCollide = false
&#9;TimeBomb.Anchored = true
&#9;DebrisService:AddItem(TimeBomb, 3)
end

--------------------
--| Script Logic |--
--------------------

--Distance check to see if can collide should be true
--[[
spawn(function()
&#9;while not TimeBomb.CanCollide and ParentTorso.Value do
&#9;&#9;local TorsoPosition = ParentTorso.Value.CFrame.p
&#9;&#9;local XZOffset = TorsoPosition-Vector3.new(TimeBomb.CFrame.p.x,TorsoPosition.y,TimeBomb.CFrame.p.z)
&#9;&#9;if XZOffset.magnitude&gt;XGraceDistance or math.abs(TorsoPosition.y-TimeBomb.CFrame.p.y)&gt;YGraceDistance then
&#9;&#9;&#9;TimeBomb.CanCollide=true
&#9;&#9;end
&#9;&#9;wait(1/30)
&#9;end
end)
--]]

local Character = CreatorTag and CreatorTag.Value and CreatorTag.Value.Character

local touchConn = TimeBomb.Touched:connect(function(other)
&#9;if Character and other and TimeBomb then
&#9;&#9;if other.CanCollide == true and not other:IsDescendantOf(Character) then
&#9;&#9;&#9;TimeBomb.CanCollide = true
&#9;&#9;end
&#9;end
end)
delay(0.2, function()
&#9;if TimeBomb then TimeBomb.CanCollide = true end 
&#9;if touchConn then touchConn:disconnect() end
end)

Connection = TimeBomb.Touched:connect(function(other)
&#9;local hitCharacter, hitHumanoid = FindCharacterAncestor(other)
&#9;if hitCharacter and hitCharacter ~= CreatorTag.Value.Character then
&#9;&#9;print(&quot;HitCharacter&quot;)
&#9;&#9;local hitMonster = MonsterContainer and hitCharacter:IsDescendantOf(MonsterContainer)
&#9;&#9;if hitMonster then
&#9;&#9;&#9;print(&quot;HitMonster&quot;)
&#9;&#9;&#9;Explode()
&#9;&#9;end
&#9;end
end)

-- Flash red and beep increasingly fast for about 3 seconds
local tickTime = 0.4
local red = true
repeat
&#9;BombMesh.VertexColor = red and Vector3.new(1,0,0) or Vector3.new(1, 1, 1)
&#9;BeepSound:Play()
&#9;wait(tickTime)
&#9;red = not red
&#9;tickTime = tickTime * 0.9
until tickTime &lt; 0.1 or Exploded

Explode()
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="RemoteFunction" referent="RBX6B642AB2675445B0ABC6BF075E18DBFE">
			<Properties>
				<string name="Name">RequestShootServer</string>
			</Properties>
		</Item>
	</Item>
</roblox>