<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">false</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>-4.37113883e-008</R11>
				<R12>1</R12>
				<R20>0</R20>
				<R21>-1</R21>
				<R22>-4.37113883e-008</R22>
			</CoordinateFrame>
			<string name="Name">DragonBoStaff</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=73184333</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>30.3008232</X>
					<Y>4.61940908</Y>
					<Z>21.9703407</Z>
					<R00>0.111295462</R00>
					<R01>-0.993111134</R01>
					<R02>0.036654532</R02>
					<R10>-0.101492688</R10>
					<R11>0.0253319722</R11>
					<R12>0.994513273</R12>
					<R20>-0.988591135</R20>
					<R21>-0.114405088</R21>
					<R22>-0.0979741141</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>0.5</X>
					<Y>0.5</Y>
					<Z>7</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=72008503</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.75</X>
						<Y>1.75</Y>
						<Z>1.75</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=72008530</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<ProtectedString name="Source">local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

local function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

class&apos;Signal&apos;(function(this)
&#9;local mListeners = {}
&#9;local mWaitObject = Create&apos;BoolValue&apos;{}

&#9;function this:connect(func)
&#9;&#9;local connection = {}
&#9;&#9;function connection:disconnect()
&#9;&#9;&#9;mListeners[func] = nil
&#9;&#9;end
&#9;&#9;mListeners[func] = connection
&#9;&#9;return connection
&#9;end

&#9;function this:fire(...)
&#9;&#9;for func, conn in pairs(mListeners) do
&#9;&#9;&#9;func(...)
&#9;&#9;end
&#9;&#9;mWaitObject.Value = not mWaitObject.Value
&#9;end

&#9;function this:wait()
&#9;&#9;mWaitObject.Changed:wait()
&#9;end
end)

--[[
KeyframeCatcher
&#9;Detects when an AnimationTrack reaches a keyframe, then invokes a specified function corresponding to the keyframe.

&#9;CreateKeyframeCatcher(animation)
&#9;&#9;Returns a new KeyframeCatcher connected to `animation`, an AnimtionTrack.
&#9;KeyframeCatcher:SetCallbacks(callbacks)
&#9;&#9;`callbacks` can be a table of string/function pairs.
&#9;&#9;When the AnimationTrack reaches a keyframe, the function corresponding to the keyframe&apos;s name will be called.
&#9;&#9;Multiple functions can be invoked if the keyframe has multiple names, delimited by spaces, commas, or semi-colons.
&#9;&#9;For example, a keyframe with the name &quot;EndFlip StartKick&quot; will call &quot;EndFlip&quot; and &quot;StartKick&quot; (in that order).
&#9;&#9;`callbacks` can also be nil, which will disable the KeyframeCatcher.
]]
class&apos;KeyframeCatcher&apos;(function(def,animation)
&#9;local reach

&#9;function def:SetCallbacks(callbacks)
&#9;&#9;if reach then
&#9;&#9;&#9;reach:disconnect()
&#9;&#9;&#9;reach = nil
&#9;&#9;end
&#9;&#9;if type(callbacks) == &quot;table&quot; then
&#9;&#9;&#9;reach = animation.KeyframeReached:connect(function(keyframe)
&#9;&#9;&#9;&#9;for name in keyframe:gmatch(&quot;[^,;%s]+&quot;) do
&#9;&#9;&#9;&#9;&#9;local callback = callbacks[name]
&#9;&#9;&#9;&#9;&#9;if callback then
&#9;&#9;&#9;&#9;&#9;&#9;callback(animation)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
end)

--[[----------------------------------------------------------------------------
AnimationProvider
&#9;Manages animations.

&#9;CreateAnimationProvider(animations)
&#9;&#9;Returns a new AnimationProvider instance.
&#9;&#9;`animations` is a table containing identity/asset_id pairs.
&#9;&#9;`asset_id` may be a string (Content) or an integer.
&#9;AnimationProvider:LoadHumanoid(humanoid)
&#9;&#9;Loads the animations into `humanoid`.
&#9;AnimationProvider:GetAnimation(identity)
&#9;&#9;Returns an AnimationTrack.
&#9;&#9;May only be called after LoadHumanoid.
&#9;AnimationProvider:StopAnimations()
&#9;&#9;Stops all animations.
&#9;&#9;May only be called after LoadHumanoid.
&#9;AnimationProvider:PrepareKeyframeCatcher(identity,callbacks)
&#9;&#9;Prepares a KeyframeCatcher to load for `identity` once the hunmanoid loads.
]]
class&apos;AnimationProvider&apos;(function(def,anim_ids)
&#9;local animations = {}
&#9;local animationTracks = {}
&#9;local catcherCallbacks = {}
&#9;local keyframeCatchers = {}
&#9;local workingHumanoid

&#9;for name,id in pairs(anim_ids) do
&#9;&#9;animations[name] = Create&apos;Animation&apos;{
&#9;&#9;&#9;Name = name;
&#9;&#9;&#9;AnimationId = type(id) == &quot;number&quot; and (&quot;rbxassetid://&quot;..id) or id;
&#9;&#9;&#9;Archivable = false;
&#9;&#9;}
&#9;end

&#9;function def:LoadHumanoid(humanoid)
&#9;&#9;if humanoid ~= workingHumanoid then
&#9;&#9;&#9;workingHumanoid = humanoid
&#9;&#9;&#9;for name,anim in pairs(animations) do
&#9;&#9;&#9;&#9;local old_track = animationTracks[name]
&#9;&#9;&#9;&#9;if old_track then
&#9;&#9;&#9;&#9;&#9;old_track:Stop()
&#9;&#9;&#9;&#9;&#9;old_track:Destroy()
&#9;&#9;&#9;&#9;&#9;if keyframeCatchers[name] then
&#9;&#9;&#9;&#9;&#9;&#9;keyframeCatchers[name] = nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;animationTracks[name] = track
&#9;&#9;&#9;&#9;if catcherCallbacks[name] then
&#9;&#9;&#9;&#9;&#9;local catcher = CreateKeyframeCatcher(track)
&#9;&#9;&#9;&#9;&#9;keyframeCatchers[name] = catcher
&#9;&#9;&#9;&#9;&#9;catcher:SetCallbacks(catcherCallbacks[name])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function def:GetAnimation(name)
&#9;&#9;if not workingHumanoid then
&#9;&#9;&#9;error(&quot;GetAnimation: humanoid has not been loaded&quot;,2)
&#9;&#9;end
&#9;&#9;return animationTracks[name]
&#9;end

&#9;function def:StopAnimations()
&#9;&#9;for name,track in pairs(animationTracks) do
&#9;&#9;&#9;track:Stop()
&#9;&#9;end
&#9;end

&#9;function def:PrepareKeyframeCatcher(name,callbacks)
&#9;&#9;catcherCallbacks[name] = callbacks
&#9;&#9;if animationTracks[name] then
&#9;&#9;&#9;local catcher = keyframeCatchers[name]
&#9;&#9;&#9;if catcher then
&#9;&#9;&#9;&#9;catcher:SetCallbacks(callbacks)
&#9;&#9;&#9;elseif callbacks then
&#9;&#9;&#9;&#9;catcher = CreateKeyframeCatcher(animationTrack[name])
&#9;&#9;&#9;&#9;keyframeCatchers[name] = catcher
&#9;&#9;&#9;&#9;catcher:SetCallbacks(catcherCallbacks[name])
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- lazy get
&#9;setmetatable(def,{__index = animationTracks})
end)

class&apos;SoundProvider&apos;(function(def,sound_ids)
&#9;local sounds = {}

&#9;for name,id in pairs(sound_ids) do
&#9;&#9;sounds[name] = Create&apos;Sound&apos;{
&#9;&#9;&#9;Name = name;
&#9;&#9;&#9;SoundId = type(id) == &quot;number&quot; and (&quot;rbxassetid://&quot;..id) or id;
&#9;&#9;&#9;Archivable = false;
&#9;&#9;}
&#9;end

&#9;function def:SetParent(parent)
&#9;&#9;for name,sound in pairs(sounds) do
&#9;&#9;&#9;sound.Parent = parent
&#9;&#9;end
&#9;end

&#9;function def:GetSound(name)
&#9;&#9;return sounds[name]
&#9;end

&#9;function def:StopSounds()
&#9;&#9;for name,sound in pairs(sounds) do
&#9;&#9;&#9;sound:Stop()
&#9;&#9;end
&#9;end

&#9;-- lazy get
&#9;setmetatable(def,{__index = sounds})
end)

--[[
ThreadID
&#9;Makes sure new threads override old ones.

&#9;CreateThreadID()
&#9;&#9;Returns a new ThreadID.
&#9;ThreadID:Request()
&#9;&#9;Returns a new ID and increments the current one.
&#9;ThreadID:Assert(id)
&#9;&#9;Returns whether the thread&apos;s ID equals the current one.
&#9;ThreadID:Reset()
&#9;&#9;Reset the current ID.
]]
class&apos;ThreadID&apos;(function(def)
&#9;local thread_id = 0

&#9;function def:Assert(id)
&#9;&#9;return thread_id == id
&#9;end

&#9;function def:Request()
&#9;&#9;thread_id = thread_id + 1
&#9;&#9;return thread_id
&#9;end

&#9;function def:Reset()
&#9;&#9;thread_id = 0
&#9;end
end)

--[[
BodyControl
&#9;Non-Anchored control over a part.

&#9;CreateBodyControl(part)
&#9;&#9;Returns a new BodyControl wrapped around `part`, a BasePart.
&#9;BodyControl:SetEnabled(enabled)
&#9;&#9;Sets whether the BodyControl is enabled.
&#9;BodyControl:SetCFrame(cframe)
&#9;&#9;Sets the CFrame of the BodyControl (position and orientation).
]]
class&apos;BodyControl&apos;(function(def,object)
&#9;local force_on = Vector3.new(math.huge,math.huge,math.huge)
&#9;local force_off = Vector3.new()

&#9;local BG = Instance.new(&quot;BodyGyro&quot;,object)
&#9;BG.Archivable = false
&#9;BG.D = 500
&#9;BG.P = 100000
&#9;BG.maxTorque = force_off

&#9;local BP = Instance.new(&quot;BodyPosition&quot;,object)
&#9;BP.Archivable = false
&#9;BP.D = 500
&#9;BP.P = 100000
&#9;BP.maxForce = force_off

&#9;function def:SetEnabled(enabled)
&#9;&#9;BP.maxForce = enabled and force_on or force_off
&#9;&#9;BG.maxTorque = enabled and force_on or force_off
&#9;end

&#9;function def:SetCFrame(cf)
&#9;&#9;BP.position = cf.p
&#9;&#9;BG.cframe = cf
&#9;end
end)

--[[
&#9;WalkSpeedManager
&#9;&#9;Manages a Humanoid&apos;s WalkSpeed.
&#9;&#9;When the walkspeed is set externally (not by this instance), the new value will become the base walkspeed.
&#9;&#9;However, the walkspeed can be locked. If so, the walkspeed will be reverted if it has been changed externally.
&#9;&#9;This allows the tool to be compatible with, say, a speed potion.

&#9;CreateWalkSpeedManager()
&#9;&#9;Returns a new WalkSpeedManager.
&#9;WalkSpeedManager:SetHumanoid(humanoid)
&#9;&#9;Sets the humanoid and sets its WalkSpeed as the base.
&#9;WalkSpeedManager:Set(walkspeed)
&#9;&#9;Sets and locks the humanoid&apos;s walkspeed.
&#9;WalkSpeedManager:Reset()
&#9;&#9;Unlocks and resets the humanoid&apos;s walkspeed to the base walkspeed.
&#9;WalkSpeedManager:GetBase()
&#9;&#9;Returns the base walkspeed.
]]
class&apos;WalkSpeedManager&apos;(function(def)
&#9;local baseWalkSpeed = 16
&#9;local currentWalkSpeed = 16
&#9;local locked = false
&#9;local settingInternal = false
&#9;local humanoid
&#9;local changed

&#9;function def:SetHumanoid(hum)
&#9;&#9;humanoid = hum
&#9;&#9;locked = false
&#9;&#9;if changed then changed:disconnect() end
&#9;&#9;if hum then
&#9;&#9;&#9;baseWalkSpeed = hum.WalkSpeed
&#9;&#9;&#9;currentWalkSpeed = baseWalkSpeed
&#9;&#9;&#9;changed = hum.Changed:connect(function(p)
&#9;&#9;&#9;&#9;if p == &quot;WalkSpeed&quot; and not settingInternal then
&#9;&#9;&#9;&#9;&#9;-- something external is modifying the walkspeed; use that as the base
&#9;&#9;&#9;&#9;&#9;baseWalkSpeed = hum.WalkSpeed
&#9;&#9;&#9;&#9;&#9;if locked then
&#9;&#9;&#9;&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;&#9;&#9;&#9;hum.WalkSpeed = currentWalkSpeed
&#9;&#9;&#9;&#9;&#9;&#9;settingInternal = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;function def:Set(ws)
&#9;&#9;if humanoid then
&#9;&#9;&#9;locked = true
&#9;&#9;&#9;currentWalkSpeed = ws
&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;humanoid.WalkSpeed = ws
&#9;&#9;&#9;settingInternal = false
&#9;&#9;end
&#9;end

&#9;function def:Reset()
&#9;&#9;if humanoid then
&#9;&#9;&#9;currentWalkSpeed = baseWalkSpeed
&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;humanoid.WalkSpeed = baseWalkSpeed
&#9;&#9;&#9;settingInternal = false
&#9;&#9;&#9;locked = false
&#9;&#9;end
&#9;end

&#9;function def:GetBase()
&#9;&#9;return baseWalkSpeed
&#9;end
end)

--[[
&#9;DamageManager
&#9;&#9;Manages damage using a queue or something.

&#9;CreateDamageManager()
&#9;&#9;Returns a new DamageManager.
&#9;DamageManager:SetDamageTable(table)
&#9;&#9;Sets a table of name/damage pairs to use.
&#9;&#9;The field [false] (as a bool) is the default damage if no damage is active.
&#9;&#9;`damage` can be a number or a function that returns the damage.
&#9;DamageManager:SetActive(name,active)
&#9;&#9;Sets whether `name` is active.
&#9;DamageManager:DeactivateAll()
&#9;&#9;Deactivates all damage.
&#9;DamageManager:GetDamage(...)
&#9;&#9;Returns the current damage.
&#9;&#9;If the current damage is a function, then received arguments are passed to that function.
]]
class&apos;DamageManager&apos;(function(def)
&#9;local damageTable = {}
&#9;local activeDamage = {false}&#9;-- a table of damage fields that are active
&#9;local damage = 0&#9;-- the current active damage

&#9;local function search_remove(t,k)
&#9;&#9;local i = 1
&#9;&#9;while i &lt;= #t do
&#9;&#9;&#9;if t[i] == k then
&#9;&#9;&#9;&#9;table.remove(t,i)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function def:SetDamageTable(dt)
&#9;&#9;damageTable = dt
&#9;&#9;for i in pairs(activeDamage) do
&#9;&#9;&#9;activeDamage[i] = nil
&#9;&#9;end
&#9;&#9;activeDamage[1] = false
&#9;&#9;if not damageTable[false] then
&#9;&#9;&#9;damageTable[false] = 0
&#9;&#9;end
&#9;&#9;damage = damageTable[false]
&#9;end

&#9;function def:SetActive(name,active)
&#9;&#9;search_remove(activeDamage,name)
&#9;&#9;if active then
&#9;&#9;&#9;table.insert(activeDamage,1,name)
&#9;&#9;end
&#9;&#9;damage = damageTable[activeDamage[1]]
&#9;end

&#9;function def:DeactivateAll()
&#9;&#9;for i in pairs(activeDamage) do
&#9;&#9;&#9;activeDamage[i] = nil
&#9;&#9;end
&#9;&#9;activeDamage[1] = false
&#9;&#9;damage = damageTable[false]
&#9;end

&#9;function def:GetDamage(...)
&#9;&#9;if type(damage) == &quot;function&quot; then
&#9;&#9;&#9;return damage(...)
&#9;&#9;else
&#9;&#9;&#9;return damage
&#9;&#9;end
&#9;end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect(&quot;EventName&quot;,...)]]
local Event = {}
local function Disconnect(...)
&#9;for _,name in pairs{...} do
&#9;&#9;if Event[name] then
&#9;&#9;&#9;Event[name]:disconnect()
&#9;&#9;&#9;Event[name] = nil
&#9;&#9;end
&#9;end
end

-- get an object; make it if it doesn&apos;t exist
local function GetMake(parent,name,type)
&#9;local object = parent:FindFirstChild(name)
&#9;if not object then
&#9;&#9;object = Create(type){Name=name}
&#9;&#9;object.Parent = parent
&#9;end
&#9;return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
&#9;while not parent:FindFirstChild(name) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
&#9;if object and object.Parent then
&#9;&#9;for i,v in pairs(object.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;return v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
&#9;local humanoid = GetHumanoid(object)
&#9;if humanoid then
&#9;&#9;return object.Parent,humanoid
&#9;end
&#9;return nil
end

-- make a joint, if the objects exist
local function AttemptJoint(x,y,c0,c1)
&#9;if x and y then
&#9;&#9;local weld = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;weld.Part0 = x
&#9;&#9;weld.Part1 = y
&#9;&#9;if c0 then weld.C0 = c0 end
&#9;&#9;if c1 then weld.C1 = c1 end
&#9;&#9;weld.Parent = x
&#9;end
end

-- destroy a joint used only by the two objects
local function KillJoint(x,y)
&#9;if x and y then
&#9;&#9;for i,v in pairs(x:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Motor6D&quot; then
&#9;&#9;&#9;&#9;if v.Part0 == x and v.Part1 == y then
&#9;&#9;&#9;&#9;&#9;v:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Tool = script.Parent
local Handle = WaitForChild(Tool,&quot;Handle&quot;)
local Character,Humanoid

local DamageBin = GetMake(Tool,&quot;DamageBin&quot;,&quot;Configuration&quot;)
local Spinning = GetMake(Tool,&quot;Spinning&quot;,&quot;BoolValue&quot;)

if not Tool:FindFirstChild(&quot;HandleFireTop&quot;) then
&#9;local HandleFire = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;HandleFireTop&quot;;
&#9;&#9;Parent = Tool;
&#9;&#9;Archivable = false;
&#9;&#9;Anchored = false;
&#9;&#9;CanCollide = false;
&#9;&#9;Locked = true;
&#9;&#9;Transparency = 1;
&#9;&#9;FormFactor = 0;
&#9;&#9;Size = Vector3.new(1,1,1);
&#9;&#9;TopSurface = 0;
&#9;&#9;BottomSurface = 0;
&#9;&#9;Create&apos;Fire&apos;{
&#9;&#9;&#9;Color = Color3.new(246/255,69/255,0);
&#9;&#9;&#9;SecondaryColor = Color3.new(102/255,0,102/255);
&#9;&#9;&#9;Heat = 9;
&#9;&#9;&#9;Size = 4;
&#9;&#9;}
&#9;}
&#9;AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi/2,0,0)*CFrame.new(0,0,3.5))
end

if not Tool:FindFirstChild(&quot;HandleFireBottom&quot;) then
&#9;local HandleFire = Create&apos;Part&apos;{
&#9;&#9;Name = &quot;HandleFireBottom&quot;;
&#9;&#9;Archivable = false;
&#9;&#9;Parent = Tool;
&#9;&#9;Anchored = false;
&#9;&#9;CanCollide = false;
&#9;&#9;Locked = true;
&#9;&#9;Transparency = 1;
&#9;&#9;FormFactor = 0;
&#9;&#9;Size = Vector3.new(1,1,1);
&#9;&#9;TopSurface = 0;
&#9;&#9;BottomSurface = 0;
&#9;&#9;Create&apos;Fire&apos;{
&#9;&#9;&#9;Color = Color3.new(1,0,0);
&#9;&#9;&#9;SecondaryColor = Color3.new(179/255,0,182/255);
&#9;&#9;&#9;Heat = 9;
&#9;&#9;&#9;Size = 4;
&#9;&#9;}
&#9;}
&#9;AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(-math.pi/2,0,0)*CFrame.new(0,0,-3.5))
end

local BurnScript = Tool:FindFirstChild(&quot;BurnScript&quot;)

local Damage = CreateDamageManager(Tool)
Damage:SetDamageTable{
&#9;[false]&#9;&#9;&#9;= 1;
&#9;[&quot;Attack&quot;]&#9;&#9;= 20;
&#9;[&quot;Spinning&quot;]&#9;= 0;
}

local spin_angle = 0.8
local max_spin_time = ( 3 )*30*spin_angle
local spin_slowdown = 1/4
local burn_ray_length = 8
local burn_chance = 1/6

local HandleControl = CreateBodyControl(Handle)
local WalkSpeed = CreateWalkSpeedManager()

local Animation = CreateAnimationProvider{
&#9;Standing = &quot;http://www.roblox.com/asset/?id=73177713&quot;;
&#9;Swing = &quot;http://www.roblox.com/asset/?id=73184276&quot;;
&#9;Spin = &quot;http://www.roblox.com/asset/?id=73177702&quot;;
}

local Sound = CreateSoundProvider{
&#9;Swoosh = &quot;http://www.roblox.com/asset/?id=46760716&quot;;
}
Sound:SetParent(Handle)
Sound.Swoosh.Volume = 0.25

local debugKeyframeReached = true

local Swinging = false
Animation:PrepareKeyframeCatcher(&quot;Swing&quot;,{
&#9;AnimationStart = function() -- never fires
&#9;&#9;debugKeyframeReached = false
&#9;&#9;Swinging = true
&#9;end;
&#9;AnimationEnd = function()
&#9;&#9;Swinging = false
&#9;end;
&#9;AttackStart = function()
&#9;&#9;if Swinging then
&#9;&#9;&#9;Damage:SetActive(&quot;Attack&quot;,true)
&#9;&#9;end
&#9;end;
&#9;AttackEnd = function()
&#9;&#9;Damage:SetActive(&quot;Attack&quot;,false)
&#9;end;
&#9;Swoosh = function()
&#9;&#9;if Swinging then
&#9;&#9;&#9;Sound.Swoosh.Pitch = math.random(120,123)/100
&#9;&#9;&#9;Sound.Swoosh:Play()
&#9;&#9;end
&#9;end;
})

-- if theres a character, get a body part from it
local function GetBodyPart(name)
&#9;local character = Character or GetCharacter(Tool)
&#9;if character then
&#9;&#9;local object = character:FindFirstChild(name)
&#9;&#9;if object then
&#9;&#9;&#9;return object
&#9;&#9;end
&#9;end
&#9;return nil
end

-- sets fire on Handle to center or ends
local function SwitchFire(name,mult,active)
&#9;local HandleFire = Tool:FindFirstChild(name)
&#9;if HandleFire then
&#9;&#9;local Fire = HandleFire:FindFirstChild(&quot;Fire&quot;)
&#9;&#9;if Fire then
&#9;&#9;&#9;if active then
&#9;&#9;&#9;&#9;AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi,0,0))
&#9;&#9;&#9;&#9;Fire.Heat = 25
&#9;&#9;&#9;&#9;Fire.Size = 10
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;AttemptJoint(Handle,HandleFire,nil,CFrame.Angles(math.pi/2*mult,0,0)*CFrame.new(0,0,3.5*mult))
&#9;&#9;&#9;&#9;Fire.Heat = 9
&#9;&#9;&#9;&#9;Fire.Size = 4
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- casts a ray that will burn a player if it hits
local function CastBurnRay()
&#9;if BurnScript then
&#9;&#9;local HandleFire = Tool:FindFirstChild(&quot;HandleFireTop&quot;)
&#9;&#9;if not HandleFire then
&#9;&#9;&#9;HandleFire = Tool:FindFirstChild(&quot;HandleFireBottom&quot;)
&#9;&#9;end
&#9;&#9;if HandleFire then
&#9;&#9;&#9;local cf = HandleFire.CFrame * CFrame.Angles(math.pi/2,0,0)
&#9;&#9;&#9;local ch = GetCharacter(Tool)
&#9;&#9;&#9;local Hit = Workspace:FindPartOnRay(Ray.new(cf.p,cf.lookVector*burn_ray_length),ch)
&#9;&#9;&#9;if GetHumanoid(Hit) then
&#9;&#9;&#9;&#9;local burn = BurnScript:Clone()
&#9;&#9;&#9;&#9;burn.Disabled = false
&#9;&#9;&#9;&#9;burn.Parent = Hit
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- does the spinning animation
local SpinThread = CreateThreadID()
local function StartSpin(Torso)
&#9;local id = SpinThread:Request()
&#9;Animation.Spin:Play(0.25,1,1.5)
&#9;Handle.CanCollide = false
&#9;wait(0.25) -- eww
&#9;if SpinThread:Assert(id) then
&#9;&#9;Animation.Spin:Play(0,1,1.5) -- fixes bug
&#9;&#9;Damage:SetActive(&quot;Spinning&quot;,true)
&#9;&#9;Spinning.Value = true
&#9;&#9;WalkSpeed:Set(WalkSpeed:GetBase()*spin_slowdown)
&#9;&#9;KillJoint(GetBodyPart(&quot;Right Arm&quot;),Handle)
&#9;&#9;HandleControl:SetEnabled(true)
&#9;&#9;SwitchFire(&quot;HandleFireTop&quot;,1,true)
&#9;&#9;SwitchFire(&quot;HandleFireBottom&quot;,-1,true)
&#9;&#9;local a = 0
&#9;&#9;local s = 0
&#9;&#9;local off = CFrame.new(0,0.5,-2) * CFrame.Angles(math.pi/2,0,0)
&#9;&#9;while SpinThread:Assert(id) do
&#9;&#9;&#9;HandleControl:SetCFrame(Torso.CFrame * off * CFrame.Angles(0,a,0))
&#9;&#9;&#9;a = a + spin_angle
&#9;&#9;&#9;s = s - 1
&#9;&#9;&#9;if a &gt; max_spin_time then break end
&#9;&#9;&#9;if s &lt;= 0 then
&#9;&#9;&#9;&#9;s = 5
&#9;&#9;&#9;&#9;Sound.Swoosh.Pitch = math.random(125,128)/100
&#9;&#9;&#9;&#9;Sound.Swoosh:Play()
&#9;&#9;&#9;end
&#9;&#9;&#9;if math.random() &lt; burn_chance then
&#9;&#9;&#9;&#9;CastBurnRay()
&#9;&#9;&#9;end
&#9;&#9;&#9;wait()
&#9;&#9;end
&#9;end
&#9;Animation.Spin:Stop(0.25)
&#9;SwitchFire(&quot;HandleFireTop&quot;,1,false)
&#9;SwitchFire(&quot;HandleFireBottom&quot;,-1,false)
&#9;HandleControl:SetEnabled(false)
&#9;AttemptJoint(GetBodyPart(&quot;Right Arm&quot;),Handle,CFrame.new(0,-1,0))
&#9;WalkSpeed:Reset()
&#9;Damage:SetActive(&quot;Spinning&quot;,false)
&#9;Spinning.Value = false
&#9;wait(0.25) -- eww
&#9;Handle.CanCollide = true
end

Tool.Equipped:connect(function(Mouse)
&#9;Character,Humanoid = GetCharacter(Tool)
&#9;if not Character then return end
&#9;Animation:LoadHumanoid(Humanoid)
&#9;WalkSpeed:SetHumanoid(Humanoid)

&#9;do&#9;-- replace the interfering RightGrip joint
&#9;&#9;local RightArm = GetBodyPart(&quot;Right Arm&quot;)
&#9;&#9;if RightArm then
&#9;&#9;&#9;WaitForChild(RightArm,&quot;RightGrip&quot;)
&#9;&#9;&#9;wait()
&#9;&#9;&#9;AttemptJoint(RightArm,Handle,CFrame.new(0,-1,0))
&#9;&#9;end
&#9;end

&#9;Animation.Standing:Play()

&#9;local Torso = GetBodyPart(&quot;Torso&quot;)
&#9;local clicktime = 0
&#9;Mouse.Button1Down:connect(function()
&#9;&#9;local t = tick()
&#9;&#9;if t-clicktime &lt; 0.2 then&#9;-- double-click
&#9;&#9;&#9;clicktime = t
&#9;&#9;&#9;Animation.Swing:Stop(0)
&#9;&#9;&#9;Swinging = false
&#9;&#9;&#9;Damage:SetActive(&quot;Attack&quot;,false)
&#9;&#9;&#9;StartSpin(Torso)
&#9;&#9;else&#9;&#9;&#9;&#9;&#9;&#9;-- single-click
&#9;&#9;&#9;clicktime = t
&#9;&#9;&#9;Swinging = true
&#9;&#9;&#9;Animation.Swing:Play(0.1,1,1.25)
&#9;&#9;&#9;if debugKeyframeReached then
&#9;&#9;&#9;&#9;Sound.Swoosh.Pitch = math.random(120,123)/100
&#9;&#9;&#9;&#9;Sound.Swoosh:Play()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;Mouse.Button1Up:connect(function()
&#9;&#9;SpinThread:Request() --sloppy
&#9;&#9;Animation.Swing:Stop(0.25)
&#9;&#9;Swinging = false
&#9;&#9;Damage:SetActive(&quot;Attack&quot;,false)
&#9;end)

&#9;Event.Died = Humanoid.Died:connect(function()
&#9;&#9;SpinThread:Reset()
&#9;&#9;Swinging = false
&#9;&#9;Damage:SetActive(&quot;Attack&quot;,false)
&#9;end)

&#9;Event.Touched = Handle.Touched:connect(function(hit)
&#9;&#9;if not hit:IsDescendantOf(Character) then
&#9;&#9;&#9;local humanoid = GetHumanoid(hit)
&#9;&#9;&#9;if humanoid then
&#9;&#9;&#9;&#9;local dtag = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = tostring(Damage:GetDamage());
&#9;&#9;&#9;&#9;&#9;Value = humanoid;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;dtag.Parent = DamageBin
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;wait(0.25) --ewww
&#9;Handle.CanCollide = true
end)

Tool.Unequipped:connect(function()
&#9;Disconnect(&quot;Died&quot;,&quot;Touched&quot;)
&#9;Animation:StopAnimations()
&#9;KillJoint(GetBodyPart(&quot;Right Arm&quot;),Handle)
&#9;Swinging = false
&#9;Spinning.Value = false
&#9;Damage:DeactivateAll()
&#9;SpinThread:Reset()
&#9;WalkSpeed:Reset()
&#9;WalkSpeed:SetHumanoid()
&#9;HandleControl:SetEnabled(false)
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX4">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Damage</string>
				<ProtectedString name="Source">local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

local function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

class&apos;Signal&apos;(function(this)
&#9;local mListeners = {}
&#9;local mWaitObject = Create&apos;BoolValue&apos;{}

&#9;function this:connect(func)
&#9;&#9;local connection = {}
&#9;&#9;function connection:disconnect()
&#9;&#9;&#9;mListeners[func] = nil
&#9;&#9;end
&#9;&#9;mListeners[func] = connection
&#9;&#9;return connection
&#9;end

&#9;function this:fire(...)
&#9;&#9;for func, conn in pairs(mListeners) do
&#9;&#9;&#9;func(...)
&#9;&#9;end
&#9;&#9;mWaitObject.Value = not mWaitObject.Value
&#9;end

&#9;function this:wait()
&#9;&#9;mWaitObject.Changed:wait()
&#9;end
end)

--[[
&#9;DamageReducer
&#9;&#9;Reduces damage taken to humanoid by a specified percentage.

&#9;CreateDamageReducer()
&#9;&#9;Returns a new DamageReducer.
&#9;DamageReducer:SetHumanoid(humanoid)
&#9;&#9;Sets the humanoid. `humanoid` can be nil.
&#9;DamageReducer:SetActive(active)
&#9;&#9;Sets whether the damage reducer is active.
&#9;DamageReducer:SetReduction(pct)
&#9;&#9;Sets the amount of damage reduction as a percentage.
]]
class&apos;DamageReducer&apos;(function(def)
&#9;local reduction = 0
&#9;local active = false
&#9;local humanoid
&#9;local changed

&#9;local function connect_changed()
&#9;&#9;if not changed then
&#9;&#9;&#9;local e = true
&#9;&#9;&#9;local last_health = humanoid.Health
&#9;&#9;&#9;changed = humanoid.HealthChanged:connect(function(health)
&#9;&#9;&#9;&#9;if e then
&#9;&#9;&#9;&#9;&#9;e = false
&#9;&#9;&#9;&#9;&#9;if health &lt; last_health then
&#9;&#9;&#9;&#9;&#9;&#9;local damage = math.abs(health - last_health)
&#9;&#9;&#9;&#9;&#9;&#9;humanoid.Health = health + damage*reduction
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;e = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;last_health = humanoid.Health
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;local function disconnect_changed()
&#9;&#9;if changed then
&#9;&#9;&#9;changed:disconnect()
&#9;&#9;&#9;changed = nil
&#9;&#9;end
&#9;end

&#9;function def:SetHumanoid(h)
&#9;&#9;if changed then
&#9;&#9;&#9;disconnect_changed()
&#9;&#9;end
&#9;&#9;humanoid = h
&#9;&#9;if h and active then
&#9;&#9;&#9;connect_changed()
&#9;&#9;end
&#9;end

&#9;function def:SetReduction(pct)
&#9;&#9;reduction = pct &lt; 0 and 0 or pct &gt; 1 and 1 or pct
&#9;end

&#9;function def:SetActive(a)
&#9;&#9;active = a
&#9;&#9;if a then
&#9;&#9;&#9;connect_changed()
&#9;&#9;else
&#9;&#9;&#9;disconnect_changed()
&#9;&#9;end
&#9;end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect(&quot;EventName&quot;,...)]]
local Event = {}
local function Disconnect(...)
&#9;for _,name in pairs{...} do
&#9;&#9;if Event[name] then
&#9;&#9;&#9;Event[name]:disconnect()
&#9;&#9;&#9;Event[name] = nil
&#9;&#9;end
&#9;end
end

-- get an object; make it if it doesn&apos;t exist
local function GetMake(parent,name,type)
&#9;local object = parent:FindFirstChild(name)
&#9;if not object then
&#9;&#9;object = Create(type){Name=name}
&#9;&#9;object.Parent = parent
&#9;end
&#9;return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
&#9;while not parent:FindFirstChild(name) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
&#9;if object and object.Parent then
&#9;&#9;for i,v in pairs(object.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;return v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
&#9;local humanoid = GetHumanoid(object)
&#9;if humanoid then
&#9;&#9;return object.Parent,humanoid
&#9;end
&#9;return nil
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Players = Game:GetService(&quot;Players&quot;)
local Debris = Game:GetService(&quot;Debris&quot;)

local Tool = script.Parent
local Handle = WaitForChild(Tool,&quot;Handle&quot;)
local BurnScript = Tool:FindFirstChild(&quot;BurnScript&quot;)
local DamageBin = WaitForChild(Tool,&quot;DamageBin&quot;)
local Spinning = WaitForChild(Tool,&quot;Spinning&quot;)

local DamageReducer = CreateDamageReducer()
DamageReducer:SetReduction(0.25)

Spinning.Changed:connect(function(value)
&#9;DamageReducer:SetActive(value)
end)

Tool.Equipped:connect(function()
&#9;local Character,Humanoid = GetCharacter(Tool)
&#9;local Player = Players:GetPlayerFromCharacter(Character)

&#9;if BurnScript then
&#9;&#9;local ctag = GetMake(BurnScript,&quot;creator&quot;,&quot;ObjectValue&quot;)
&#9;&#9;ctag.Value = Player
&#9;end

&#9;DamageReducer:SetHumanoid(Humanoid)

&#9;Event.DamageBin = DamageBin.ChildAdded:connect(function(dtag)
&#9;&#9;if dtag:IsA&quot;ObjectValue&quot; then
&#9;&#9;&#9;local humanoid = dtag.Value
&#9;&#9;&#9;local damage = tonumber(dtag.Name)
&#9;&#9;&#9;if humanoid and damage then
&#9;&#9;&#9;&#9;local ctag = Create&apos;ObjectValue&apos;{
&#9;&#9;&#9;&#9;&#9;Name = &quot;creator&quot;;
&#9;&#9;&#9;&#9;&#9;Value = Player;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;&#9;ctag.Parent = humanoid
&#9;&#9;&#9;&#9;humanoid:TakeDamage(damage)
&#9;&#9;&#9;&#9;Debris:AddItem(ctag,1)
&#9;&#9;&#9;&#9;Debris:AddItem(dtag,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
end)

Tool.Unequipped:connect(function()
&#9;DamageReducer:SetHumanoid()
&#9;Disconnect(&quot;DamageBin&quot;)
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX5">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BurnScript</string>
				<ProtectedString name="Source">local damage = 2
local interval = 0.5

local Debris = Game:GetService(&quot;Debris&quot;)
local BodyPart = script.Parent
local Humanoid
do
&#9;if BodyPart.Parent then
&#9;&#9;for i,v in pairs(BodyPart.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;Humanoid = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

if Humanoid then
&#9;local Fire = Instance.new(&quot;Fire&quot;,BodyPart)
&#9;Fire.Color = Color3.new(246/255,69/255,0)
&#9;Fire.SecondaryColor = Color3.new(102/255,0,102/255)
&#9;script.Parent = Fire

&#9;local died = false
&#9;Humanoid.Died:connect(function() died = true end)

&#9;local CreatorTag = script:FindFirstChild(&quot;creator&quot;)
&#9;if CreatorTag then
&#9;&#9;CreatorTag = CreatorTag:Clone()
&#9;&#9;while not died do
&#9;&#9;&#9;local ctag = CreatorTag:Clone()
&#9;&#9;&#9;ctag.Parent = Humanoid
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;Debris:AddItem(ctag,interval)
&#9;&#9;&#9;wait(interval)
&#9;&#9;end
&#9;else
&#9;&#9;while not died do
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;wait(interval)
&#9;&#9;end
&#9;end
end
script:Destroy()</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX6">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>30.0748558</X>
					<Y>6.87266016</Y>
					<Z>27.8593006</Z>
					<R00>0.997801602</R00>
					<R01>0.0202767048</R01>
					<R02>-0.0630945489</R02>
					<R10>-1.86264515e-009</R10>
					<R11>0.952044845</R11>
					<R12>0.305958748</R12>
					<R20>0.0662726685</R20>
					<R21>-0.305286139</R21>
					<R22>0.949951768</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>31.3082047</X>
					<Y>0.891891956</Y>
					<Z>9.38999557</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>