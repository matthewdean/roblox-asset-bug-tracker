<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">false</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>-1</R00>
				<R01>0</R01>
				<R02>-8.74227766e-008</R02>
				<R10>-8.74227766e-008</R10>
				<R11>-4.37113883e-008</R11>
				<R12>1</R12>
				<R20>-3.82137093e-015</R20>
				<R21>1</R21>
				<R22>4.37113883e-008</R22>
			</CoordinateFrame>
			<string name="Name">CelestialStaff</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=84102386</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-0.5</X>
					<Y>2.30000019</Y>
					<Z>-0.5</Z>
					<R00>-0</R00>
					<R01>-1</R01>
					<R02>0</R02>
					<R10>-0</R10>
					<R11>-0</R11>
					<R12>1</R12>
					<R20>-1</R20>
					<R21>-0</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">3</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>1</Y>
					<Z>4.5</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=84102534</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.5</X>
						<Y>1.5</Y>
						<Z>1.5</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=84102498</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<ProtectedString name="Source">local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

local function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

--[[----------------------------------------------------------------------------
AnimationProvider
&#9;Manages animations.

&#9;CreateAnimationProvider(animations)
&#9;&#9;Returns a new AnimationProvider instance.
&#9;&#9;`animations` is a table containing identity/asset_id pairs.
&#9;&#9;`asset_id` may be a string (Content) or an integer.
&#9;AnimationProvider:LoadHumanoid(humanoid)
&#9;&#9;Loads the animations into `humanoid`.
&#9;AnimationProvider:GetAnimation(identity)
&#9;&#9;Returns an AnimationTrack.
&#9;&#9;May only be called after LoadHumanoid.
&#9;AnimationProvider:StopAnimations()
&#9;&#9;Stops all animations.
&#9;&#9;May only be called after LoadHumanoid.
]]
class&apos;AnimationProvider&apos;(function(def,anim_ids)
&#9;local animations = {}
&#9;local animationTracks = {}
&#9;local catcherCallbacks = {}
&#9;local keyframeCatchers = {}
&#9;local workingHumanoid

&#9;for name,id in pairs(anim_ids) do
&#9;&#9;animations[name] = Create&apos;Animation&apos;{
&#9;&#9;&#9;Name = name;
&#9;&#9;&#9;AnimationId = type(id) == &quot;number&quot; and (&quot;rbxassetid://&quot;..id) or id;
&#9;&#9;&#9;Archivable = false;
&#9;&#9;}
&#9;end

&#9;function def:LoadHumanoid(humanoid)
&#9;&#9;if humanoid ~= workingHumanoid then
&#9;&#9;&#9;workingHumanoid = humanoid
&#9;&#9;&#9;for name,anim in pairs(animations) do
&#9;&#9;&#9;&#9;local old_track = animationTracks[name]
&#9;&#9;&#9;&#9;if old_track then
&#9;&#9;&#9;&#9;&#9;old_track:Stop()
&#9;&#9;&#9;&#9;&#9;old_track:Destroy()
&#9;&#9;&#9;&#9;&#9;if keyframeCatchers[name] then
&#9;&#9;&#9;&#9;&#9;&#9;keyframeCatchers[name] = nil
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local track = humanoid:LoadAnimation(anim)
&#9;&#9;&#9;&#9;animationTracks[name] = track
&#9;&#9;&#9;&#9;if catcherCallbacks[name] then
&#9;&#9;&#9;&#9;&#9;local catcher = CreateKeyframeCatcher(track)
&#9;&#9;&#9;&#9;&#9;keyframeCatchers[name] = catcher
&#9;&#9;&#9;&#9;&#9;catcher:SetCallbacks(catcherCallbacks[name])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;function def:GetAnimation(name)
&#9;&#9;if not workingHumanoid then
&#9;&#9;&#9;error(&quot;GetAnimation: humanoid has not been loaded&quot;,2)
&#9;&#9;end
&#9;&#9;return animationTracks[name]
&#9;end

&#9;function def:StopAnimations()
&#9;&#9;for name,track in pairs(animationTracks) do
&#9;&#9;&#9;track:Stop()
&#9;&#9;end
&#9;end

&#9;-- lazy get
&#9;setmetatable(def,{__index = animationTracks})
end)


--[[
SoundProvider
&#9;Manages sounds.

&#9;CreateSoundProvider(sounds)
&#9;&#9;Returns a new SoundProvider.
&#9;&#9;`sounds` is a table containing identity/asset_id pairs.
&#9;&#9;`asset_id` may be a string (Content) or an integer.
&#9;SoundProvider:SetParent(parent)
&#9;&#9;Sets the parent of all the sounds at once. Can be nil.
&#9;SoundProvider:GetSound(identity)
&#9;&#9;Returns a Sound.
&#9;SoundProvider:StopSounds()
&#9;&#9;Stops all sounds.
&#9;SoundProvider:Fade(identity, goal, time, delta)
&#9;&#9;Applies a fading effect to a Sound, starting with the current volume.
&#9;&#9;`goal` is the volume to reach by the end of the transition.
&#9;&#9;`time` is the amount of time the transition should take, in seconds.
&#9;&#9;Optionally, `delta` is a function that transforms the progress of the fade (for non-linear transitions)
]]
class&apos;SoundProvider&apos;(function(def,sound_ids)
&#9;local sounds = {}

&#9;local CP = Game:GetService(&quot;ContentProvider&quot;)

&#9;for name,id in pairs(sound_ids) do
&#9;&#9;sounds[name] = Create&apos;Sound&apos;{
&#9;&#9;&#9;Name = name;
&#9;&#9;&#9;SoundId = type(id) == &quot;number&quot; and (&quot;rbxassetid://&quot;..id) or id;
&#9;&#9;&#9;Archivable = false;
&#9;&#9;}
&#9;&#9;CP:Preload(sounds[name].SoundId)
&#9;end

&#9;function def:SetParent(parent)
&#9;&#9;for name,sound in pairs(sounds) do
&#9;&#9;&#9;sound.Parent = parent
&#9;&#9;end
&#9;end

&#9;function def:GetSound(name)
&#9;&#9;return sounds[name]
&#9;end

&#9;function def:StopSounds()
&#9;&#9;for name,sound in pairs(sounds) do
&#9;&#9;&#9;sound:Stop()
&#9;&#9;end
&#9;end

&#9;function def:Fade(name,g,t,delta)
&#9;&#9;local sound = sounds[name]
&#9;&#9;delta = delta or function(n) return n end
&#9;&#9;if sound then
&#9;&#9;&#9;local s = sound.Volume
&#9;&#9;&#9;local i = 0
&#9;&#9;&#9;while i &lt; 1 do
&#9;&#9;&#9;&#9;i = i + wait()/t
&#9;&#9;&#9;&#9;sound.Volume = (g-s)*delta(i)+s
&#9;&#9;&#9;end
&#9;&#9;&#9;sound.Volume = g
&#9;&#9;else
&#9;&#9;&#9;error(&quot;SoundProvider::Fade: no such sound named `&quot;..name..&quot;`&quot;,2)
&#9;&#9;end
&#9;end

&#9;-- lazy get
&#9;setmetatable(def,{__index = sounds})
end)

--[[
ThreadID
&#9;Makes sure new threads override old ones.

&#9;CreateThreadID()
&#9;&#9;Returns a new ThreadID.
&#9;ThreadID:Request()
&#9;&#9;Returns a new ID and increments the current one.
&#9;ThreadID:Assert(id)
&#9;&#9;Returns whether the thread&apos;s ID equals the current one.
&#9;ThreadID:Reset()
&#9;&#9;Reset the current ID.
]]
class&apos;ThreadID&apos;(function(def)
&#9;local thread_id = 0

&#9;function def:Assert(id)
&#9;&#9;return thread_id == id
&#9;end

&#9;function def:Request()
&#9;&#9;thread_id = thread_id + 1
&#9;&#9;return thread_id
&#9;end

&#9;function def:Reset()
&#9;&#9;thread_id = 0
&#9;end
end)

--[[
&#9;WalkSpeedManager
&#9;&#9;Manages a Humanoid&apos;s WalkSpeed.
&#9;&#9;When the walkspeed is set externally (not by this instance), the new value will become the base walkspeed.
&#9;&#9;However, the walkspeed can be locked. If so, the walkspeed will be reverted if it has been changed externally.
&#9;&#9;This allows the tool to be compatible with, say, a speed potion.

&#9;CreateWalkSpeedManager()
&#9;&#9;Returns a new WalkSpeedManager.
&#9;WalkSpeedManager:SetHumanoid(humanoid)
&#9;&#9;Sets the humanoid and sets its WalkSpeed as the base.
&#9;WalkSpeedManager:Set(walkspeed)
&#9;&#9;Sets and locks the humanoid&apos;s walkspeed.
&#9;WalkSpeedManager:Reset()
&#9;&#9;Unlocks and resets the humanoid&apos;s walkspeed to the base walkspeed.
&#9;WalkSpeedManager:GetBase()
&#9;&#9;Returns the base walkspeed.
]]
class&apos;WalkSpeedManager&apos;(function(def)
&#9;local baseWalkSpeed = 16
&#9;local currentWalkSpeed = 16
&#9;local locked = false
&#9;local settingInternal = false
&#9;local humanoid
&#9;local changed

&#9;function def:SetHumanoid(hum)
&#9;&#9;humanoid = hum
&#9;&#9;locked = false
&#9;&#9;if changed then changed:disconnect() end
&#9;&#9;if hum then
&#9;&#9;&#9;baseWalkSpeed = hum.WalkSpeed
&#9;&#9;&#9;currentWalkSpeed = baseWalkSpeed
&#9;&#9;&#9;changed = hum.Changed:connect(function(p)
&#9;&#9;&#9;&#9;if p == &quot;WalkSpeed&quot; and not settingInternal then
&#9;&#9;&#9;&#9;&#9;-- something external is modifying the walkspeed; use that as the base
&#9;&#9;&#9;&#9;&#9;baseWalkSpeed = hum.WalkSpeed
&#9;&#9;&#9;&#9;&#9;if locked then
&#9;&#9;&#9;&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;&#9;&#9;&#9;hum.WalkSpeed = currentWalkSpeed
&#9;&#9;&#9;&#9;&#9;&#9;settingInternal = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;function def:Set(ws)
&#9;&#9;if humanoid then
&#9;&#9;&#9;locked = true
&#9;&#9;&#9;currentWalkSpeed = ws
&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;humanoid.WalkSpeed = ws
&#9;&#9;&#9;settingInternal = false
&#9;&#9;end
&#9;end

&#9;function def:Reset()
&#9;&#9;if humanoid then
&#9;&#9;&#9;currentWalkSpeed = baseWalkSpeed
&#9;&#9;&#9;settingInternal = true
&#9;&#9;&#9;humanoid.WalkSpeed = baseWalkSpeed
&#9;&#9;&#9;settingInternal = false
&#9;&#9;&#9;locked = false
&#9;&#9;end
&#9;end

&#9;function def:GetBase()
&#9;&#9;return baseWalkSpeed
&#9;end
end)

--[[
LightingTime
&#9;Manages lighting transition.

&#9;CreateLightingTime ( number `acceleration`, number `deceleration`, number `max_velocity` )
&#9;&#9;All three arguments measure in hours.
&#9;:Start ( ThreadID `thread`, number `currentID` )
&#9;&#9;Starts up the transition with `thread` and `currentID` to determine whether to accelerate or decelerate.
&#9;:Stop ( )
&#9;&#9;Immediately stops the transition.
&#9;:GetExternalCount ( )
&#9;&#9;Returns the amount of times the TimeOfDay has been changed externally.
&#9;:ResetExternalCount ( )
&#9;&#9;Reset external change count.
&#9;&#9;
]]
class&apos;LightingTime&apos;(function(def,accel,decel,max)
&#9;-- convert number (in hours) to TimeOfDay string
&#9;-- because TimeOfDay doesn&apos;t cast numbers as expected (3.7 -&gt; 03:07:00 instead of 3:42:00)
&#9;local function ToTimeOfDay(n)
&#9;&#9;n = n % 24
&#9;&#9;local i,f = math.modf(n)
&#9;&#9;local m = f*60
&#9;&#9;local mi,mf = math.modf(m)
&#9;&#9;m = tostring(math.abs(math.floor(m)))
&#9;&#9;local s = tostring(math.abs(math.floor(mf*60)))
&#9;&#9;return i..&quot;:&quot;..string.rep(&quot;0&quot;,2-#m)..m..&quot;:&quot;..string.rep(&quot;0&quot;,2-#s)..s
&#9;end

&#9;-- convert TimeOfDay string to number (in hours)
&#9;local function FromTimeOfDay(t)
&#9;&#9;local signed,h,m,s = t:match(&quot;^(%-?)(%d+):(%d+):(%d+)$&quot;)
&#9;&#9;s = tonumber(s)/60
&#9;&#9;m = tonumber(m + s)/60
&#9;&#9;h = tonumber(h) + m
&#9;&#9;return h * (#signed &gt; 0 and -1 or 1)
&#9;end

&#9;local Lighting = Game:GetService(&quot;Lighting&quot;)
&#9;local threadRunning = false
&#9;local setInternal = false
&#9;local time = FromTimeOfDay(Lighting.TimeOfDay)
&#9;local velocity = 0
&#9;local exCount = 0
&#9;local threadID
&#9;local cID

&#9;max = max * 0.03

&#9;local con = Lighting.Changed:connect(function(p)
&#9;&#9;if p == &quot;TimeOfDay&quot; then
&#9;&#9;&#9;if not setInternal then
&#9;&#9;&#9;&#9;exCount = exCount + 1
&#9;&#9;&#9;&#9;threadRunning = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)
&#9;
&#9;function def:Reset()
&#9;&#9;setInternal = false
&#9;&#9;velocity = 0
&#9;end

&#9;function def:ResetExternalCount()
&#9;&#9;exCount = 0
&#9;end

&#9;function def:GetExternalCount()
&#9;&#9;return exCount
&#9;end

&#9;local function NewThread()
&#9;&#9;coroutine.wrap(function()
&#9;&#9;&#9;threadRunning = true
&#9;&#9;&#9;time = FromTimeOfDay(Lighting.TimeOfDay)
&#9;&#9;&#9;while threadRunning do
&#9;&#9;&#9;&#9;local t = wait()
&#9;&#9;&#9;&#9;if threadID:Assert(cID) then
&#9;&#9;&#9;&#9;&#9;velocity = velocity + accel*t
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;velocity = velocity - accel*t
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if velocity &gt; max then
&#9;&#9;&#9;&#9;&#9;velocity = max
&#9;&#9;&#9;&#9;elseif velocity &lt; 0 then
&#9;&#9;&#9;&#9;&#9;threadRunning = false
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;time = time + velocity

&#9;&#9;&#9;&#9;setInternal = true
&#9;&#9;&#9;&#9;Lighting.TimeOfDay = ToTimeOfDay(time)
&#9;&#9;&#9;&#9;setInternal = false
&#9;&#9;&#9;end
&#9;&#9;&#9;def:Reset()
&#9;&#9;end)()
&#9;end

&#9;function def:Start(thread,cid)
&#9;&#9;threadID = thread
&#9;&#9;cID = cid
&#9;&#9;if not threadRunning then
&#9;&#9;&#9;NewThread()
&#9;&#9;end
&#9;end

&#9;function def:Stop()
&#9;&#9;threadRunning = false
&#9;end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- Tiny Event Manager; Add: [[Event.EventName = (event)]]; Remove: [[Disconnect(&quot;EventName&quot;,...)]]
local Event = {}
local function Disconnect(...)
&#9;for _,name in pairs{...} do
&#9;&#9;if Event[name] then
&#9;&#9;&#9;Event[name]:disconnect()
&#9;&#9;&#9;Event[name] = nil
&#9;&#9;end
&#9;end
end

-- get an object; make it if it doesn&apos;t exist
local function GetMake(parent,name,type)
&#9;local object = parent:FindFirstChild(name)
&#9;if not object then
&#9;&#9;object = Create(type){Name=name}
&#9;&#9;object.Parent = parent
&#9;end
&#9;return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
&#9;while not parent:FindFirstChild(name) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
&#9;if object and object.Parent then
&#9;&#9;for i,v in pairs(object.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;return v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
&#9;local humanoid = GetHumanoid(object)
&#9;if humanoid then
&#9;&#9;return object.Parent,humanoid
&#9;end
&#9;return nil
end

-- make a joint, if the objects exist
local function AttemptJoint(x,y,c0,c1)
&#9;if x and y then
&#9;&#9;local weld = Instance.new(&quot;Motor6D&quot;)
&#9;&#9;weld.Part0 = x
&#9;&#9;weld.Part1 = y
&#9;&#9;if c0 then weld.C0 = c0 end
&#9;&#9;if c1 then weld.C1 = c1 end
&#9;&#9;weld.Parent = x
&#9;&#9;return weld
&#9;end
end

-- destroy a joint used only by the two objects
local function KillJoint(x,y)
&#9;if x and y then
&#9;&#9;for i,v in pairs(x:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Motor6D&quot; then
&#9;&#9;&#9;&#9;if v.Part0 == x and v.Part1 == y then
&#9;&#9;&#9;&#9;&#9;v:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--SETTINGS----------------------------------------------------------------------

-- Time velocity when transitioning
local time_acceleration&#9;= ( 1/2 )*1/60&#9;-- minutes per second
local time_deceleration&#9;= ( 1 )*1/60&#9;-- minutes per second
local max_time_velocity&#9;= ( 1/2 )&#9;&#9;-- hours per second

-- Magic circle shield
local charge_time&#9;= 1&#9;&#9;-- amount of time before circle is fully charged
local decharge_time&#9;= 0.5&#9;-- amount of time before circle is completely decharged
local spin_velocity&#9;= 90&#9;-- degrees per second
local circle_size&#9;= 24&#9;-- max diameter of circle

-- Missiles
local missile_range&#9;= 48&#9;-- range in which humanoids will be detected
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- size == [n, volume_limit/(n*n), n]/2
local missile_delay&#9;= 0.5&#9;-- the amount of time (in seconds) between each missile
local missile_speed&#9;= 24

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Tool = script.Parent
local Handle = WaitForChild(Tool,&quot;Handle&quot;)
local Character,Humanoid

local magicEnabled = true
local canMagic = true

local BurnScript = WaitForChild(Tool,&quot;BurnScript&quot;)
local BindScript = WaitForChild(Tool,&quot;BindScript&quot;)

local ShieldActive = GetMake(Tool,&quot;ShieldActive&quot;,&quot;BoolValue&quot;)
ShieldActive.Value = false

local WalkSpeed = CreateWalkSpeedManager()

local Animation = CreateAnimationProvider{
&#9;Wave&#9;= &quot;http://www.roblox.com/asset/?id=83994332&quot;;
&#9;Raised&#9;= &quot;http://www.roblox.com/asset/?id=83994319&quot;;
}                   

local Sound = CreateSoundProvider{
&#9;SunBurst&#9;= &quot;http://www.roblox.com/asset/?id=16433289&quot;;
&#9;MoonBurst&#9;= &quot;http://www.roblox.com/asset/?id=84005018&quot;;
}

local CircleTemplate = Create&apos;Part&apos;{
&#9;Name = &quot;CelestialCircle&quot;;
&#9;Anchored = true;
&#9;CanCollide = false;
&#9;Transparency = 1;
&#9;FormFactor = Enum.FormFactor.Custom;
&#9;TopSurface = Enum.SurfaceType.Smooth;
&#9;BottomSurface = Enum.SurfaceType.Smooth;
&#9;Create&apos;Decal&apos;{
&#9;&#9;Name = &quot;DecalTop&quot;;
&#9;&#9;Face = Enum.NormalId.Top;
&#9;&#9;Texture = &quot;http://www.roblox.com/asset/?id=78036587&quot;;
&#9;};
&#9;Create&apos;Decal&apos;{
&#9;&#9;Name = &quot;DecalBottom&quot;;
&#9;&#9;Face = Enum.NormalId.Bottom;
&#9;&#9;Texture = &quot;http://www.roblox.com/asset/?id=78036587&quot;;
&#9;};
&#9;Create&apos;BlockMesh&apos;{
&#9;&#9;Scale = Vector3.new(1,0,1);
&#9;};
};

-- if theres a character, get a body part from it
local function GetBodyPart(name)
&#9;local character = Character or GetCharacter(Tool)
&#9;if character then
&#9;&#9;local object = character:FindFirstChild(name)
&#9;&#9;if object then
&#9;&#9;&#9;return object
&#9;&#9;end
&#9;end
&#9;return nil
end

local LightingTime = CreateLightingTime(time_acceleration,time_deceleration,max_time_velocity)

local Missiles = {
&#9;{&#9;-- moon
&#9;&#9;is_active = function()
&#9;&#9;&#9;return Game:GetService(&quot;Lighting&quot;):GetMoonDirection():Dot(Vector3.new(0,1,0)) &gt; 0;
&#9;&#9;end;
&#9;&#9;fire = function(origin,target)
&#9;&#9;&#9;local missile = Create&apos;Part&apos;{
&#9;&#9;&#9;&#9;Name = &quot;CelestialMissile&quot;;
&#9;&#9;&#9;&#9;FormFactor = 0;
&#9;&#9;&#9;&#9;TopSurface = 0;
&#9;&#9;&#9;&#9;BottomSurface = 0;
&#9;&#9;&#9;&#9;Reflectance = 0.5;
&#9;&#9;&#9;&#9;BrickColor = BrickColor.new(&quot;Bright yellow&quot;);
&#9;&#9;&#9;&#9;CanCollide = false;
&#9;&#9;&#9;&#9;Locked = true;
&#9;&#9;&#9;&#9;Size = Vector3.new(4,4,1);
&#9;&#9;&#9;&#9;Create&apos;SpecialMesh&apos;{
&#9;&#9;&#9;&#9;&#9;MeshId = &quot;http://www.roblox.com/asset/?id=3270017&quot;;
&#9;&#9;&#9;&#9;&#9;Scale = Vector3.new(4,4,4);
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;Create&apos;Sparkles&apos;{
&#9;&#9;&#9;&#9;&#9;SparkleColor = Color3.new(1,1,0);
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;Create&apos;BodyVelocity&apos;{
&#9;&#9;&#9;&#9;&#9;maxForce = Vector3.new(math.huge,math.huge,math.huge);
&#9;&#9;&#9;&#9;&#9;velocity = Vector3.new(0,0,0);
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;&#9;SoundId = Sound.MoonBurst.SoundId;
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;}
&#9;&#9;&#9;local bv = missile.BodyVelocity
&#9;&#9;&#9;local particle = missile.Sparkles
&#9;&#9;&#9;missile.CFrame = CFrame.new(origin,target) --* CFrame.Angles(-math.pi/2,0,0)
&#9;&#9;&#9;bv.velocity = (target-origin).unit*missile_speed
&#9;&#9;&#9;local con;con = missile.Touched:connect(function(hit)
&#9;&#9;&#9;&#9;if not hit:IsDescendantOf(Character) and hit.Name ~= &quot;CelestialMissile&quot; then
&#9;&#9;&#9;&#9;&#9;local h = GetHumanoid(hit)
&#9;&#9;&#9;&#9;&#9;if h and h.Health &gt; 0 and h.Torso then
&#9;&#9;&#9;&#9;&#9;&#9;local bind = BindScript:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;bind.Disabled = false
&#9;&#9;&#9;&#9;&#9;&#9;bind.Parent = h.Torso
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;con:disconnect()
&#9;&#9;&#9;&#9;&#9;missile.Anchored = true
&#9;&#9;&#9;&#9;&#9;missile.Transparency = 1
&#9;&#9;&#9;&#9;&#9;particle.Enabled = false
&#9;&#9;&#9;&#9;&#9;wait(1) -- particles cut off if Fire object is removed, which looks ugly
&#9;&#9;&#9;&#9;&#9;missile:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;local sound = missile.Sound
&#9;&#9;&#9;missile.Parent = Workspace
&#9;&#9;&#9;sound:Play()
&#9;&#9;&#9;Game:GetService(&quot;Debris&quot;):AddItem(missile,5)
&#9;&#9;end;
&#9;};
&#9;{&#9;-- sun
&#9;&#9;is_active = function()
&#9;&#9;&#9;return Game:GetService(&quot;Lighting&quot;):GetSunDirection():Dot(Vector3.new(0,1,0)) &gt; 0;
&#9;&#9;end;
&#9;&#9;fire = function(origin,target)
&#9;&#9;&#9;local missile = Create&apos;Part&apos;{
&#9;&#9;&#9;&#9;Name = &quot;CelestialMissile&quot;;
&#9;&#9;&#9;&#9;FormFactor = 0;
&#9;&#9;&#9;&#9;Shape = 0;
&#9;&#9;&#9;&#9;TopSurface = 0;
&#9;&#9;&#9;&#9;BottomSurface = 0;
&#9;&#9;&#9;&#9;Transparency = 0.5;
&#9;&#9;&#9;&#9;BrickColor = BrickColor.new(&quot;Deep orange&quot;);
&#9;&#9;&#9;&#9;CanCollide = false;
&#9;&#9;&#9;&#9;Locked = true;
&#9;&#9;&#9;&#9;Size = Vector3.new(3,3,3);
&#9;&#9;&#9;&#9;Create&apos;Fire&apos;{};
&#9;&#9;&#9;&#9;Create&apos;BodyVelocity&apos;{
&#9;&#9;&#9;&#9;&#9;maxForce = Vector3.new(math.huge,math.huge,math.huge);
&#9;&#9;&#9;&#9;&#9;velocity = Vector3.new(0,0,0);
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;&#9;Create&apos;Sound&apos;{
&#9;&#9;&#9;&#9;&#9;SoundId = Sound.SunBurst.SoundId;
&#9;&#9;&#9;&#9;};
&#9;&#9;&#9;}
&#9;&#9;&#9;local bv = missile.BodyVelocity
&#9;&#9;&#9;local particle = missile.Fire
&#9;&#9;&#9;missile.CFrame = CFrame.new(origin,target) * CFrame.Angles(-math.pi/2,0,0)
&#9;&#9;&#9;bv.velocity = (target-origin).unit*missile_speed
&#9;&#9;&#9;local con;con = missile.Touched:connect(function(hit)
&#9;&#9;&#9;&#9;if not hit:IsDescendantOf(Character) and hit.Name ~= &quot;CelestialMissile&quot; then
&#9;&#9;&#9;&#9;&#9;if GetHumanoid(hit) then
&#9;&#9;&#9;&#9;&#9;&#9;local burn = BurnScript:Clone()
&#9;&#9;&#9;&#9;&#9;&#9;burn.Disabled = false
&#9;&#9;&#9;&#9;&#9;&#9;burn.Parent = hit
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;con:disconnect()
&#9;&#9;&#9;&#9;&#9;missile.Anchored = true
&#9;&#9;&#9;&#9;&#9;missile.Transparency = 1
&#9;&#9;&#9;&#9;&#9;particle.Enabled = false
&#9;&#9;&#9;&#9;&#9;wait(1) -- particles cut off if Fire object is removed, which looks ugly
&#9;&#9;&#9;&#9;&#9;missile:Destroy()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;local sound = missile.Sound
&#9;&#9;&#9;missile.Parent = Workspace
&#9;&#9;&#9;sound:Play()
&#9;&#9;&#9;Game:GetService(&quot;Debris&quot;):AddItem(missile,5)
&#9;&#9;end;
&#9;};
}

local function FireMissiles(origin)

&#9;-- get missiles that are active
&#9;local activeMissiles = {}
&#9;for i = 1,#Missiles do
&#9;&#9;local missile = Missiles[i]
&#9;&#9;if missile.is_active() then
&#9;&#9;&#9;activeMissiles[#activeMissiles+1] = missile.fire
&#9;&#9;end
&#9;end
&#9;if #activeMissiles == 0 then return end

&#9;local humanoidList = {}
&#9;do&#9;-- get a list of humanoids within a region
&#9;&#9;local region_vec = Vector3.new(missile_range,math.floor(10^5/(missile_range*missile_range)),missile_range)/2
&#9;&#9;local missile_region = Region3.new(origin-region_vec,origin+region_vec)
&#9;&#9;local partsList = Workspace:FindPartsInRegion3(missile_region,Character,100)
&#9;&#9;local parentCache = {}
&#9;&#9;for i,part in pairs(partsList) do
&#9;&#9;&#9;local parent = part.Parent
&#9;&#9;&#9;if not parentCache[parent] then
&#9;&#9;&#9;&#9;parentCache[parent] = true
&#9;&#9;&#9;&#9;local h = GetHumanoid(part)
&#9;&#9;&#9;&#9;if h and h.Health &gt; 0 then
&#9;&#9;&#9;&#9;&#9;humanoidList[#humanoidList+1] = h
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if #humanoidList == 0 then return end

&#9;-- randomize humanoid list
&#9;for i = 1,#humanoidList do
&#9;&#9;local r = math.random(1,#humanoidList)
&#9;&#9;humanoidList[i],humanoidList[r] = humanoidList[r],humanoidList[i]
&#9;end

&#9;-- fire random missile in each humanoid&apos;s direction
&#9;for i = 1,#humanoidList do
&#9;&#9;local humanoid = humanoidList[i]
&#9;&#9;local pos
&#9;&#9;do
&#9;&#9;&#9;local target = humanoid.Torso
&#9;&#9;&#9;if target then
&#9;&#9;&#9;&#9;pos = target.Position
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if pos then
&#9;&#9;&#9;local missile = activeMissiles[math.random(1,#activeMissiles)]
&#9;&#9;&#9;coroutine.wrap(missile)(origin,pos)
&#9;&#9;&#9;wait(missile_delay)
&#9;&#9;end
&#9;end
end

local ClickThread = CreateThreadID()
Tool.Equipped:connect(function(Mouse)
&#9;Character,Humanoid = GetCharacter(Tool)
&#9;if not Character then return end
&#9;Animation:LoadHumanoid(Humanoid)
&#9;WalkSpeed:SetHumanoid(Humanoid)

&#9;local Torso = GetBodyPart(&quot;Torso&quot;)

&#9;do&#9;-- replace the interfering RightGrip joint
&#9;&#9;local RightArm = GetBodyPart(&quot;Right Arm&quot;)
&#9;&#9;if RightArm then
&#9;&#9;&#9;local grip = WaitForChild(RightArm,&quot;RightGrip&quot;)
&#9;&#9;&#9;local C0,C1 = grip.C0,grip.C1
&#9;&#9;&#9;wait()
&#9;&#9;&#9;AttemptJoint(RightArm,Handle,C0,C1)
&#9;&#9;end
&#9;end

&#9;local down = false
&#9;Mouse.Button1Down:connect(function()
&#9;&#9;if canMagic and GetBodyPart(&quot;Right Arm&quot;) then
---- READY MAGIC
&#9;&#9;&#9;local cid = ClickThread:Request()

&#9;&#9;&#9;LightingTime:ResetExternalCount()

&#9;&#9;&#9;Animation.Raised:Play(0.25)
&#9;&#9;&#9;wait(0.25)
&#9;&#9;&#9;if not ClickThread:Assert(cid) then return end
&#9;&#9;&#9;Animation.Wave:Play()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;if not ClickThread:Assert(cid) then return end

---- DO MAGIC
&#9;&#9;&#9;canMagic = false
&#9;&#9;&#9;WalkSpeed:Set(0)

&#9;&#9;&#9;if LightingTime:GetExternalCount() == 0 then
&#9;&#9;&#9;&#9;LightingTime:Start(ClickThread,cid)
&#9;&#9;&#9;end

&#9;&#9;&#9;local Circle = CircleTemplate:Clone()
&#9;&#9;&#9;Circle.Size = Vector3.new(circle_size,16,circle_size)
&#9;&#9;&#9;Circle.Parent = Character
&#9;&#9;&#9;local top = Circle.DecalTop
&#9;&#9;&#9;local bottom = Circle.DecalBottom
&#9;&#9;&#9;local pos = Circle.Position
&#9;&#9;&#9;local charge,spin = 0,0
&#9;&#9;&#9;while ClickThread:Assert(cid) do
&#9;&#9;&#9;&#9;local t = wait()
&#9;&#9;&#9;&#9;charge = charge + t/charge_time
&#9;&#9;&#9;&#9;if charge &gt;= 1 then
&#9;&#9;&#9;&#9;&#9;charge = 1
&#9;&#9;&#9;&#9;&#9;ShieldActive.Value = true
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;ShieldActive.Value = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;spin = spin + spin_velocity*t
&#9;&#9;&#9;&#9;local c = 1-math.pow(1-charge,2)
&#9;&#9;&#9;&#9;Circle.Mesh.Scale = Vector3.new(c,0,c)
&#9;&#9;&#9;&#9;top.Transparency = 1-c
&#9;&#9;&#9;&#9;bottom.Transparency = 1-c
&#9;&#9;&#9;&#9;Circle.CFrame = CFrame.new(Torso.Position+Vector3.new(0,-2,0)) * CFrame.Angles(0,-math.rad(spin),0)
&#9;&#9;&#9;end

---- FIRE MISSILES
&#9;&#9;&#9;if charge &gt;= 1 then
&#9;&#9;&#9;&#9;Spawn(function()
&#9;&#9;&#9;&#9;&#9;FireMissiles(Torso.Position)
&#9;&#9;&#9;&#9;&#9;WalkSpeed:Reset()
&#9;&#9;&#9;&#9;&#9;canMagic = true
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;WalkSpeed:Reset()
&#9;&#9;&#9;&#9;canMagic = true
&#9;&#9;&#9;end

---- CLEANUP MAGIC
&#9;&#9;&#9;ShieldActive.Value = false

&#9;&#9;&#9;local pos = Circle.Position
&#9;&#9;&#9;local size = Circle.Mesh.Scale.x
&#9;&#9;&#9;local opac = 1-top.Transparency
&#9;&#9;&#9;charge = 1
&#9;&#9;&#9;ShieldActive.Value = false
&#9;&#9;&#9;while charge &gt; 0 do
&#9;&#9;&#9;&#9;local t = wait()
&#9;&#9;&#9;&#9;charge = charge - t/decharge_time
&#9;&#9;&#9;&#9;spin = spin + spin_velocity*t
&#9;&#9;&#9;&#9;local c = (1-math.pow(1-charge,2))*size
&#9;&#9;&#9;&#9;Circle.Mesh.Scale = Vector3.new(c,0,c)
&#9;&#9;&#9;&#9;top.Transparency = 1-charge*opac
&#9;&#9;&#9;&#9;bottom.Transparency = 1-charge*opac
&#9;&#9;&#9;&#9;Circle.CFrame = CFrame.new(pos) * CFrame.Angles(0,-math.rad(spin),0)
&#9;&#9;&#9;end
&#9;&#9;&#9;Circle:Destroy()
&#9;&#9;end
&#9;end)

&#9;Mouse.Button1Up:connect(function()
&#9;&#9;local cid = ClickThread:Request()
&#9;&#9;Animation.Wave:Stop(0.1)
&#9;&#9;wait(0.1)
&#9;&#9;if not ClickThread:Assert(cid) then return end
&#9;&#9;Animation.Raised:Stop()
&#9;end)
end)

Tool.Unequipped:connect(function()
&#9;ShieldActive.Value = false
&#9;KillJoint(GetBodyPart(&quot;Right Arm&quot;),Handle)
&#9;ClickThread:Reset()
&#9;Animation:StopAnimations()
&#9;Sound:StopSounds()
&#9;WalkSpeed:Reset()
end)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX4">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Damage</string>
				<ProtectedString name="Source">local function class(name)
&#9;local def = {}
&#9;getfenv(0)[name] = def
&#9;return function(ctor, static)
&#9;&#9;local nctor = function(...)
&#9;&#9;&#9;local this = {}
&#9;&#9;&#9;if ctor then
&#9;&#9;&#9;&#9;ctor(this, ...)
&#9;&#9;&#9;end
&#9;&#9;&#9;return this
&#9;&#9;end
&#9;&#9;getfenv(0)[&apos;Create&apos;..name] = nctor
&#9;&#9;if static then static(def) end
&#9;end
end

local function Create(ty)
&#9;return function(data)
&#9;&#9;local obj = Instance.new(ty)
&#9;&#9;for k, v in pairs(data) do
&#9;&#9;&#9;if type(k) == &apos;number&apos; then
&#9;&#9;&#9;&#9;v.Parent = obj
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;obj[k] = v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return obj
&#9;end
end

--[[
&#9;DamageReducer
&#9;&#9;Reduces damage taken to humanoid by a specified percentage.

&#9;CreateDamageReducer()
&#9;&#9;Returns a new DamageReducer.
&#9;DamageReducer:SetHumanoid(humanoid)
&#9;&#9;Sets the humanoid. `humanoid` can be nil.
&#9;DamageReducer:SetActive(active)
&#9;&#9;Sets whether the damage reducer is active.
&#9;DamageReducer:SetReduction(pct)
&#9;&#9;Sets the amount of damage reduction as a percentage.
]]
class&apos;DamageReducer&apos;(function(def)
&#9;local reduction = 0
&#9;local active = false
&#9;local humanoid
&#9;local changed

&#9;local function disconnect_changed()
&#9;&#9;if changed then
&#9;&#9;&#9;changed:disconnect()
&#9;&#9;&#9;changed = nil
&#9;&#9;end
&#9;end

&#9;local function connect_changed()
&#9;&#9;if humanoid then
&#9;&#9;&#9;disconnect_changed()
&#9;&#9;&#9;local e = true
&#9;&#9;&#9;local last_health = humanoid.Health
&#9;&#9;&#9;changed = humanoid.HealthChanged:connect(function(health)
&#9;&#9;&#9;&#9;if e then
&#9;&#9;&#9;&#9;&#9;e = false
&#9;&#9;&#9;&#9;&#9;if health &lt; last_health then
&#9;&#9;&#9;&#9;&#9;&#9;local damage = math.abs(health - last_health)
&#9;&#9;&#9;&#9;&#9;&#9;humanoid.Health = health + damage*reduction
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;e = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;last_health = humanoid.Health
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;function def:SetHumanoid(h)
&#9;&#9;humanoid = h
&#9;&#9;if h and active then
&#9;&#9;&#9;connect_changed()
&#9;&#9;end
&#9;end

&#9;function def:SetReduction(pct)
&#9;&#9;reduction = pct &lt; 0 and 0 or pct &gt; 1 and 1 or pct
&#9;end

&#9;function def:SetActive(a)
&#9;&#9;active = a
&#9;&#9;if a then
&#9;&#9;&#9;connect_changed()
&#9;&#9;else
&#9;&#9;&#9;disconnect_changed()
&#9;&#9;end
&#9;end
end)

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-- get an object; make it if it doesn&apos;t exist
local function GetMake(parent,name,type)
&#9;local object = parent:FindFirstChild(name)
&#9;if not object then
&#9;&#9;object = Create(type){Name=name}
&#9;&#9;object.Parent = parent
&#9;end
&#9;return object
end

-- wait until child exists; return child
local function WaitForChild(parent,name)
&#9;while not parent:FindFirstChild(name) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
&#9;return parent:FindFirstChild(name)
end

-- get a sibling humanoid of object; by humanoid, not by name
local function GetHumanoid(object)
&#9;if object and object.Parent then
&#9;&#9;for i,v in pairs(object.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;return v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

-- get the parent character from an object; verified by GetHumanoid
local function GetCharacter(object)
&#9;local humanoid = GetHumanoid(object)
&#9;if humanoid then
&#9;&#9;return object.Parent,humanoid
&#9;end
&#9;return nil
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local Players = Game:GetService(&quot;Players&quot;)
local Debris = Game:GetService(&quot;Debris&quot;)

local Tool = script.Parent
local Handle = WaitForChild(Tool,&quot;Handle&quot;)
local BurnScript = Tool:FindFirstChild(&quot;BurnScript&quot;)
local ShieldActive = WaitForChild(Tool,&quot;ShieldActive&quot;)

local DamageReducer = CreateDamageReducer()
DamageReducer:SetReduction(0.5)

ShieldActive.Changed:connect(function(value)
&#9;DamageReducer:SetActive(value)
end)

Tool.Equipped:connect(function()
&#9;local Character,Humanoid = GetCharacter(Tool)
&#9;local Player = Players:GetPlayerFromCharacter(Character)

&#9;BurnScript = Tool:FindFirstChild(&quot;BurnScript&quot;)
&#9;if BurnScript then
&#9;&#9;local ctag = GetMake(BurnScript,&quot;creator&quot;,&quot;ObjectValue&quot;)
&#9;&#9;ctag.Value = Player
&#9;end

&#9;DamageReducer:SetHumanoid(Humanoid)
end)

Tool.Unequipped:connect(function()
&#9;DamageReducer:SetHumanoid()
end)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX5">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BurnScript</string>
				<ProtectedString name="Source">local damage = 2
local interval = 0.5

local Debris = Game:GetService(&quot;Debris&quot;)
local BodyPart = script.Parent
local Humanoid
do
&#9;if BodyPart.Parent then
&#9;&#9;for i,v in pairs(BodyPart.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;Humanoid = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

if Humanoid then
&#9;local Fire = Instance.new(&quot;Fire&quot;,BodyPart)
&#9;script.Parent = Fire

&#9;local died = false
&#9;Humanoid.Died:connect(function() died = true end)

&#9;local CreatorTag = script:FindFirstChild(&quot;creator&quot;)
&#9;if CreatorTag then
&#9;&#9;CreatorTag = CreatorTag:Clone()
&#9;&#9;while not died do
&#9;&#9;&#9;local ctag = CreatorTag:Clone()
&#9;&#9;&#9;ctag.Parent = Humanoid
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;Debris:AddItem(ctag,interval)
&#9;&#9;&#9;wait(interval)
&#9;&#9;end
&#9;else
&#9;&#9;while not died do
&#9;&#9;&#9;Humanoid:TakeDamage(damage)
&#9;&#9;&#9;wait(interval)
&#9;&#9;end
&#9;end
end
script:Destroy()</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX6">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BindScript</string>
				<ProtectedString name="Source">local bind_time = 5

local Debris = Game:GetService(&quot;Debris&quot;)
local BodyPart = script.Parent
local Humanoid
do
&#9;if BodyPart.Parent then
&#9;&#9;for i,v in pairs(BodyPart.Parent:GetChildren()) do
&#9;&#9;&#9;if v:IsA&quot;Humanoid&quot; then
&#9;&#9;&#9;&#9;Humanoid = v
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

if Humanoid then
&#9;local oWalkSpeed = Humanoid.WalkSpeed
&#9;Humanoid.WalkSpeed = 0

&#9;local bind0 = Instance.new(&quot;Part&quot;)
&#9;bind0.Name = &quot;CelestialMissile&quot;
&#9;bind0.FormFactor = 0
&#9;bind0.TopSurface = 0
&#9;bind0.BottomSurface = 0
&#9;bind0.Reflectance = 0.5
&#9;bind0.BrickColor = BrickColor.new(&quot;Bright yellow&quot;)
&#9;bind0.Anchored = true
&#9;bind0.CanCollide = false
&#9;bind0.Locked = true
&#9;bind0.Size = Vector3.new(4,4,1)
&#9;&#9;local mesh = Instance.new(&quot;SpecialMesh&quot;,bind0)
&#9;&#9;mesh.MeshId = &quot;http://www.roblox.com/asset/?id=3270017&quot;
&#9;&#9;mesh.Scale = Vector3.new(4,4,4)
&#9;local bind1 = bind0:Clone()
&#9;&#9;local p = Instance.new(&quot;Sparkles&quot;,bind1)
&#9;&#9;p.SparkleColor = Color3.new(1,1,0)
&#9;bind0.Parent = script
&#9;bind1.Parent = script

&#9;local start = tick()
&#9;local spin = 0
&#9;while script.Parent do
&#9;&#9;bind0.CFrame = BodyPart.CFrame * CFrame.Angles(math.rad(spin),-math.rad(spin*2),math.rad(spin))
&#9;&#9;bind1.CFrame = BodyPart.CFrame * CFrame.Angles(-math.rad(spin),math.rad(spin),math.rad(spin))
&#9;&#9;spin = spin + 90*wait()
&#9;&#9;if tick()-start &gt; bind_time then break end
&#9;end
&#9;for i=0,1,0.1 do
&#9;&#9;bind0.Transparency = i
&#9;&#9;bind1.Transparency = i
&#9;&#9;bind0.CFrame = BodyPart.CFrame * CFrame.Angles(math.rad(spin),-math.rad(spin*2),math.rad(spin))
&#9;&#9;bind1.CFrame = BodyPart.CFrame * CFrame.Angles(-math.rad(spin),math.rad(spin),math.rad(spin))
&#9;&#9;spin = spin + 90*wait()
&#9;end
&#9;Humanoid.WalkSpeed = oWalkSpeed &gt; 0 and oWalkSpeed or 16
&#9;bind0:Destroy()
&#9;bind1:Destroy()
end
script:Destroy()</ProtectedString>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX7">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>4.2886734</X>
					<Y>2.05584955</Y>
					<Z>-2.04162693</Z>
					<R00>-0.328868985</R00>
					<R01>0.181813791</R01>
					<R02>0.926708698</R02>
					<R10>3.72528985e-009</R10>
					<R11>0.981292486</R11>
					<R12>-0.192522764</R12>
					<R20>-0.944375515</R20>
					<R21>-0.0633147657</R21>
					<R22>-0.322716683</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-14.2455025</X>
					<Y>5.90630531</Y>
					<Z>4.41270781</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">ThumbnailCamera</string>
			</Properties>
		</Item>
	</Item>
</roblox>